<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:lang="hu">    
    
    <info xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">

    <title xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Magasabb szintű programozási nyelvek I.</title>               

    <subtitle xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Labor jegyzőkönyv</subtitle>               

    <titleabbrev xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX KÖNYV</titleabbrev>               

    <authorgroup xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <author>
        <personname>
            <honorific>Dr</honorific>
            <surname>Bátfai</surname>
            <firstname>Norbert</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>E. adjunktus, DE.</shortaffil>
            <jobtitle>Egyetemi adjunktus</jobtitle>
            <orgname>Debreceni Egyetem</orgname>
            <orgdiv>Információtechnológiai Tanszék</orgdiv>
            <address>
                <email>batfai.norbert@inf.unideb.hu</email>
                <email>nbatfai@gmail.com</email>
            </address>
        </affiliation>
        <address>
            <street>Kassai út 26.</street>
            <city>Debrecen</city>
            <postcode>4028</postcode>
            <country>Magyarország</country>
            <email>batfai.norbert@inf.unideb.hu</email>
            <otheraddr>
                <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/">https://arato.inf.unideb.hu/batfai.norbert/</link>
            </otheraddr>
        </address>
    </author>   
    <author>
        <personname>       
            <surname>Bátfai</surname>
            <firstname>Mátyás</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>tanuló</shortaffil>
            <jobtitle>tanuló</jobtitle>
            <orgname>Debreceni Hunyadi János Általános Iskola</orgname>
            <orgdiv>6/c</orgdiv>
            <address>
                <email>batfai.matyi@gmail.com</email>               
            </address>
        </affiliation>               
    </author>  
    
    <author>
        <personname>       
            <surname>Bátfai</surname>
            <firstname>Nándor</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>tanuló</shortaffil>
            <jobtitle>tanuló</jobtitle>
            <orgname>Debreceni Hunyadi János Általános Iskola</orgname>
            <orgdiv>4/c</orgdiv>
            <address>
                <email>batfai.nandi@gmail.com</email>               
            </address>
        </affiliation>               
    </author>  
    
    <author>
        <personname>       
            <surname>Bátfai</surname>
            <firstname>Margaréta</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>tanuló</shortaffil>
            <jobtitle>tanuló</jobtitle>
            <orgname>Debreceni Hunyadi János Általános Iskola</orgname>
            <orgdiv>4/c</orgdiv>
            <address>
                <email>batfai.greta@gmail.com</email>               
            </address>
        </affiliation>               
    </author>
    <author>
        <personname>       
            <surname>Human</surname>
            <firstname>Person</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>guy</shortaffil>
            <jobtitle>guy</jobtitle>
            <orgname>Earth</orgname>
            <orgdiv>Mammals</orgdiv>
            <address>
                <email>aprettydecentaddress@gmail.com</email>               
            </address>
        </affiliation>               
    </author>  
</authorgroup>               

    <edition xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX, DEBRECEN, 2020. február 22, v. 0.0.5</edition>               

    <pubdate>2019</pubdate>
    <copyright>
        <year>2019</year>
        <holder>Dr. Bátfai Norbert</holder>
    </copyright>
    <legalnotice>           
        <para>                
            Copyright (C) 2019, Norbert Bátfai Ph.D., batfai.norbert@inf.unideb.hu, nbatfai@gmail.com, 
        </para>
        <para>
            Permission is granted to copy, distribute and/or modify this document
            under the terms of the GNU Free Documentation License, Version 1.3
            or any later version published by the Free Software Foundation;
            with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
            A copy of the license is included in the section entitled "GNU
            Free Documentation License".                
        </para>
        <para>
            <link xlink:href="https://www.gnu.org/licenses/fdl.html">https://www.gnu.org/licenses/fdl.html</link>                
        </para>
            
        <para>
            Engedélyt adunk Önnek a jelen dokumentum sokszorosítására, terjesztésére és/vagy módosítására 
            a Free Software Foundation által kiadott GNU FDL 1.3-as, vagy bármely azt követő verziójának 
            feltételei alapján. Nincs Nem Változtatható szakasz, nincs Címlapszöveg, nincs Hátlapszöveg.                
        </para>
        <para>
            <link xlink:href="http://gnu.hu/fdl.html">http://gnu.hu/fdl.html</link>                
        </para>
    </legalnotice>   
    
    <revhistory xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <revision>
        <revnumber>0.0.1</revnumber>
        <date>2019-02-12</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az iniciális dokumentum szerkezetének kialakítása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.2</revnumber>
        <date>2019-02-14</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Inciális feladatlisták összeállítása.
        </revremark>
    </revision>    
    <revision>
        <revnumber>0.0.3</revnumber>
        <date>2019-02-16</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Feladatlisták folytatása.
            Feltöltés a BHAX csatorna 
            <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
            repójába.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.4</revnumber>
        <date>2019-02-19</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            A Brun tételes feladat kidolgozása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.5</revnumber>
        <date>2020-02-15</date>
        <authorinitials>rkeeves</authorinitials>
        <revremark>
            Forked and inited bhax derived <link xlink:href="https://github.com/rkeeves/bhax-derived">bhax-derived</link>
        </revremark>
    </revision>
</revhistory>               
                               
</info>     
        
    <dedication xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>

    </para>
<blockquote>
    <attribution>Gregory Chaitin, <citetitle>META MATH! The Quest for Omega</citetitle>, <citation>METAMATH</citation></attribution>
    <para>
        „To me, you understand something only if you can program it.  
        (You, not someone else!)  Otherwise you don’t really understand it, 
        you only think you understand it.”
    </para>
</blockquote>
</dedication>     
    
    <preface xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Előszó</title>
    <para xml:id="bhax-textbook-pre.Eloszo">
        Amikor programozónak terveztem állni, ellenezték a környezetemben, mondván, hogy kell  
        szövegszerkesztő meg táblázatkezelő, de az már van... nem lesz programozói munka.
    </para>                 
    <para>
        Tévedtek. Hogy egy generáció múlva kell-e még tömegesen hús-vér programozó vagy
        olcsóbb lesz allokálni igény szerint pár robot programozót a felhőből?
        A programozók dolgozók lesznek vagy papok?
        Ki tudhatná ma. 
    </para>
    <para>
        Mindenesetre a programozás a teoretikus kultúra csúcsa. A GNU mozgalomban látom annak 
        garanciáját, hogy ebben a szellemi kalandban a gyerekeim is részt vehessenek majd. Ezért programozunk.
    </para>          
    <section>
        <title>Hogyan forgasd</title>
        <para>
            A könyv célja egy stabil programozási szemlélet kialakítása az olvasóban. Módszere, hogy hetekre 
            bontva ad egy tematikus feladatcsokrot. Minden feladathoz megadja a megoldás forráskódját és forrásokat
            feldolgozó videókat.
            Az olvasó feladata, hogy ezek tanulmányozása után maga adja meg a feladat megoldásának lényegi
            magyarázatát, avagy írja meg a könyvet.
        </para>
        <para>
            Miért univerzális? Mert az olvasótól (kvázi az írótól) függ, hogy kinek szól a könyv. 
            Alapértelmezésben gyerekeknek, mert velük készítem az iniciális változatot. 
            Ám tervezem felhasználását az egyetemi programozás oktatásban is. Ahogy szélesedni tudna a 
            felhasználók köre, akkor lehetne kiadása különböző korosztályú gyerekeknek, családoknak, 
            szakköröknek, programozás kurzusoknak, felnőtt és továbbképzési műhelyeknek és sorolhatnánk... 
        </para>
        <section>
            <title>Milyen nyelven nyomjuk?</title>
            <para>
                C (mutatók), C++ (másoló és mozgató szemantika) és Java (lebutított C++) nyelvekből kell egy jó alap, 
                ezt kell kiegészíteni pár R (vektoros szemlélet), Python (gépi tanulás bevezető), Lisp és Prolog (hogy lássuk
                mást is) példával.
            </para>
        </section>
        <section>
            <title>Hogyan nyomjuk?</title>
            <para>
                Rántsd le a <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
                git repót, vagy méginkább forkolj belőle magadnak egy sajátot a GitLabon, ha már saját könyvön dolgozol!
            
                <screen><![CDATA[]]></screen> 
            
            </para>
            <para>
                Ha megvannak a könyv DocBook XML forrásai, 
                akkor az alább látható <command>make</command> parancs ellenőrzi, hogy „jól formázottak” és 
                „érvényesek-e” ezek az XML források, majd 
                elkészíti a <application>dblatex</application> programmal a könyved pdf változatát, íme:
                <screen><![CDATA[batfai@entropy:~$ cd glrepos/bhax/thematic_tutorials/bhax_textbook/
batfai@entropy:~/glrepos/bhax/thematic_tutorials/bhax_textbook$ make
rm -f bhax-textbook-fdl.pdf
xmllint --xinclude bhax-textbook-fdl.xml --output output.xml
xmllint --relaxng http://docbook.org/xml/5.0/rng/docbookxi.rng output.xml --noout
output.xml validates
rm -f output.xml	
dblatex bhax-textbook-fdl.xml -p bhax-textbook.xls
Build the book set list...
Build the listings...
XSLT stylesheets DocBook - LaTeX 2e (0.3.10)
===================================================
Stripping NS from DocBook 5/NG document.
Processing stripped document.
Image 'dblatex' not found
Build bhax-textbook-fdl.pdf
'bhax-textbook-fdl.pdf' successfully built]]></screen>             

            Ha minden igaz, akkor most éppen ezt a legenerált <filename>bhax-textbook-fdl.pdf</filename> fájlt olvasod.
            </para>
<tip>
              <title>A DocBook XML 5.1 új neked?</title>
              <para>
                  Ez esetben forgasd a <link xlink:href="https://tdg.docbook.org/tdg/5.1/">https://tdg.docbook.org/tdg/5.1/</link>
                  könyvet, a végén találod az informatikai szövegek jelölésére használható gazdag „API” elemenkénti
                  bemutatását.                  
              </para>            
            </tip>            
        </section>
        
    </section>            

</preface> 

    <!-- 
        <xi:include href="bhax-textbook-glossary.xml">
            <xi:fallback>
                <para>
                    <emphasis>XInclude: bhax-textbook-glossary.xml file not found</emphasis>
                </para>
            </xi:fallback>
        </xi:include> 
    -->

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Bevezetés</title>
    <partintro>
        <para> 
        </para>
    </partintro>
    <chapter>
        <info>
            <title>Vízió</title>
            <keywordset>
                <keyword/>
            </keywordset>
        </info>
        <section>
            <title>Mi a programozás?</title>
            <para>
                Ne cifrázzuk: programok írása. Mik akkor a programok? Mit jelent az írásuk?
            </para>
        </section>
        <section>
            <title>Milyen doksikat olvassak el?</title>
            <itemizedlist>
                <listitem>
                    <para>Kezd ezzel: <link xlink:href="http://esr.fsf.hu/hacker-howto.html">http://esr.fsf.hu/hacker-howto.html</link>!</para>                        
                </listitem>
                <listitem>
                    <para>Olvasgasd aztán a kézikönyv lapjait, kezd a <command>man man</command> parancs kiadásával. A C programozásban
                    a 3-as szintű lapokat fogod nézegetni, például az első feladat kapcsán ezt a 
                    <command>man 3 sleep</command> lapot</para>                        
                </listitem>
                <listitem>
                    <para>C kapcsán a <citation>KERNIGHANRITCHIE</citation> könyv adott részei.</para>                        
                </listitem>
                <listitem>
                    <para>C++ kapcsán a <citation>BMECPP</citation> könyv adott részei.</para>                        
                </listitem>
                <listitem>
                    <para>Az igazi kockák persze csemegéznek a C nyelvi szabvány 
                        <link xlink:href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">ISO/IEC 9899:2017</link> kódcsipeteiből is.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Amiből viszont a legeslegjobban lehet tanulni, az a 
                        <link xlink:href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html">The GNU C Reference Manual</link>, mert gcc specifikus és programozókra
                        van hangolva: szinte csak 1-2 lényegi mondat és apró, lényegi kódcsipetek! Aki pdf-ben jobban
                        szereti olvasni: <link xlink:href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.pdf"/>
                    </para>                        
                </listitem>
                <listitem>
                    <para>Az R kódok olvasása kis általános tapasztalat után automatikusan, erőfeszítés nélkül menni fog. 
                        A Python nincs ennyire a spektrum magától értetődő végén, ezért ahhoz olvasd el a  
                        <citation>BMECPP</citation> könyv - 20 oldalas gyorstalpaló részét.
                    </para>                        
                </listitem>
            </itemizedlist>            
        </section>
        <section>
            <title>Milyen filmeket nézzek meg?</title>
            <itemizedlist>
                <listitem>
                    <para>21 - Las Vegas ostroma, 
                        <link xlink:href="https://www.imdb.com/title/tt0478087/">https://www.imdb.com/title/tt0478087/</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-turing.MontyHall">Monty Hall probléma</link> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Kódjátszma, 
                        <link xlink:href="https://www.imdb.com/title/tt2084970">https://www.imdb.com/title/tt2084970</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-caesar.EXOR-toro">kódtörő feladat</link> élménye.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
            </itemizedlist> 
        </section>
    </chapter>                
</part> 

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Tematikus feladatok</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
   <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó: <link xlink:href="">No link</link>
        </para>
        <para>
            Megoldás forrása:
            <itemizedlist>
              <listitem>
                <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/thefor.c">Basic infinite for loop</link></para>                     
              </listitem>
              <listitem>
                <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-f_torvalds.c">For with linux sleep</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-w.c">While infinite</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-f.c">Macros for OS call handling</link></para>
              </listitem>
            </itemizedlist>
        </para>
        <para>
            Végtelen ciklusokra gyakorlatban sok példa akad: szerverek, game loop-ok, interaktív interpreter terminálhoz.
            A végtelen ciklus azonban olykor nem várt. Például lehet bug, de akár lehet a természetes működés része.
            Erre jó példa a Tanár Úr által említett PageRank algoritmus.
            Én azonban, a hozzáadott munka miatt másik példát hoznék: mérnöki CAE végeselemes számítások (pl. <application>Ansys</application>) esetén egyes esetekben a megoldás nem konvergál n lépés után sem, és ez előre nem látható be. Erre a célra a felhasználó megadhat vészhelyzeti kilépési konvergencia kritériumokat.
            Ez nem matematikai kényszert jelent, hanem szimplán, ha n iteráció, vagy t idő elteltével a megoldáshoz nem jutunk közelebb, akkor a program ki break-el  ciklusból.
        </para>  
        <para>
            Alább egy minimális végtelen ciklus látható for-ral. Amit vegyünk észre, az az hogy az egész "üres". Ezt a <link xlink:href="https://en.cppreference.com/w/cpp/language/for">for loop szintaktikai definíciója teszi lehetővé</link>, hisz nyíltan kifejezi az optional, hogy nem kötelező megadni.
            Ez persze egyéb hatásokkal is jár, például, hogy a <literal>for(;;)</literal>-ban használhatjuk az ehhez képest külső scope-ban deklarált változókat.
        </para>
        <figure>
            <title>For syntax</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/for.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>for syntax (ugye hogy optional!)</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/thefor.c"/></textobject>
        </programlisting>   
        <para>        
          Alább a fenti példa látható egy <literal>while</literal> loop-pal. Értelemszerűen a conditional-ban mivel egy <literal>true</literal> bool literal-t írtuk, így ez mindig igazra fog kiértékelődni.
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/infty-w.c"/></textobject>
        </programlisting>     
        <para>
            Alább egy <literal>while</literal>-t használtunk, de mostmár alszunk is.
            A <literal>sleep</literal> viszont sajnos OS dependens call (mi sem mondja el jobban mint az unistd include-olása).
            Mivel az OS feladata az ütemezés, plusz a megszakítások kezelése (hisz ugye az egész lelke az időzítés ezáltal a timer).
            <literal>sleep</literal> esetén jelezzük az OS-felé, hogy nem kérünk CPU időt (azaz váltsa a process status-t), viszont emellett viszont a megfelelő idő elmúltával (megszakításos alapon) újból kerüljünk számításra várakozóba.
            A probléma természetesen annyi, hogy scheduling-tól függően, lehet soha nem kerülünk vissza még az idő letelte után sem CPU-ra.
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/infty-f_torvalds.c"/></textobject>
        </programlisting> 
        <para>
          Mindenesetre az alvás egy OS specifikus dolog, pl.: <link xlink:href="http://man7.org/linux/man-pages/man2/nanosleep.2.html">nanosleep</link>.
          Ha több fajta OS-n kell futni, ahhoz sajnos trükközni kell. Egy barbár megoldás a preprocesszor használata.
          Alábbi példában az látható, hogy preprocesszor által értelmezett szöveget is elhelyeztem a fájlban.
          Technikailag ez annyit tesz, hogy compile előtt a preprocesszor elődolgozza a forrásfájlt, és ez példánkban azzal jár 
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/infty-f.c"/></textobject>
        </programlisting>      
        <para>
          Egyébként a <literal>gcc</literal> mellé betudunk passzolni flageket. Például <literal>-DALMA</literal>-val gyakorlatilag azt mondjuk a preprocesszornak, hogy vegye úgy mintha <literal>#define ALMA</literal>.
          Ez pontosan annyira szép mint amennyire elegáns, de ez van. Nézzük csak meg ezt az almát!
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/alma.cpp"/></textobject>
        </programlisting>
        <para>
          Láthatóan ez nem fog lefordulni ha nincs definiálva az ALMA, de azért tegyünk próbát!
        </para>
        <figure>
            <title>Alma no flag fail</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/almanoflag.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>A flag nem használva</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
          Miért azt írja hogy <literal>hello was not declared in scope</literal>?
          Nos a preprocesszor végigment a forrásfájlon, és, mivel nem volt ALMA definiálva, ezért a compilation stage-ben az a kód részlet ami <literal>#ifdef</literal>-be volt zárva nem létezett.
          Próbáljuk ki azt hogy <literal>g++ alma.cpp -o alma -DALMA</literal>!
          Az alábbi screenshot-ról látszik, hogy mivel lusta vagyok, ezért a git bash-ből csináltam.
        </para>
        <figure>
            <title>Alma With flag</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/almaflag.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>A flag-et használva</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>
            Ha belenézel az STL-be, akkor az is tele lesz ilyenekkel, hisz különböző OS-ekkel kell tudni használni, és a rendszerhívások átlalában eltérőek.
            Egyébként ha valami IDE-vel dolgozol, ott gyakran még szépen be is szürkíti azokat a részeket a kódban amelyeket ki fog hagyni.
            Itt semmi mágia nem történik, hanem simán nem a forráskódod megy a compiler-nek, hanem előtte van egy preprocesszor, ami feldolgozza ezeket az utasításokat.
            Makrók ugyanilyenek. Tehát nem runtime kiértékelhető az <literal>#ifdef</literal> hanem egy utasítás a preprocesszornak.
            Leggyakrabban <literal>#ifdef</literal>-el header guard-ként fogsz találkozni (vele kb. ekvivalens a nem mindenhol támogatott <literal>#pragma once</literal>).
        </para>
        <para>
            Na jó, de ez nem válaszolja meg a kérdést, hogy miért nem bírja a gépem OBS-el együtt a notepad++-t.
        </para>
        <para>
            Mármint, akarom mondani, milyen ügyes kis dolog ez a preprocesszor! De csak ennyit tud? A válasz nem. Alábbi példában filename, linenumber-t íratunk ki.
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/builtins.cpp"/></textobject>
        </programlisting>
        <figure>
            <title>builtins</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/builtins.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>Macro supplied fname és linenumber</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            Most pedig következzen egy összevagdosott code snippet egy régi projektemből. A lényeg annyi, hogy unit test-eléshez, egy makró alapú library-ről volt szó. (Csak poénból, tudom hogy van gtest).
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/example_macros.h"/></textobject>
        </programlisting>
        <para>
            A fenti snippetben látszik, hogy a <literal>#define</literal>-al meghatározott dolgok többek mint "változók". Ezeket preprocesszor makróknak hívjuk, és az előfeldolgozáskor expandáljuk őket.
            Azaz először az <literal>EXPECT_EQ</literal> expandálódik <literal>EXPECT(case,arg0,arg1,pred_eq,"Expect failed ==")</literal>. Az Expect-ben meg egy pici scope-ot létrehozunk.
          A lényeg ebből annyi, hogy nem kell megijedni tőle, jóra is lehet használni. Annyi hogy az expanzióval óvatosan, mert elég nehéz debuggolni. (ugyanolyan szívás mint az STL-es template alapú hibákat, azaz nem egy one liner lesz.)
        </para>
    </section>
   <section>
      <title>Lefagyott, nem fagyott, akkor most mi van?</title>
      <para>
        Lehet-e írni olyan programot amely minden programról megmondja, hogy lefut-e?
      </para>
     <para>
          Megoldás videó: <link xlink:href="">No link</link>
      </para>
      <para>
          Megoldás forrása:
          <itemizedlist>
              <listitem>
                <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/t100.c">Turing 100 (pseudocode)</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/t1000.c">Turing 1000 (pseudocode)</link></para>
              </listitem>
          </itemizedlist>
      </para>
      <para>
          A probléma elég fontos. Miért is? Nos, a probléma az, hogyha ez nem lehetséges, akkor soha nem fogjuk tudni bizonyítani az összes program helyességét.
         
          Tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
          függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne végtelen ciklus:              
      </para>
      
      <para>
      A borbély az aki azok haját vágja, akik nem teszik meg ezt saját maguknak.
        De a borbély vágja-e a saját haját?
        Nos, tegyük fel levágja:
        Ebben az esetben ő levágta a haját egy olyan embernek aki egyébként ezt megteszi saját magának.
        Ok, tegyük fel nem vágja:
        Viszont ebben az esetben nem vágja a saját haját, aka lehetne a saját ügyfele, viszont ha most levágja akkor kezdődik az egész elölről <link xlink:href="https://en.wikipedia.org/wiki/Russell%27s_paradox">Russel's paradox</link>.
      </para>
      <para>
        Ezzel a problémával sok helyen találkozhatunk. Például <citation>DENOTATIONALSEMANTICS</citation> 4.1.1. fejezet, vagy akár <citation>SICP</citation> Excercise 4.15.
      </para>
      <programlisting language="c" linenumbering="numbered">
        <textobject><textdata encoding="UTF-8" fileref="Turing/t100.c"/></textobject>
      </programlisting>   
      <para>
          A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
          <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
          akár önmagára
          <screen><![CDATA[T100(T100)
false]]></screen>  
          ezt a kimenetet adja.    
    </para>    
      <para>
          A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
          Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
      </para>
      <programlisting language="c" linenumbering="numbered">
        <textobject><textdata fileref="Turing/t1000.c"/></textobject>
      </programlisting>                     
       <para>
        Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                            
        <itemizedlist>
            <listitem>
                <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
            </listitem>
            <listitem>
                <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
            </listitem>
        </itemizedlist>
        akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
        függvényt, azaz a T100 program nem is létezik.                
      </para>
       <para>
        Persze ha már lefagyott, nem fagyott témánál vagyunk, akkor érdemes kicsit beszélni a kiértékelésről. Alább látható egy egyszerű kifejezés. Mi lesz vajon a vége?
        <equation>
          <mathphrase>(λx.y) ( (λz.z z) (λz.z z) )</mathphrase>
        </equation>
        Redukáljuk!
        <equation>
          <mathphrase>(λx.y) ( (λz.z z) (λz.z z) )</mathphrase>
        </equation>
        Hrumph, ugyanoda jutottunk, kezdjük elölről!
        <equation>
          <mathphrase>(λx.y)  ( (λz.z z) (λz.z z) )</mathphrase>
        </equation>
        Redukáljuk az x-t kötő baloldali lambdát a jobb oldallal a jobb oldal redukciója nélkül.
        <equation>
          <mathphrase>y</mathphrase>
        </equation>
        Azaz addig késleltettük a kiértékelést, amíg lehetett, és a végén kiderült, hogy abszolút nem is volt szükséges!
        Ez a módszer zseniális! Innentől mindent késleltetni fogunk!
      </para>
      <para>
        Nézzünk egy példát a <citation>SICP</citation>-ből! Alábbi definíciók alapján ki fogjuk értékelni a <function>(f 5)</function>-t!
      </para>
<literallayout>
(define (square x) (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
</literallayout>
      <para>
        Annyira jó ez a késleltetés, hogy alkalmazzuk a <function>(f 5)</function> kiértékelésénél!
      </para>
<literallayout>
(f 5)
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)) )
(+ (* (+ 5 1) (+ 5 1)) (square (* 5 2)))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
(+ (* 6 (+ 5 1)) (* (* 5 2) (* 5 2)))
(+ (* 6 6) (* (* 5 2) (* 5 2)))
(+ (* 6 6) (* 10 (* 5 2)))
(+ (* 6 6) (* 10 10))
(+ 36 (* 10 10))
(+ 36 100)
136
</literallayout>
      <para>
        Mint ahogy azt látjuk <function>(+ 5 1)</function> és <function>(* 5 2)</function> kétszer kerül redukcióra. Hát így már nem is olyan jó...
      </para>
      <para>
        Hogy fut le vajon egy másik út?
      </para>
<literallayout>
(f 5)
(sum-of-squares (+ 5 1) (* 5 2))
(sum-of-squares 6 (* 5 2))
(sum-of-squares 6 10)
(+ (square 6) (square 10))
(+ (* 6 6) (* 10 10))
(+ 36 (* 10 10))
(+ 36 100)
136
</literallayout>
      <para>
        Kevesebb számítást végzünk mint a késleltetős előző esetben. Azaz látjuk, hogy a redukciós stratégiának a teljesítményre is van hatása.
      </para>
  </section>
  <section>
    <title>Változók értékének felcserélése</title>
    <para>
      Írjunk egy olyan programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés használata nélkül, és ez ne bug hanem feature legyen!
    </para>
    <para>
      Megoldás videó: <link xlink:href="">No Link</link>
    </para>
    <para>
      Megoldás forrása:
      <itemizedlist>
      <listitem>
        <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/swap_xor.cpp">Swap XOR</link></para>
      </listitem>
      <listitem>
        <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/swap_subtract.cpp">Swap Subtract</link></para>
      </listitem>
      <listitem>
        <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/swap_mult.cpp">Swap Multiplication</link></para>
      </listitem>
      <listitem>
        <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/swap_ptr.cpp">Swap Ptr</link></para>                   
      </listitem>
    </itemizedlist>
    </para>
    <para>
        Több megoldási lehetőség is van, ezeket fogjuk a következő bekezdésekben bemutatni.
    </para>
    <para>
        Nézzünk valami szorzásos osztásosat!
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/swap_mult.cpp"/></textobject>
    </programlisting>
    <para>
      Kövessük nyomon mi történik!
<literallayout>
(a,6) (b,7)
a = a * b =&gt; (a,42) (b,7)
b = a \ b =&gt; (a,42) (b,7)
a = a \ b =&gt; (a,6) (b,7)
</literallayout>
      Hát ez működik, de 0-val nem osztunk, plusz a szorzás osztás nehéz. Nézzünk mást!
    </para>
    <para>
        Nézzünk valami összeadás kivonásosat!
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/swap_subtract.cpp"/></textobject>
    </programlisting>
    <para>
      Kövessük nyomon mi történik!
<literallayout>
(a,6) (b,7)
a = a + b =&gt; (a,13) (b,7)
b = a - b =&gt; (a,13) (b,6)
a = a - b =&gt; (a,7) (b,6)
</literallayout>
      Ez is jó, és ráadásul csak összeadással és kivonással terheljük a CPU-t!
    </para>
    <para>
      De esetleg van valami más is? Nos nézzük a xor műveletet!
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/swap_xor.cpp"/></textobject>
    </programlisting>  
    <para>
    Kövessük végig!
<literallayout>
(a,110) (b,111)
a = a XOR b =&gt; (a,001) (b,111)
b = a XOR b =&gt; (a,001) (b,110)
a = a XOR b =&gt; (a,111) (b,110)
</literallayout>
        Egy nagyon furcsa dolgot láthatunk. Az összes előző esetnél több operátort kellett használni (*) és (/) illetve (+) és (-).
      Most azonban egy olyan esetet látunk, amikor egyetlen operátorral megtudtuk oldani (kommutatív, asszociatív, identitás elem létezik, f(a,a)=Identitás elem).
    </para>
    <para>
        Alábbi utolsó példa csak egy picit behozza a pointer-eket a képbe.
        Ezekkel ha még nem értjük mi van, ne aggódjunk.
        Minden pointert érdemes egy címként felfogni.
        Azaz ha létezik egy int változónk foo néven akkor foo-nak van ugye egy értéke, illetve egy címe.
        A cím az amit a ptr megtestesít (na jó nem, de most így elég...).
        Természetesen funckiókra is mutathatunk.
        Sőt, ha már valaha láttunk C kódot, akkor valószínűleg belefutottunk már callback-ekbe stb.
        Aka akár funkciókat és bepasszolhatunk funkciókba, stb.
    </para>
   <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/swap_ptr.cpp"/></textobject>
    </programlisting>
  </section>                     
  <section>
    <title>Labdapattogás</title>
    <para>
        Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
        használata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! Nem írhatsz hozzá DLC-t, és ne legyen benne lootbox, mert nem ez EA vagyunk.
    </para>
    <para>
        Megoldás videó: <link xlink:href=""/>
    </para>
    <para>
        Megoldás forrása:
        <itemizedlist>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/pubghypetrain.h">Helper header</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/ball.cpp">Ball</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/ballnoif.cpp">Ball no if</link></para>
          </listitem>
        </itemizedlist>
    </para>
    <para>
        Ennek a feladatnak az volt a lényege, hogy elágazás nélkül kicsikarjunk a gépből valami féle döntés alapú útválasztást.
        Először nézzük az alapot.
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/ball.cpp"/></textobject>
    </programlisting>
    <para>
      Nyilvánvalóan valahogyan trükközni kell, hisz az <literal>if</literal>-et ha kihagynánk, akkor nem tudnánk például dönteni, hogy mely karaktert küldjük std out-ra. Nézzük egy lehetséges megoldást.
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/ballnoif.cpp"/></textobject>
    </programlisting>
    <para>
      Simán csak implicit konverzió történik, mind <literal>collide</literal>, mind <literal>draw</literal> esetén.
    </para>
    
    <para>
      Ha már itt tartunk, akkor nézzünk más jellegű if encode-olást is! (használhatjuk például a <citation>CHISOMORPH</citation>-t) 
<literallayout>
true = λx.λy.x
false = λx.λy.y
if(B,P,Q)= B P Q
</literallayout>
    </para>
   <para> Az if true then P else Q redukciója
<literallayout>
if true then P else Q
= true P Q
= λx.λy.x P Q
= λy.P Q
= P
</literallayout>
  Az if false then P else Q redukciója
<literallayout>
if false then P else Q
= false P Q
= λx.λy.y P Q
= λy.y Q
= Q
</literallayout>
</para>
<para>
Vezessünk be számokat!
<literallayout>
if false then P else Q
0 = λf.λx.x
1 = λf.λx.f x
2 = λf.λx.f (f x)
...
</literallayout>
Illetve egy isZero predikátumot!
<literallayout>
IsZero = λn.n (λx.false) true
</literallayout>
Nézzük meg pár esetre a predikátumunk működését!
<literallayout>
IsZero 0
= (λn.n (λx.false) true) (λf.λx.x)
= ( (λf.λx.x) (λx.false) true)
= ( λx.x true)
= true
</literallayout>
<literallayout>
IsZero 1
= (λn.n (λx.false) true) (λf.λx.f x)
= ( (λf.λx.f x) (λx.false) true) 
= ( (λx.(λx.false) x)  true) 
= (λx.false) true
= false
</literallayout>
</para>
    <para>
     Mostmár mondhatunk olyat, hogy osztásnál ne legyen nulla a nevezőben, azaz if IsZero b then 0 else (div a b).
     A lényeg az, hogy dobjon vissza egy (div valami valami)-t ha el lehet végezni, különben pedig egy 0-t. Például 4-el és 0-val hívjuk. 
<literallayout>
( (λx.λy.(IsZero y) 0 (div x y)) 4 0
= ( (λy.(IsZero y) 0 (div 4 y)) 0 
= ((IsZero 0) 0 (div 4 0))
= (true 0 (div 4 0))
= ((λx.λy.x) 0 (div 4 0))
= ((λy.0) (div 4 0))
= 0
</literallayout>
Most nézzük meg 4 és 2-vel.
<literallayout>
( (λx.λy.(IsZero y)) 0 (div x y)) 4 2
( (λy.IsZero y) 0 (div 4 y)) 2
((IsZero 2) 0 (div 4 2))
(false 2 (div 4 2))
((λx.λy.y) 0 (div 4 2))
((λy.y) (div 4 2))
(div 4 2)
</literallayout>
    </para>
  </section>                     
  <section>
    <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
    <para>
        Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
        Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
    </para>
    <para>
        Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link>, 
        <link xlink:href="https://youtu.be/KRZlt1ZJ3qk">https://youtu.be/KRZlt1ZJ3qk</link>, 
        <link xlink:href=""/>.
    </para>
    <para>
        Megoldás forrása:
        <itemizedlist>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/wordsize.cpp">Wordsize</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/bogomips.c">Bogomips</link></para>
          </listitem>
        </itemizedlist>
    </para>
   <para>
      Először is nézzük a biteket! A számokat kettes számrendszerben tároljuk. A shift az értékek "tologatása". De pontosan mi az a shift? 
    </para> 
    <para>
      Amikor left shiftelünk, akkor mi is történik? Nézzük unsigned char-ra!
      <quote>For unsigned lhs, the value of LHS &lt;&lt; RHS is the value of LHS * 2^RHS, reduced modulo maximum value of the return type plus 1 (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded). </quote>
      Alább látható hogy miről van szó.
    </para>
<literallayout>
1   &lt;&lt; 1 =&gt;    (1*2^1)%(255+1) = 2   (00000010)
2   &lt;&lt; 1 =&gt;    (2*2^1)%(255+1) = 4   (00000100)
4   &lt;&lt; 1 =&gt;    (4*2^1)%(255+1) = 8   (00001000)
8   &lt;&lt; 1 =&gt;    (8*2^1)%(255+1) = 16  (00010000)
16  &lt;&lt; 1 =&gt;   (16*2^1)%(255+1) = 32  (00100000)
32  &lt;&lt; 1 =&gt;   (32*2^1)%(255+1) = 64  (01000000)
64  &lt;&lt; 1 =&gt;   (64*2^1)%(255+1) = 128 (10000000)
128 &lt;&lt; 1 =&gt;  (128*2^1)%(255+1) = 0   (00000000)
</literallayout>
  <para>
      Alábbi kóddal nézzük meg:
    </para>
  <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/shiftl_uchar.cpp"/></textobject>
    </programlisting>
  <figure>
            <title>shiftl_uchar</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/shiftl_uchar.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>shiftl_uchar std kimeneten</phrase>
                </textobject>
            </mediaobject>
        </figure> 
    <para>
      Mi történik a right shift esetben?
      <quote>For unsigned lhs and for signed lhs with nonnegative values, the value of LHS &gt;&gt; RHS is the integer part of LHS / 2^RHS.</quote>
    </para>  
<literallayout>
255 &gt;&gt; 1 =&gt; intp(255 div 2^1) = 127 (01111111)
127 &gt;&gt; 1 =&gt; intp(127 div 2^1) = 63  (00111111)
63  &gt;&gt; 1 =&gt; intp(63 div 2^1)  = 31  (00011111)
31  &gt;&gt; 1 =&gt; intp(31 div 2^1)  = 15  (00001111)
15  &gt;&gt; 1 =&gt; intp(15 div 2^1)  = 7   (00000111)
7   &gt;&gt; 1 =&gt; intp(7 div 2^1)   = 3   (00000011)
3   &gt;&gt; 1 =&gt; intp(3 div 2^1)   = 1   (00000001)
1   &gt;&gt; 1 =&gt; intp(1 div 2^1)   = 0   (00000000)
</literallayout>
<para>
      Alábbi kóddal nézzük meg:
    </para>
  <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/shiftr_uchar.cpp"/></textobject>
    </programlisting>
  <figure>
            <title>shiftr_uchar</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/shiftr_uchar.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>shiftr_uchar std kimeneten</phrase>
                </textobject>
            </mediaobject>
        </figure>
  <para>
      Alábbi kód az előzőeket hajtja végre csak int-et használunk.
    </para>
  <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/wordsize.cpp"/></textobject>
  </programlisting>
<para>
      Előjeles esetben figyelembe kell venni, hogy például a felső bit előjelet is jelenthet akár. Alábbi ábra szép illusztrációt ad arra, mire is kell gondolni (2s complement).
    </para>
  <figure>
    <title>2s complement</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/twoscomplement.png" scale="100"/>
        </imageobject>
        <textobject>
            <phrase>2s complement</phrase>
        </textobject>
    </mediaobject>
</figure>
    <para>
      Most áttérünk a bogomips-re. Itt egy új dologgal talákozunk &lt;&lt;= de ez igazából csak annyit tesz, hogy a shift rhs-t egyből az lhs oldalon lévő változóba vissza is tároljuk.
      A delay egy for loop ami elszámol <literal>loops</literal>-ig, azaz addig növeli (++) unáris operátorral i értékét amíg a <literal>i &lt; loops</literal> conditional igaz.
      A while ciklus fejben pedig már a jól ismert left shift zajlik (loops_per_sec 1-ről indul).
      De hogy biztosak legyünk nézzük az alábbi programot (bár nagyon ismerős lesz...)
    </para>
<programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/bogomips_shifting.cpp"/></textobject>
  </programlisting>
   <figure>
    <title>ullshift</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/ullshift.png" scale="100"/>
        </imageobject>
        <textobject>
            <phrase>bogomips_shifting kimeneten</phrase>
        </textobject>
    </mediaobject>
</figure>
<para>
A bogomips while body egyébként annyiról szól, hogy lekérjük hány tick telt el idáig, majd nyomunk n mennyiség lépést a for ciklusban, visszajövünk és megint lekérdezzük az eltelt tick-ek számát. Ha a tickek száma nem kevesebb mint amennyit a CLOCKS_PER_SEC konstanssal állít magáról a gép, akkor elkezdjük a kiszállást.
A loops_per_sec pedig a következő módon jön ki:
</para>
<literallayout>
loop_per_masodperc = ( loopok_szama / tick_szam ) * CLOCKS_PER_SEC;
[1/s] = ( [1] / [1] ) * [1/s]
</literallayout>
    <para>
    Ezután következik zsonglőrködés a számokkal. Ez a rész a <literal>bogus</literal> a bogomips-ben.
    Ha sok időnk van akkor meg is mérhetjük a saját gépünkét. Alább egy random példa.
    </para>
   <figure>
    <title>bogomips kimeneten</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/bogoihatemondays.png" scale="100"/>
        </imageobject>
        <textobject>
            <phrase>bogomips kimeneten</phrase>
        </textobject>
    </mediaobject>
</figure>
  </section> 
<section>
    <title>Helló, Google!</title>
    <para>
        Írj olyan C programot, amely egy több milliárd(haha ne ne...elég lesz kevesebb srsly) honlapból álló hálózatra kiszámolja az N lap Page-Rank 
        értékét, és <link xlink:href="https://youtu.be/WfbTbPEEJxI?t=9971">nem lesz belőle baj egy szenátusi kihallgatáson</link>!
    </para>
    <para>
        Megoldás videó: <link xlink:href=""/>
    </para>
    <para>
        Megoldás forrása:
        <itemizedlist>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/pagerank_example.cpp">Pagerank Példa</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/pagerank_c.cpp">Pagerank C</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/pagerank_iter.cpp">STL Iterator</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/pagerank_vec.cpp">Purely STL Vector</link></para>
          </listitem>
        </itemizedlist>
    </para>
<para>
      Pagerank a Google által használt adóelk...keresési algoritmus magja. A feladat arról szólt, hogy egy négy honlapból álló kapcsolati hálón kellene vele elemezni. A pageranktől azt várjuk, hogy az összes honlapnak mondjuk adjon egy 0-1-ig terjedő értéket (normalizált, azaz az összes lap rankjének összege 1 for sanity check).
       Van több implementáció is, de mi egy konkrétan kitenyésztett példa progival fogunk dolgozni. Ez a pagerank vektor értékeit fő iterációs lépésenként kiírja egy fájlba.
      A pagerankkel a példában egy irányított multigráfon fogunk számolni. (irányított mert számít hogy honnan-hova megy az él, multigráf pedig a több él egy pontból plusz hurkok is lehetnek)
    </para>
    <figure>
    <title>pagerank kapcsolati irányított multigráf</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/pagerank_graph.png" scale="100"/>
        </imageobject>
        <textobject>
            <phrase>pagerank kapcsolati irányított multigráf</phrase>
        </textobject>
    </mediaobject>
    </figure>
    <para>
      Ez ugyan emberként érthető, de próbáljuk valahogy szervezettebb formába hozni. Csináljunk egy kvadratikus mátrixot, és töltsük ki a következő szabály szerint: <literal>Először mindenhova írjunk be nullát</literal> majd <literal>Ha A-ból B-be megy él, akkor A oszlop B sorába írjunk 1-et</literal>
      Először nézzük csak meg J-re(J-ből egy él megy ki JP felé...)
    </para>
<literallayout>
    J  JP JPL   M
J   0   0   0   0
JP  1   0   0   0
JPL 0   0   0   0
M   0   0   0   0
</literallayout>
    <para>
      Most pedig csináljuk meg JP-re(magába és JPLbe)
    </para>
<literallayout>
    J  JP JPL   M
J   0   0   0   0
JP  1   1   0   0
JPL 0   1   0   0
M   0   0   0   0
</literallayout>
    <para>
      Jöhet JPL (mindenkibe csak magába nem)
    </para>
<literallayout>
    J  JP JPL   M
J   0   0   1   0
JP  1   1   0   0
JPL 0   1   1   0
M   0   0   1   0
</literallayout>
    <para>
      Jöhet M (csak JP-be)
    </para>
<literallayout>
    J  JP JPL   M
J   0   0   1   0
JP  1   1   0   1
JPL 0   1   1   0
M   0   0   1   0
</literallayout>
    <para>
      Most normalizáljuk, azaz adjuk össze az egy oszlopban lévő számokat, nevezzük ezt <literal>szum</literal>mának.
       Ha meg van, akkor utána ugyanezen az oszlopon menjünk végig és mindenkit osszunk el <literal>szum</literal>-mal, ha szum nem nulla.
    </para>
<literallayout>
    J  JP JPL   M
J   0   0 1/3   0
JP  1 1/2 1/3   1
JPL 0 1/2   0   0
M   0   0 1/3   0
</literallayout>
 <para>
      Vessük össze az előadás diával.
    </para>
<figure>
    <title>pagerank link mátrix sanity check</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/pagerank_lmx.png" scale="100"/>
        </imageobject>
        <textobject>
            <phrase>pagerank link mátrix sanity check</phrase>
        </textobject>
    </mediaobject>
</figure>
    <para>
      Most hogy végre van link mátrixunk elkezdhetünk számolni. De mi is a lényeg, mit fogunk számolni?
      Gondoljunk vissza a <link xlink:href="https://www.youtube.com/watch?v=PFDu9oVAE-g">sajátérték sajátvektorra</link>, és <link xlink:href="https://www.desmos.com/calculator/upooihuy4s">próbálgassuk</link> is ha tetszik!
      Magyarul amikor Tanár Úr azt mondja <literal>Tehát ha h jelöli a PR vektort, akkor h=Lh. Linalg kedvelőknek: a PageRank vektor az L linkmátrix 1 sajátértékhez tartozó sajátvektora.</literal>
      akkor gondoljunk a következőre
    </para>
<literallayout>
                      | PR[1] |
                      | PR[2] |
                      | PR[3] |
                      | PR[4] |
                     
   | 0   0 1/3   0 |  |   ?   |   = | PR[1] |
   | 1 1/2 1/3   1 |  |   ?   |     | PR[2] |
   | 0 1/2   0   0 |  |   ?   |     | PR[3] |
   | 0   0 1/3   0 |  |   ?   |     | PR[4] |
</literallayout>
  <para>
      De milyen vektorról is beszélünk? Mi a végcél ezzel az egész saját vektor dologgal? Vizualizájuk!
    </para>
    <para>
      Jelen példában 4 node van szóval PR 4 elemű, ezt nehéz lenne ábrázolnom.
      Viszont gondoljunk egy két node-ból álló esetre! Ezen esetben PR vektor 2 elemű lesz, szóval már plottolhatjuk 2dbe.
      Alábbi ábrán simán fogtuk magunkat és a PR vektor 1. számát x-nek 2. számát y-nak vettük csináltunk bele egy nyilat az origóból.
      Színkódoltuk is: A legelső iter utáni PR vektor halvány szürke, az utolsó pedig fekete, közte pedig graduálisan változtattuk a feketeséget (hsv mert lusta voltam, de ne menjünk bele).
    </para>
<literallayout>
x = [0	1	0.5	0.75	0.625	0.6875	0.65625 ]
y = [1	0	0.5	0.25	0.375	0.3125	0.34375	]
</literallayout>
  <figure>
    <title>pagerank vektor</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/prvectorpagerank.png" scale="100"/>
        </imageobject>
        <textobject>
            <phrase>pagerank vektor</phrase>
        </textobject>
    </mediaobject>
  </figure>
  <para>
      Fenti ábrán látható, hogy ahogy beindul az iteráció vadul [0,1]-ből [1,0]-ba vált, majd [0.5,0.5] és szépen lassan kezd beállni [0.66 0.33]-ba!
    </para>
    <para>
      Magyarul a nem pontos PR vektor közelítésünk egyre kisebb cikázással kezd beállni abba az irányba ami egyébként az "igazi" sajátvektor irány. Ez alapján világos, hogy az egész számításnak az a célja hogy megtaláljuk azt a vektort, amire ha alkalmazzuk a Link mátrixot transzformációként, akkor iránya már nem fog változni.
      (Ha valakit érdekel akkor a 2d-s eset az oppenoffice <link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/pagerank.ods">fájl</link>-ban a <literal>twod</literal> munkalapon van, de semmi különös.)
    </para>
    <para>
      Ha valaki mégsem értené, nézzünk egy konkrét példát: Hogyan lett pl [0.5,0.5] irányú vektorból [0.75,0.25]?
      Alábbi ábrán felveszünk egy [0.75,0.25] vektort(zöld folytonos vonal), és ezt változatlanul fogjuk hagyni. Ezután veszünk egy [1,1] vektort(kék folytonos vonal). Azért [1,1] mert csak az irány a fontos, és azt akartam hogy nyúljon túl a zöldön trafó után. Ezekután transzformáljuk a linkmátrix-szal a kéket. Azt várjuk hogy a transzformáció után a zöld folytonos és kék folytonos egyirányú legyen.
    </para>
     <figure>
            <title>pagerank trf</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/pagerank_trf.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>pagerank trf</phrase>
                </textobject>
            </mediaobject>
        </figure> 
    <para>
      Vissza matekra! Mátrixok vektorok stb. szorzást már tanultunk szóval, oldjuk is meg!
    </para>
<literallayout>
                   | PR[1] |
                   | PR[2] |
                   | PR[3] |
                   | PR[4] |
                     
| 0   0 1/3   0 |  | PR[3]/3                     | = | PR[1] |
| 1 1/2 1/3   1 |  | PR[1]+PR[2]/2+PR[3]/3+PR[4] |   | PR[2] |
| 0 1/2   0   0 |  | PR[2]/2                     |   | PR[3] |
| 0   0 1/3   0 |  | PR[3]/3                     |   | PR[4] |
</literallayout>
  
    <para>
      Szét is robbanthatjuk akár egyenletekre...
    </para>
<literallayout>
PR[3]/3             = PR[1]
PR[1]+PR[2]/2+PR[4] = PR[2]
PR[2]/2+PR[3]/3     = PR[3]
PR[3]/3             = PR[4]
</literallayout>
    <para>
      Most pedig jön a kérdés, hogy hogyan oldjuk meg? PR[2] önmagából számolja önmagát!
    </para>
    <para>
      A válasz nem túlzottan bonyolult...tároljuk el az előző lépés értékeit minden ciklusban és használjuk azokat. (Ez lesz a megoldásban PRv)
    </para>
<literallayout>
PRv[3]/3             = PR[1]
PRv[1]+PR[2]/2+PR[4] = PR[2]
PRv[2]/2+PR[3]/3     = PR[3]
PRv[3]/3             = PR[4]
</literallayout>
  <para>
    Egy kérdés még maradt: Mennyi legyen PRv iniciális értéke?
    A válasz annyi, hogy mindegyik érték 1 aztán benormáljuk, hogy összegük 1 legyen (Mat viz).
  </para>
  <para>
    Ha midezt megértettük, akkor már könnyű lesz megérteni az alábbi kódomat! A refekkel, constokkal, initializer listekkel meg a többi szeméttel ne törődjünk még nem kell őket érteni, csak a pagerank-re fókuszáljunk.
    Ha esetleg nem lenne érthető a kód, akkor beraktam a repóba egy openoffice calc (olyan mint az excel csak kevesebb benne a fluff) doksit, ami ugyanezt a pagerank számítást csinálja...
    A fejezet végén beillesztettem a C++ kódot, viszont most következzen két diagram. Az első a C++ algoritmus PR vektorának értékeit mutatja iterációnként, a másik pedig az <link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/pagerank.ods">open office</link>-ost, ha valaki valami miatt szereti az irodai munkát.
  </para>
  <figure>
    <title>pagerank cpp konvergál</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/pagerank_results_cpp.png" scale="100"/>
        </imageobject>
        <textobject>
            <phrase>pagerank cpp konvergál</phrase>
        </textobject>
    </mediaobject>
  </figure>
<figure>
    <title>pagerank openoffice konvergál</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="img/pagerank_results_openoffice.png" scale="100"/>
        </imageobject>
        <textobject>
            <phrase>pagerank openoffice konvergál</phrase>
        </textobject>
    </mediaobject>
</figure>

    <para>
    Kicsit azért vigyázzunk...ugyanis van két kis probléma.
    Tanár Úr azért mondta hogy rázzuk a vizet az internetben, mert arra gondolt, hogy ez az iteratív megoldás olyan mintha vödrök között öntögetnénk vizet, vagy mondjuk egy fémlemez hőmérsékletét akarnánk úgy kiszámolni, hogy az egyik szélén tudjuk a hőmérsékletet a többit pedig úgy számoljuk, hogy a négy (felső-alsó-bal-jobb egy kockás lapon mondjuk) szomszédját átlagoljuk.
    Nos első esetben az a probléma, hogy az egyik vödörbe folyik víz be, vissza is folyik magába, de kifele nem.
    A példa fájlban egy <literal>get_dangling</literal> funkció csinál olyan mátrix-ot amiben van egy nyelő jellegű node.
    </para>
<literallayout>
    { 1,0,1,0,1,0},
    { 1,1,0,1,0,0},
    { 0,1,1,0,1,0},
    { 1,0,1,1,0,0},
    { 0,1,0,1,1,0},
    { 1,0,1,0,1,0}
</literallayout>
    <para>
    Most pedig következzen az igazi vizes locspocs.
    Vegyük a következő kapcsolati gráfot:
    </para>
<literallayout>
    A   A
A   0   0
B   1   1
</literallayout>
<para>
 A locspocs-t indítsuk a következő PRv-vel:
</para>
<literallayout>
PRv  0 
PRv  1
</literallayout>
<para>
    Érezhető hogy ennek mi lesz a vége, ha valaki elképesztően kíváncsi az open office <link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/pagerank.ods">fájlban</link>-ban látható egy <literal>Infinite</literal> nevű munkalap.
</para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/pagerank_example.cpp"/></textobject>
    </programlisting> 
  </section>
  <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
    <title>A Monty Hall probléma</title>
    <para>
        Írj szimulációt a Monty Hall problémára!
    </para>
    <para>
        Megoldás videó: <link xlink:href="">No link</link>
    </para>
    <para>
        Megoldás forrása: <link xlink:href="">No link</link>
    </para>
    <para>
        Gondolkodjunk úgy hogy két stratégia van: "nem választunk újra" és "újra választunk".
        Alábbi kódban "nem választunk újra" esetben N lehetőség közül 1/N valószínűségünk van nyerni.
        Viszont ha tudjuk hogy "nem választunk újra" veszített, és a fazon már kinyitott egy ajtót, akkor N-2-ből kell csak választanunk.
        Utolsó sorban kiírja az nbatfai és ezen kód is sanity check jelleggel a két startégia nyertes kimeneteleinek összegét, ami N=3 esetben egyenlő N-nel.
        Magasabb N-nél ez nem így van, hisz ha "nem választunk újra" veszített és a fazon kinyitottegy ajtót és N&gt;3 akkor nekünk kisebb mint 100% esélyünk van "újra választunk"-kal nyerni.
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/monty_hall.cpp"/></textobject>
    </programlisting> 
  </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>

        <para>
            A természetes számok építőelemei a prímszámok. Abban az értelemben, 
            hogy minden természetes szám előállítható prímszámok szorzataként.
            Például 12=2*2*3, vagy például 33=3*11.
        </para>
        <para>
            Prímszám az a természetes szám, amely csak önmagával és eggyel 
            osztható. Eukleidész görög matematikus már Krisztus előtt tudta, 
            hogy végtelen sok prímszám van, de ma sem tudja senki, hogy 
            végtelen sok ikerprím van-e. Két prím ikerprím, ha különbségük 2.
        </para>
        <para>
            Két egymást követő páratlan prím között a legkisebb távolság a 2, 
            a legnagyobb távolság viszont bármilyen nagy lehet! Ez utóbbit 
            könnyű bebizonyítani. Legyen n egy tetszőlegesen nagy szám. 
            Akkor szorozzuk össze n+1-ig a számokat, azaz számoljuk ki az 
            1*2*3*… *(n-1)*n*(n+1) szorzatot, aminek a neve (n+1) faktoriális, 
            jele (n+1)!.
        </para>
        <para>
            Majd vizsgáljuk meg az a sorozatot:
        </para>    
        <para>
            (n+1)!+2, (n+1)!+3,… , (n+1)!+n, (n+1)!+ (n+1) ez n db egymást követő azám, ezekre (a jól ismert
            bizonyítás szerint) rendre igaz, hogy            
        </para>    
        <itemizedlist>
            <listitem>
                <para>(n+1)!+2=1*2*3*… *(n-1)*n*(n+1)+2, azaz 2*valamennyi+2, 2 többszöröse, így ami osztható kettővel</para>
            </listitem>
            <listitem>
                <para>(n+1)!+3=1*2*3*… *(n-1)*n*(n+1)+3, azaz 3*valamennyi+3, ami osztható hárommal</para>
            </listitem>
            <listitem>
                <para>...</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n-1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n-1)*valamennyi+(n-1), ami osztható (n-1)-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+n=1*2*3*… *(n-1)*n*(n+1)+n, azaz n*valamennyi+n-, ami osztható n-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n+1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n+1)*valamennyi+(n+1), ami osztható (n+1)-el</para>
            </listitem>
        </itemizedlist>
        <para>
            tehát ebben a sorozatban egy prim nincs, akkor a (n+1)!+2-nél 
            kisebb első prim és a (n+1)!+ (n+1)-nél nagyobb első 
            prim között a távolság legalább n.            
        </para>    
        <para>
            Az ikerprímszám sejtés azzal foglalkozik, amikor a prímek közötti 
            távolság 2. Azt mondja, hogy az egymástól 2 távolságra lévő prímek
            végtelen sokan vannak.
        </para>    
        <para>
            A Brun tétel azt mondja, hogy az ikerprímszámok reciprokaiból képzett sor összege, azaz
            a (1/3+1/5)+ (1/5+1/7)+ (1/11+1/13)+... véges vagy végtelen sor konvergens, ami azt jelenti, hogy ezek
            a törtek összeadva egy határt adnak ki pontosan vagy azt át nem lépve növekednek, 
            ami határ számot B<subscript>2</subscript> Brun konstansnak neveznek. Tehát ez
            nem dönti el a több ezer éve nyitott kérdést, hogy az ikerprímszámok halmaza végtelen-e? 
            Hiszen ha véges sok van és ezek
            reciprokait összeadjuk, akkor ugyanúgy nem lépjük át a B<subscript>2</subscript> Brun konstans értékét, 
            mintha végtelen 
            sok lenne, de ezek már csak olyan csökkenő mértékben járulnának hozzá a végtelen sor összegéhez, 
            hogy így sem lépnék át a Brun konstans értékét.     
        </para>
        <para>
            Ebben a példában egy olyan programot készítettünk, amely közelíteni próbálja a Brun konstans értékét.
            A repó <link xlink:href="../../../bhax/attention_raising/Primek_R/stp.r">
                <filename>bhax/attention_raising/Primek_R/stp.r</filename>
            </link> mevű állománya kiszámolja az ikerprímeket, összegzi
            a reciprokaikat és vizualizálja a kapott részeredményt.
        </para>
        <programlisting language="R">
<![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>

library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]>
        </programlisting>        
        <para>
            Soronként értelemezzük ezt a programot:
        </para>                
        <programlisting language="R">
<![CDATA[ primes = primes(13)]]>
        </programlisting>        
        <para>
            Kiszámolja a megadott számig a prímeket.             
        </para>
        <screen>
<![CDATA[> primes=primes(13)
> primes
[1]  2  3  5  7 11 13
]]>
        </screen>
                
        <programlisting language="R">
<![CDATA[ diff = primes[2:length(primes)]-primes[1:length(primes)-1]]]>
        </programlisting>        
        <screen>
<![CDATA[> diff = primes[2:length(primes)]-primes[1:length(primes)-1]
> diff
[1] 1 2 2 4 2
]]>
        </screen>        
        <para>
            Az egymást követő prímek különbségét képzi, tehát 3-2, 5-3, 7-5, 11-7, 13-11.
        </para>
        <programlisting language="R">
<![CDATA[idx = which(diff==2)]]>
        </programlisting>        
        <screen>
<![CDATA[> idx = which(diff==2)
> idx
[1] 2 3 5
]]>
        </screen>              
        <para>
            Megnézi a <varname>diff</varname>-ben, hogy melyiknél lett kettő az eredmény, mert azok az ikerprím párok, ahol ez igaz.
            Ez a <varname>diff</varname>-ben lévő 3-2, 5-3, 7-5, 11-7, 13-11 külünbségek közül ez a 2., 3. és 5. indexűre teljesül.
        </para>
        <programlisting language="R">
<![CDATA[t1primes = primes[idx]]]>
        </programlisting>  
        <para>
            Kivette a primes-ból a párok első tagját. 
        </para>
        <programlisting language="R">
<![CDATA[t2primes = primes[idx]+2]]>
        </programlisting>        
        <para>
            A párok második tagját az első tagok kettő hozzáadásával képezzük.
        </para>
        <programlisting language="R">
<![CDATA[rt1plust2 = 1/t1primes+1/t2primes]]>
        </programlisting>        
        <para>
            Az 1/t1primes a t1primes 3,5,11 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t1primes
[1] 0.33333333 0.20000000 0.09090909
]]>
        </screen>                      
        <para>
            Az 1/t2primes a t2primes 5,7,13 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t2primes
[1] 0.20000000 0.14285714 0.07692308
]]>
        </screen>                      
        <para>
            Az 1/t1primes + 1/t2primes pedig ezeket a törteket rendre összeadja.
        </para>
        <screen>
<![CDATA[> 1/t1primes+1/t2primes
[1] 0.5333333 0.3428571 0.1678322
]]>
        </screen>                      
        <para>
            Nincs más dolgunk, mint ezeket a törteket összeadni a 
            <function>sum</function> függvénnyel.
        </para>
        
        <programlisting language="R">
<![CDATA[sum(rt1plust2)]]>
        </programlisting>    
        <screen>
<![CDATA[>   sum(rt1plust2)
[1] 1.044023
]]>
        </screen>            
        <para>
            A következő ábra azt mutatja, hogy a szumma értéke, hogyan nő, egy határértékhez tart, a 
            B<subscript>2</subscript> Brun konstanshoz. Ezt ezzel a csipettel rajzoltuk ki, ahol először a fenti 
            számítást 13-ig végezzük, majd 10013, majd 20013-ig, egészen 990013-ig, azaz közel 1 millióig.
            Vegyük észre, hogy az ábra első köre, a 13 értékhez tartozó 1.044023.
        </para>
        <programlisting language="R">
<![CDATA[x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")]]>
        </programlisting>          
        <figure>
            <title>A B<subscript>2</subscript> konstans közelítése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrunKorok.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>
          Az nbatfai program C++-ban bitset-tel. (Bitset miatt compile time tudnunk kell N-et.)
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/primes.cpp"/></textobject>
        </programlisting>
        <figure>
            <title>Az c++ B<subscript>2</subscript> konstans közelítés eredményei</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/brun.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/VkMFrgBhN1g">https://youtu.be/VkMFrgBhN1g</link>
                    </para>    
                </listitem>                
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/aF4YK6mBwf4">https://youtu.be/aF4YK6mBwf4</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>
</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
         
      <section>
        <title>BNF</title>
        <para>statement-ek BNF formában</para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/bnf_c.txt"/></textobject>
        </programlisting> 
      </section>
      <section>
        <title>inline functions</title>
        <para>Inline régebben nem volt.</para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/inline.c"/></textobject>
        </programlisting>
      </section>
      <section>
        <title>új típusok</title>
        <para>Például long long int. Érdemes <literal>-Wall -Wpedantic</literal>-al compile-olni, hogy dobja a hibát.</para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/longlongint.c"/></textobject>
        </programlisting>
        <para>Complex például nem volt része a szabványnak</para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/try_complex.c"/></textobject>
        </programlisting>
      </section>
      <section>
        <title>struct initialization</title>
        <para>Például designated initialization</para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/designatedinit.c"/></textobject>
        </programlisting>
      </section>
      <section>
        <title>mixing decl and code</title>
        <para>Deklaráció lehet akár kód után is</para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/decl.c"/></textobject>
        </programlisting>
      </section>
      <section>
        <title>implicit fn</title>
        <para>Régebben, ha például include math lemaradt, attól még compile működött, mert implicit egy int sin() deklaráció generált. Mivel ez többnyire nem egyezik a valódásgossal, ezért ez általában hibához vezet.</para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/implicitf.c"/></textobject>
        </programlisting>
      </section>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
          Első és legfontosabb, hogy <literal>math.h</literal> atoi atof miatt explicit beraktam. (Persze jogos kérdés, hogy miért kell egyszerre öv és hózentróger a nadrághoz...)
        </para>
        <para>
          Első és legfontosabb, hogy <literal>math.h</literal> atoi atof miatt explicit beraktam. (Persze jogos kérdés, hogy miért kell egyszerre öv és hózentróger a nadrághoz...)
           A Tanár Úr verziója csak valós számokat parse-ol. Az enyémben int és float parse megy külön counterrel.
           Ahhoz hogy ezt elérjük definiáltuk a <literal>DIGIT</literal>-et, és ha 1 vagy több digit van egymás mellett és a végén terminál a karaterlánc, vagy whitespace van, akkor int, ha pedig pont van (és utána 0 vagy több DIGIT) akkor pedig float.
        </para>
        <para>
           A másik dolog, hogy Tanár Úr verziója nem lép ki. Nos, a mi esetünkben a <literal>brexit</literal> karakterlánc hatására a program leáll.
        </para>
        <para>
          Lehetne hosszabban taglalni a feladatot (pl. 1.1e3 parse?), de direkt rövidre vettük.
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/numberparser.lex"/></textobject>
        </programlisting>
        <para>
            A lényeg annyi a flex az alap lex fájl alapján generál egy C forrásfájlt amit aztán le kell fordítani gcc-vel. Annyi hogy gcc compile esetén mellé kell linkelni valamely library-t dependencia miatt. (A bepasszolt -ll vagy -lml stb. flag).
            Ahhoz hogy ez menjen olykor a -lml stb. flag ELŐTT -L"Mypath"-al meg kell adni a lib-et tartalmazó dir abszolút elérését.
        </para>
        <para>
            A kigenerált forrásba nézzünk bele mert érdekes. Láthatóan <literal>label</literal>-eket használ és <literal>goto</literal>-t.
            De mit is ugrál ez a kis szörnyeteg? Nos, a Tanár Úr által említett Turing-os dologról van szó!
            Emlékezzünk a bevprog-os Bjarne Stroustrup-os példára. Ott például emlékezhetünk, hogy nem lehetett simán azt mondani, hogy 1 vagy több digit az int lesz, hiszen ha a következő char . akkor float-ot parse-olunk.
            Nos ez startégia van lekódolva label-ekkel. Ha state machine-ként képzeljük el, akkor gyakorlatilag ezek a label-ek a állapotok.
        </para>
        
        
    </section>                     

    <section>
        <title>Leetspeak</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Annyi történik, hogy a lexernél nem bonyolítottuk túl a szabályokat. Egy szabály van ami bármely char esetén érvényes. 
        </para>
        <para>Alábbi sor annyit jelent, hogy l337d1c7 egy array melynek elemei user defined cipher struct típusúak. Az hogy hány elemű l337d1c7 azt úgy tudjuk meg, hogy l337d1c7 méretét (memóriabeli foglalási méretét) elosztjuk cipher foglalási méretével. Eredményü azt kapjuk hány cipher van az arrayben. Magyarul ez csak egy handy dolog, hogy ne manuálisan kelljen megadni.(it would be prone to errors)</para>
<literallayout>
#define L337SIZE (sizeof l337d1c7 / sizeof (struct cipher))
</literallayout>
        <para>A lényege az egésznek, hogy stdin-re gyűlik az input. Mihelyst EOF van "aktivizálódunk", és minden karaktert egyenként beolvasunk (magyarul nincs sok értelme a lexernek, hisz nincs igazi szabály)</para>
        <para>l337d1c7-t legegyszerűbb egy szótárként felfogni: Minden charhoz megadja a leet beli karakterlánc megfelelőit</para>
        <para>Minden char-nál csinálunk egy lineáris keresést (nem a char-ral, hanem a lowercase verziójával), azaz addig megyünk l337d1c7 amíg meg nem találjuk azt a ciphert amelynek az adott charról szól. Mivel nem biztos hogy lesz ilyen a végén found-dal van egy guard ami annyit jelent, ha nem találtunk a szótárban, akkor írjuk vissza stdout-ra az eredeti chart.</para>
        <para>Ha viszont benne volt a szótárban, akkor generálunk egy random számot(main-ben már megseedetuk sys time-al és linuxon a saját pid-nkkal)</para>
        <para>Ha a random szám</para>
        <para>kisebb mint 91 akkor a szótárból az első karakterláncot írjuk ki stdout-ra</para>
        <para>kisebb mint 95 akkor a szótárból a második karakterláncot írjuk ki stdout-ra</para>
        <para>kisebb mint 98 akkor a szótárból a harmadik karakterláncot írjuk ki stdout-ra</para>
        <para>egyébként a szótárból a negyedik karakterláncot írjuk ki stdout-ra</para>
         <figure>
              <title>leetspeak</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/lolspeak.png" scale="100"/>
                  </imageobject>
                  <textobject>
                      <phrase>leetspeak</phrase>
                  </textobject>
              </mediaobject>
          </figure>
          <para>Alább a source kód</para>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="Chomsky/l337d1c7.l"/></textobject>
          </programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
        </para>
        
        <para>
          Nem kell túlbonyolítani... signal function-nek két argja van: <literal>signum</literal>, és <literal>handler</literal>.
        </para>
        <para>
          Minden signal csak egy szám, hogy "hanyas csatornán jön az üzenet". Ha jön egy jel mondjuk a 15-ös csatornán, akkor az fogja kezelni, aki a 15-ösre be lett állítva.
        </para>
        <para>
          Mikor signal-hoz új handlert rendelünk akkor return-ben visszakapjuk az eddigi handler fn ptr-ét.
        </para>
        <para>
          Annyit még tisztázzunk hogy SIG_IGN egy makró ami egy default handler címévé expandál. Annyi a trükk hogy ennek a címe SOHA nem egyezik meg egy normális funkció címével se. Azaz ez az address unique.
        </para>
        <para>
          Hogy tiszta legyen a kép, alább egy példa program a signal működéséről.
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/signalhandling.c"/></textobject>
        </programlisting>
        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            <para>
              Átállítom ignoredra. Ha eddig is ignored volt minden ok, de ha eddig nem ignored volt, akkor átrakom jelkezelőre.
            </para>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>
                <para>Valid, prefix de mivel az expression return value semmire se kell, ezért lehetne postfix is</para>                
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>
                <para>Valid, postfix</para>                         
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>   
                <para>belép loop-ba, felveszi a nullát i, szóval tomb[0]=0</para>
                <para>következő menetben a postfix miatt, először lemásolja a jelenlegi értéket, inkrementálja i-t, majd a másolt érték lesz a kiértékelés vége.</para>                
                <para>Magyarul tomb[1]=0</para>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>
                <para>Maybe unintended assignment versus equality comparison. (nagyon rossz debuggolni az ilyet, volt vele szerencsém)</para>                
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>
                <para>EZ IGAZI BUG!</para>
                <para>A kiértékelési sorrend nem függ sztenderdtől, szóval bármit kaphatunk (implementáció dönt).</para>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting> 
                <para>Ha a egy ptr akkor okozhat meglepetéseket, de egyébként mivel az értékek alapvetően másolódva adódnak át, ezért ok lehet.</para>                
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>
                <para>Ez sem eldönthető ennyi alapján, annyi hozzáfűzve, hogy f láthatóan okozhat mellékhatást, hisz címet kap, de akár ok is lehet.</para>
            </listitem>
        </orderedlist>
    </section>                     
<!--
    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <para>
          Egyszerűsítésért bevezettem <literal>s</literal> succesor függvényt, illetve <literal>P</literal> predikátumot.
        </para>
<para>&#8704; x &#8707; y ( (x&lt;y) &#8743; (P(y)) )</para>
<para>Bármely x-hez található legalább egy x-nél nagyobb y prím szám.</para>
<para>&#8704; x &#8707; y ( (x&lt;y) &#8743; (P(s(s(y)))) )</para>
<para></para>
<para>Bármely x-hez található oly x-nél nagyobb y szám, mely rákövetkezőjének rákövetkezője prím.</para>
<para>&#8707; y &#8704; x ( P(x) &#8835; (x&lt;y))</para>
<para>Létezik oly y szám, hogy bármely x esetén ha x prímszám akkor x kisebb mint y.</para>
<para>&#8707; y &#8704; x ( (y&lt;x) &#8835; &#172;(P(x)))</para>
<para>Létezik oly y,  hogy bármely x esetén, ha y kisebb mint x, akkor x nem prím.</para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
    </section>                                                                                                                                                                            
                  -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>
        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>   
          <para>Alább mellékeltem egy példát, próbáltam értelmessé tenni, szóval nem csak compile-ol, hanem eredményeket is ad...</para>
       <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/decls.cpp"/></textobject>
        </programlisting> 
        <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>  
                <para>int típusú a nevű változó adott scope-ban.</para>                
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>
                <para>ptr típusú b nevű változó, mely int típusra mutat. értéke legyen az a változó címe.</para>  
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>
                <para>referencia r néven int típusra. referencia mutasson a változóra.</para>
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>
                <para>tömb típusú c nevű 5 elemű int típust taralmazó, inicializálatlan (azaz ram szeméttől függnek értékei)</para>
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>
                <para>referencia tr néven tömbre int elemekkel 5-ös mérettel</para>                
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>  
                <para>d néven tömb(bár igazából minden tömb ptr) 5 elemű elemei int ptr-ek.</para> 
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>
                <para>h néven int ptr return type-ú  void arg-ú függvény.</para>                 
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>    
                <para>l néven fn ptr. A mutatott függvény int ptr return type-ú és void arg-ú</para>                 
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>   
                <para>v néven function. v egy intet fogad és egy fn ptr-et ad vissza. A visszaadott fn ptr int-et ad vissza és két argja van int, int.</para>
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting> 
                <para>z néven egy fn ptr. Fn ptr egy int-et kaphat, és fn ptr-t ad vissza. A visszaadott fn ptr két intet fogad és int-et ad vissza.</para>
            </listitem>            
        </itemizedlist>       
        <para> 
          A typedef használata következik most. DIREKT TÉRTEM EL Tanár ÚR példájától.
          Okom erre az volt, hogy az alábbi pattern-t nagyon gyakran használják  C API-k esetén.
        </para> 
        <para>
          A lényeg az, hogy van valami adatstruktúra, vagy adat, vagy akármi amit zárni akarnak api használó elől, viszont indirekt hozzáférés kell hozzá.
        </para>
        <para>
          Alábbi példában annyi történik, hogy (ismerős lehet Java, Cpp lambdákból) egy funkciót, és egy user defined void ptr-t adunk be, és a library ezt fogja hívogatni.
        </para>
        <para>
          Annyival megspékeltük a dolgot, hogyha a visit function nem 0-t ad vissza akkor a lib megáll és nem iterál tovább.
        </para>
        <para>
          Long story short, ez a program az 5 indexű elemig eliterál, de azt már nem írja ki és befejezi a visit-et.
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Chomsky/typedefedtodeath.c"/></textobject>
        </programlisting>
    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>Mi az az alsó háromszög mx? Nos, vegyünk egy nxn-es mátrixot. A főátló és az alatti elemek az alsó háromszög mx.</para>
<literallayout>
X O O O O
X X O O O
X X X O O
X X X X O
X X X X X
</literallayout>
        <para>Gyakorlati haszna az, hogy ha pl. szimmetrikus a mátrixunk, akkor elég az alsó háromszög mx-ot tárolni.</para>
        <para>Nézzük a kódot, de előtte tisztázzuk malloc-ot és free-t!</para>
        <para>malloc egy értéket vár, hogy hány bájt memória területet(konzisztens, tehát egybefüggően szabad) adjon. Amit vissza ad, az egy ptr a mem a blokk kezdőcímére.</para>
        <para>free egy ptr-t vár. Adott ptr-t kezdeti címnek veszi és ezen címtől kezdve annyit szabadít fel, amennyit a ptr által mutatott típus foglal.</para>
        <para>Alább egy malloc call:</para>
<literallayout>
if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL){
  return -1;
}
</literallayout>
      <para>Azaz kérünk memória nr darab double ptr-nek. Ha malloc nem tud adni, akkor null ptr jön vissza, ezáltal igaz lesz a kondíció és kilépünk -1-el.</para>
      <para>Persze, ez csak a madártávlati nézet, hiszen technikailag, tm-be assignoljuk a malloc által adott értéket és utána checkeljük, hogy tm==NULL -e.</para>
       <para>A lényeg hogyha ezen túl vagyunk, akkor van egy tömbünk a memóriában pointerekkel (melyek double-re mutatnak). Ezek a pointerek jelenleg mem szemetet tárolnak, úgyhogy kezdjük el őket valódi címekkel feltölteni.</para> 
       <para>Mivel nr darab-szor kell elvégezni ugyanazt a műveletet majd, ezért logikusan jön egy for, de nekünk a for teste a lényeg.</para>
<literallayout>
if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
{
    return -1;
}
</literallayout>
       <para>Mivel előbb a malloc-ot tisztáztuk, most inkább a méretbe és az elméletbe akarok belemenni. Mármint miért ez a (i+1) szorzó?</para>
        <figure>
              <title>mem mx</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/mxmem.png" scale="100"/>
                  </imageobject>
                  <textobject>
                      <phrase>mem mx</phrase>
                  </textobject>
              </mediaobject>
          </figure>
        <para>Fenti ábrán látható, hogy minden pointer "eggyel hosszab" blokkra mutat mint a másik, az egész pedig egyről indul (hisz az első a főatlóbeli elemet tartalmazza csak)</para>
       <para>Most ne menjünk bele az alignment-be, meghogy valójában hogyan is tárolódik, inkább örüljünk az ábrának!</para>
      <para>Azaz kérünk blokkokat, megkapjuk a címeket, és ezeket tm[i]-be assignoljuk... </para>
      <para>Sajnos a double-ök még mindig memória szemetet tartalmaznak, ezért felülírjuk őket 0, 1, 2...stb. vel</para>
<literallayout>
for (int i = 0; i &lt; nr; ++i)
    for (int j = 0; j &lt; i + 1; ++j)
        tm[i][j] = i * (i + 1) / 2 + j;
Szamoljuk t[i][j] értékét i=2 j=2 esetben
tm[i][j] = i * (i + 1) / 2 + j;
tm[2][2] = 2 * (2 + 1) / 2 + 2;
tm[2][2] = 2 * 3 / 2 + 2;
tm[2][2] = 3 + 2;
tm[2][2] = 5;
  j 0  1  2
i
0   0
1   1  2  
2   3  4  5
</literallayout>
      <para>Ezekután stdoutra kiprinteljük a mx elemeit soronként</para>
      <para>Ezekután jön egy kis trükközés</para>
<literallayout>
tm[3][0] = 42.0;
egyértelmű

(*(tm + 3))[1] = 43.0;
(tm + 3) = tm + 3*sizeof(double*)
(tm+3) at derefeljük *-gal
azaz megmondjuk, hogy amit ott talál azt egy double ptr-ként értelmezze (hisz ugye alapból double** volt tm...)
utána pedig this[1]=*(this+1*sizeof(double))
Azaz a mátrixba assignolunk tm[3][1]=43

*(tm[3] + 2) = 44.0;
tm[3] = *(tm+3*sizeof(double*))
*(tm[3] + 2) pedig simán annyit hogy tm[3] + 2= tm[3] + 2*sizeof(double)
deref miatt doubleként dolgozzuk fel a cym által mutatott helytől kezdve a memóriát (és ugye annyit amennyi a sizeof(double))
Azaz a mátrixba assignolunk tm[3][2]=44

*(*(tm + 3) + 3) = 45.0;
(tm + 3) = tm + 3*sizeof(double*)
derefeljük úgyhogy double* kapunk.
hozzáadunk 3-at azaz *(tm + 3) + 3 = *(tm + 3) + 3*sizeof(double)
Azaz a mátrixba assignolunk tm[3][3]=45
</literallayout>
  <para>
  Tanár Úr még kérdésként feltette mi van ha 
  </para>
<literallayout>
*(tm + 3)[1] = 43.0;
</literallayout>
  <para>
  Szóval <link xlink:href="https://en.cppreference.com/w/c/language/operator_precedence"> baj </link>. Indirection ugye RL asszociatív és 2-es precedence, míg [] LR asszociatív és 1-es precedence.
  Hogy jól eltudjam magyarázni csináltam egy labortenyésztett frankenstein példát:
  </para>
<literallayout>
*(tm + 3)[1] = 43.0;
*((tm + 3)[1])
*(*((tm + 3)+(1)))
*(*((tm + 4)))
**(tm + 4)
tm[4][0] Azaz a tm[4][0] értéket fogjuk átírni
</literallayout>
<para/>
<literallayout>
0.000000, 
1.000000, 2.000000, 
3.000000, 4.000000, 5.000000, 
42.000000, 7.000000, 44.000000, 45.000000, 
43.000000, 11.000000, 12.000000, 13.000000, 14.000000,
</literallayout>
       <para>
            Újra kinyomtatjuk a mátrixot.
        </para>
        <para>
            Most jön a lényeges rész: mi legyen a memóriával ha már nem kell?
        </para>
<literallayout>
for (int i = 0; i &lt; nr; ++i)
        free (tm[i]);
    free (tm);
</literallayout>
          <figure>
              <title>mem free</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/mxfree.png" scale="100"/>
                  </imageobject>
                  <textobject>
                      <phrase>mem free</phrase>
                  </textobject>
              </mediaobject>
          </figure>
        <para>
            Megoldás forrása: <link xlink:href="Caesar/tm.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Caesar/tm.c"/></textobject>
        </programlisting>
        <para>Bennt hagytam Tanár Úr képét mert jobb mint az enyém.</para>
        <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
        <para>
            A lényeg az egészből az, ha más nem is, hogy azért szertjük a cpp-t, mert nem kézzel kell takarítani, hanem vannak smart pointerek.
            Sajnos azonban shared_ptr esetén overhead-je van a dolognak.
            Illetve azt is érdemes fejben tartani, hogy "kivétel kezelés" esetén a memória kezelést nem szabad elfelejteni.
        </para>
        <para>Ha valaki kíváncsi a címekre</para>
      <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Caesar/tmmore.c"/></textobject>
        </programlisting>        
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
          XOR-ral már találkoztunk a swap feladatnál. Ott már tárgyaltuk, hogy a XOR 
          nagyon különleges művelet tulajdonságai miatt: kommutatív, asszociatív, létezik identitás elem, azaz létezik I, hogy bármely A esetén A XOR I = A.
          Minden bitminta önmagával XOR-ozva Identitást ad, és azt már tisztáztuk hogy A XOR I = A.
        </para>
        <para>
          Ezek alapján az exor program a következő módon működik:
          Vesszük a titkosítandó szöveget és egy kulcsot. Képzeljük úgy, hogy a kulcsot többször a titkosítandó alá terítjük, és az egymás alatt álló karakterek össze XOR-ozásával kapjuk a titkosított szöveget.
        </para>
<literallayout>
ez egy uzenet
kulcskulcskul

Az első lépés "e" XOR "k"
(e) 01100101
(k) 01101011
    00001110
...
</literallayout>
        <para>
          Természetesen, ha titkosított szöveget ugyanazzal a kulccsal mégegyszer le xor-ozzuk, akkor az eredeti szöveget kapjuk vissza:
        </para>
<literallayout>
    00001110
(k) 01101011
(e) 01100101
</literallayout>
        <para>
          Természetesen, ha titkosított szöveget ugyanazzal a kulccsal mégegyszer le xor-ozzuk, akkor az eredeti szöveget kapjuk vissza:
        </para>
        <para>
          Most viszont nézzük meg az implementáció specifikus részleteket.
        </para>
        <para>
          A kódban használunk preprocesszornak szánt utasításokat:
        </para>
<literallayout>
#define MAX_KULCS 100
#define BUFFER_MERET 256
</literallayout>
        <para>
          Ez egyszerűen annyit tesz, hogy a preprocesszor, ha belefut bármikor <literal>MAX_KULCS</literal> vagy <literal>BUFFER_MERET</literal> karakterláncokba, akkor ezeket a megadott int literalokra cseréli.
          Ezek egyébként technikailag azért kellenek, mert tömbökkel fogunk dolgozni és ezek méretét compile time közölni kell a rendszerrel.
          Azért, hogy ne csak számokat arjunk be, ezért olyan nevekkel láttuk el ezeket a preprocesszoros módszerrel, mely a gépi kódot nem változtatja meg, de nekünk segít a kód olvasásban.
        </para>
        <para>
          Nézzük, most a bementről olvasást! Mivel karakteres módban meglepetések érhetnek minket, ehelyett binárisan akarjuk olvasni a dolgokat.
          Tanár Úr megoldásától eltérően én DIREKT NEM stdin és stdout-tal dolgoztam. Ugyanis Mingw esetén csak és kizárólag binary mode-ban lehet a titkosított szöveget normálisan beolvasni.
          Szóval annyit csináltam, hogy fopennel az első explicit futtatási argumentum alapján próbálok READ és BINARY módban nyitni egy fájlt (ugyanezt kimenthez is).
          A lényeg, hogy ha sikeres akkor egy a fájlra mutató ptr-et kapok vissza.
        </para>
<literallayout>
FILE *fdi = 0;
fdi = fopen(argv[2], "rb");
</literallayout>      
      <para>Ezekután kezdődhet a beolvasás. 
      <literal>fread</literal>-nek először átadunk egy ptr-t(buffer) ami az általa használható memória területre mutat (ide fogja írni a fájlból olvasott értékeket). 
      Ezután az 1 konstans annyit mond, hogy minden egység 1 byte (ez sajnos elég veszélyes, lásd encoding).
      Ezután írjuk a max egyhuzamban olvasandó elem számot, ez a mi esetünkben a buffer mérete.
      Végül pedig a ptr az olvasandó fájlra.
      Vissza adott érték az olvasott bájtok száma. Ha 0 az olvasott bájtok száma, a while ciklus fejbeli conditional hamissá válik, azaz abbahagyjuk a ciklus futtatását.
      </para>
<literallayout>
while ((olvasott_bajtok = fread (buffer, 1, BUFFER_MERET, fdi)))
</literallayout>
      <para>Ha sikeres az olvasás, akkor amíg az olvasott bájtok számát el nem érjük karakterenként össze xor-ozzuk a kiindulási szöveg és a kulcs egy karakterének bitjeit.</para>
      <para>Mivel a kulcsot wraparoundolni kell, ezért egész osztást alkamazunk. (Azaz, ha pl kulcsméret 8, és kulcsindex+1=8 lenne akkor az új kulcsindex 8%8=1 ezáltal elkerülve az index out of bounds esetet)</para>
<literallayout>
for (int i = 0; i &lt; olvasott_bajtok; ++i)
{
  buffer[i] = buffer[i] ^ kulcs[kulcs_index];
  kulcs_index = (kulcs_index + 1) % kulcs_meret;
}
</literallayout>
    <para>Ha ezzel meg vagyunk, akkor a mostmár "titkosított" buffer-t kiírjuk a kimenetre</para>
<literallayout>
fwrite (buffer,1, olvasott_bajtok,fdo);
</literallayout>
      <figure>
          <title>exorcmd</title>
          <mediaobject>
              <imageobject>
                  <imagedata fileref="img/exorcmd.png" scale="100"/>
              </imageobject>
              <textobject>
                  <phrase>exorcmd</phrase>
              </textobject>
          </mediaobject>
      </figure>
<para>A példának a facebook csoportba 2017-ben feladott secret.txt-t használtam.</para>
<literallayout>
Bár az RSA jól adja át a nyilvános kulcsú titkosítás tulajdonságait, egy dolgot még nem tárgyaltunk, mely a titkosítás egyik alapkövetelménye, miszerint hogyan tehetjük biztossá, hogy tényleg a feladótól kaptuk az üzenetet, és nem valaki más küldött az ő nevében? Az alábbiakban ezt tárgyaljuk.

Tegyük fel, hogy Alíz (A) Bob (B) nyilvános kulcsát használja, hogy egy titkosított üzenetet küldjön neki. Az üzenetében bizonygathatja, hogy ő valóban A, de B-nek mégsem lesz semmi konkrét bizonyítéka, hogy ténylegesen A írt neki, hiszen a nyilvános kulcsát mindenki használhatja arra hogy titkos üzenetet írjon neki. Ilyen bizonytalanságok elkerülése végett is használható az RSA, hogy RSA szintű biztonsággal tanúsíthassuk szerzői kilétünket. Ezzel a lépéssel pedig az RSA valódi nyilvános kulcsú titkosító eljárássá növi ki magát.

Tehát A szeretne küldeni egy üzenetet B-nek. Kivág az üzenetéből egy kis töredéket – ebből lesz a megjelölt üzenet – veszi ennek mondjuk az ASCII értékét, ezt az értéket felemeli a d-edik hatványára, majd veszi a kapott számot modulo N (pont így csinálná, amikor dekódolna egy üzenetet), s a kapott végeredményt aláírásként hozzácsatolja az egyszerű módon titkosított üzenethez. (Mint látjuk ez is ugyanolyan hatásos mint ha az egész üzenetével az előbb vázolt műveleteket hajtotta volna végre csupán így sokkal gyorsabbá vált, hogy csak egy kis töredék értékre mutatta meg, hogy tényleg A az üzenet szerzője).

Hogyan dekódolja az aláírást B?

Mikor megkapja a megjelölt üzenetet, az aláírást felemeli A nyilvános e kitevőjére, s veszi modulo N az értéket (pont, mint amikor A-nak kódolna egy üzenetet), mivel a két művelet egymás inverzei, ezért összehasonlítja az eredményként kapott kivágott üzenetet az üzenetben szereplő egyszerű módon kódolt szövegrészlettel, s ha a kettő megegyezik, B biztosan tudhatja, hogy az üzenet szerzője A titkos kulcsának birtokában volt.

</literallayout>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Caesar/exor.c"/></textobject>
        </programlisting>        
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section xml:id="bhax-textbook-feladatok-caesar.EXOR-toro">
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            A sima exor-hoz képest annyi a csavarás a feladaton, hogy nem tudjuk a kulcsot, illetve nem tudjuk hogy minek kell lennie a végeredménynek.
        </para>
        <para>
            Az első problémát viszonylag egyszerű módon oldottuk meg, egyszerűen csak keresztül tekerünk egymásba ágyazott for loopokkal
            az összes lehetséges kulcson. Feltételezve, hogy a kulcs csak olyan 0,1,2,3,4,5,6,7,8,9 karakterekből állhat, és a kulcsméret BIZTOSAN 8.
        </para>
        <para>
            A második probléma nehezebb! Hogyan tudjuk, hogy amit törtünk az, nos hogy jó-e?
            A program ezt heurisztikus módon oldja meg...vagy nem oldja meg.
            A lényeg annyi, hogy az algoritmus addig fog futni, amíg az összes kulcsot ki nem próbálta,
            viszont ha felmerül a gyanúja, hogy jó lehet a kulcs amit próbál, akkor stdoutra kiírja a siker gyanús kulcsot és a vele előállított szöveget.
        </para>
        <para>
          A sikeresség eldöntéséhez két dolgot használunk: átlagos szóhossz és gyakori szavak
        </para>
        <para>
          Az átlagos szóhossz...nos elég ember nyelv specifikus, mert , nos inkább nézzük:
          Mivel a space-eket összeszámolja és leosztja a szöveghosszat vele, ezért "aaa aaa aaa " = 4 "aaaaaaaaaaaa   "=4
        </para>
        <para>
          A gyakori szavakat csak simán megpróbálja megtalálni a szövegben (ignore case módban).
          Sajnos az élet nem olyan egyszerű, ezért mingw esetén <literal>strcasestr</literal>-t meg kell írni.
          Nem, itt tényleg nem segít a <literal>#define _GNU_SOURCE</literal> string header előtt...
        </para>
        <para>Na de lássuk a while fejből a read-et!(kicsit megtördeltem)</para>
<literallayout>
olvasott_bajtok
=
read ( 0, 
      (void *) p,
      (p - titkos + OLVASAS_BUFFER &lt; MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p))
</literallayout>
        <para>Első arg 0, tehát stdin, eddig OK. következő egy p ptr, ami a buffer a read szempontjából. Most nézzük a ternary-t önmagában!</para>
        <para>Már a fájl elején észre vehetjük <literal>MAX_TITKOS</literal> és <literal>OLVASAS_BUFFER</literal>-ből, 
        hogy gyakorlatilag annyiról van szó, hogy max 4096 bájtot fogunk összvissz beolvasni, de ezt 256-os falatokban.
        Na de nézzük inkább a kódot, a ternary-t átírtam magyarázat miatt inkább egy if-re alább!
        (NE FELDJÜK: A read 3. argját számítjuk, ami azt adja meg hány bájtot kell olvasni a read-nek. Azaz az egésznek egy számot kell visszaadnia ami megmondja mennyit olvasson a read...)
        </para>
<literallayout>
int num;
if(p - titkos + OLVASAS_BUFFER &lt; MAX_TITKOS) 
{
  num = OLVASAS_BUFFER;
}else{
  num = titkos + MAX_TITKOS - p
}
</literallayout>
    <para>Magyarázattal együtt:</para>
<literallayout>
bool a = (p - titkos + OLVASAS_BUFFER &lt; MAX_TITKOS);
Próbáljuk ki pár értéken:
(p - titkos + 256 &lt; 4096)=?

Let p=1024, titkos=1024
(1024 - 1024 + 256 &lt; 4096)=(256 &lt; 4096)=true
Ekkor ugye azt mondjuk read-nek hogy OLVASAS_BUFFER-nyit tudunk olvasson, szóval p-t növeljük 256-tal!

Let p=4864, titkos=1024
(4864 - 1024 + 256 &lt; 4096)=((3840+256) &lt; 4096)=((4096) &lt; 4096)=false
Ekkor ugye azt mondjuk read-nek hogy (titkos + MAX_TITKOS - p)-nyit olvasson.
Ez jelen esetben (1024 + 4096 - 4864)=256

Most pedig nézzük mi lesz ezután:
ugye p-t 256-tal növeltük, szóval most p=4864+256=5120
(5120 - 1024 + 256 &lt; 4096)=((4096+256) &lt; 4096)=((4352) &lt; 4096)=false
Ekkor ugye azt mondjuk read-nek hogy (titkos + MAX_TITKOS - p)-nyit olvasson.
Ez jelen esetben (1024 + 4096 - 5120)=0

Ez 0 bájt beolvasásával fog járni, ezáltal kiesünk a while-ból.
</literallayout>
  <para>Ezekután annyi történik, hogyha a buffer nem telt meg teljesen akkor kinullázzuk, nehogy a mem szemét véletlenül infonak hasson...illetve string terminálás miatt (általában érdemes null terminálni a c stringeket)</para>
  <para>Ezekután pedig csak simán a fentebb leírt xor-ozást és tiszta szöveg heurisztikus keresgetés zajlik.</para>    
  <para>Egyetlen fontos dolog van még: Ha titkost lexorozom, akkor a következő körben friss kulccsal baj lesz, hisz nem az eredetit hanem egy törtet kezdenék újratörni.</para>   
  <para>A probléma megoldása simán annyi (a xor műveleti tulajdonságai miatt), hogy nem plusz memóriát használok egy tiszta verzió tartására, hanem vissza xorozom ugyanazon array-t. ÉS ugye emlékszünk hogy (A XOR B) XOR B = A </para>
   <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Caesar/exor_breaker.c"/></textobject>
        </programlisting>         
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
          Ebben a feladatban a double*** handling a lényeg, de mindez cpp-ben, azaz malloc és free helyett new és delete.
          Tanár Úr kódját fogom használni, de a nem szükséges részeket kivettem (hisz egyébként 900 sor és például backpropagation nem kell...). 
        </para>
        <para>
          Mielőtt nekiugrunk a feladatnak nézzük végig matematikailag mit akart elérni Tanár Úr, és csak ezután nézzük a kódot.
          Ez így talán megfogja könnyíteni a megértést, hisz például a var arg handling nem a feedforward része, úgyhogy csak azután fogunk kitérni rá, hogy az alap matek megvan.
          Backproppal most nem fogunk foglalkozni, csak feedforward-al. Tegyük fel egy 3x3as "képből" indulunk ki (nem rgb, csak fekete és fehér).
          A 3x3-asból előállítunk egy vektort. Ez lesz az input adata a hálónak.
        </para>
        <para>
          Feladat legyen a következő: Kapunk egy 3x3-as fekete képet. Ezt beküldjük egy neurális háló kezdeménybe, és a végén például egy 1 elemű vektort kapunk.
          A vektor 0. eleme akkor és csak akkor 1 értékű, ha a képen mondjuk 4-es van. Cseresznye a torta tetején: Nincs bias.
        </para>
        <para>
          Első hallásra bonyolult, de valójában egyszerű: 
        </para>
        <para>
          A kép egy 3x3-as mátrix, lapítsuk egy vektorba. Ez lesz az input.
        </para>
        <figure>
              <title>nn input</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/nninputs.png" scale="50"/>
                  </imageobject>
                  <textobject>
                      <phrase>nn input</phrase>
                  </textobject>
              </mediaobject>
        </figure>
        <para>
          A háló hasraütésszerűen (totál mindegy, csak kellettek a konkrét számok, hogy le tudjam rajzolni) 9-5-3-1
        </para>
        <figure>
              <title>nn layers</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/nnlayers.png" scale="50"/>
                  </imageobject>
                  <textobject>
                      <phrase>nn layers</phrase>
                  </textobject>
              </mediaobject>
        </figure>
        <para>
          A háló a következő módon működik: nincs benne feedback, azaz i-edik layeren lévő node csak és kizárólag i-1-edik node-ot használhat inputnak. 
        </para>
        <para>
          Ahelyett, hogy hardcodeoljuk ki kihez kapcsolódik a pagerank-nél látott módon mátrixos formában írjuk fel.
          Vegyük például a 9 elemű input layer és az 5 elemű layer (ő az eső hidden layer) kapcsolatát leíró mátrixot.
          A layerek gyakorlatilag vektorok.
          A lényeg, hogy kell egy M kapcsolati mátrix. A célja annyi, hogyha megszorzom egy 9 elemű-vel, akkor egy 5 eleműt kapjak.
          A kapcsolati mátrix tehát pl. 5x9-es, hisz M*A=B:
        </para>
 <literallayout>
          | ? |
          | ? |
          | ? |

| ? ? ? |       = | ? |
| ? ? ? |         | ? |
</literallayout>
        <para>Azaz, ha kapok egy inputot, akkor össze szorzom a 9-5 közti trafó mátrixxal, és megkapom az 5 elemű layer értékeit. Utána ezt megszorzom az 5-3 trafóval, majd ezt megszorzom a 3-1 trafóval és kijön a végeredmény:</para>
        <figure>
              <title>nnmxmult</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/nnmxmult.png" scale="50"/>
                  </imageobject>
                  <textobject>
                      <phrase>nnmxmult</phrase>
                  </textobject>
              </mediaobject>
        </figure>
        <para>
          Azaz, az egész egy mátrix vektor szorzás lánc (sőt, mivel nincs bias ezért még elméletben sem kell trükközni).
          Egyetlen egy komoly trükk van. Mikor kijön egy mátrix-vektor szorzás segítségével egy új vektor, akkor minden elemén alkalmazzuk a sigmoid funkciót.
          Ez egy folytonos jellegű vágó függvény.
        </para>
        <figure>
              <title>sigmoid</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/sigmoid.png" scale="50"/>
                  </imageobject>
                  <textobject>
                      <phrase>sigmoid</phrase>
                  </textobject>
              </mediaobject>
        </figure>
        <para>
            Ez alapján próbáljuk meg meghatározni milyen adatokra lesz szüksége az n layer számú Perceptron-nak. El kell tárolni n darab vektort. El kell tárolni n-1 darab transzformációs mátrixot.
            Mivel kicsit C-sen fogjuk írni a kódot, ezért nem csak az értékeket, ha nem a tömb méreteket is. Szóval el kell tárolni hogy hány layer van. El kell tárolni, hogy MINDEN vektor hosszát. A trafó mátrixok hosszait nem kell eltárolni, mert ahogy az ábrák is mutatják a vektor hosszakból számolhatóak.
        </para>
        <para>
          Mielőtt belemegyünk a kódba, egy dolgot még tisztáznunk kell: Milyen értékei legyenek a weight mátrixoknak? Nos, teljesen random [-1,1] tartománybeli double.
        </para> 
        <para>
          Most nézzük a kódot. Létrehozzuk a Perceptron osztályt. Ctor-ban inicializáljuk
        </para>  
        <para>
          A Perceptron ( int nof, ... ) kicsit furcsának tűnhet mert var arg-os, de nem kell megijedni. Simán annit jelent, hogy int nof után véges sok argumentum jöhet.
        </para>
<literallayout>
va_list vap;
va_start ( vap, nof );
</literallayout>
        <para>
        va_list-ből pedig va_arg-gal pedig megpróbálunk egy általunk megadott explicit típusú értéket "kiszedni" a listából.
        (Ezek makrók nem function call-ok, azaz ezeket a preprocesszor expandálni fogja.)
        </para>
<literallayout>
n_units[i] = va_arg ( vap, int );
</literallayout>
        <para>
          Egyből jön a kérdés, hogy itt akkor elméletileg bug-ok keletkezhetnek <link xlink:href="https://en.cppreference.com/w/cpp/language/variadic_arguments">default arg promotion</link> miatt. Igen ez így van de mi ezzel most nem foglalkozunk.
          Másik kérdés, hogy mi történik akkor, ha nof nem egyezik a megadott argumentumok száma -1-el.
        </para>
        <para>
          Mikor megvagyunk a va_list traversalt illető makró használattal <literal>va_end</literal>-et használunk.
        </para>
<literallayout>
va_end ( vap );
</literallayout> 
      <para>
        Nézzük a ctor-t pici részekben:
      </para>      
<literallayout>
n_layers = nof;
    units = new double*[n_layers];
    n_units = new int[n_layers];
    va_list vap;
    va_start ( vap, nof );
    for ( int i {0}; i &lt; n_layers; ++i ){
      n_units[i] = va_arg ( vap, int );
      if ( i ){units[i] = new double [n_units[i]];}
    }
    va_end ( vap );
</literallayout>
        <para>
          A Perceptron osztályt ctor-ban egy int-et kap, azaz a layer számot, illetve var arg-ként int-eket, amik az egyes layer-ekben lévő neuron számokat adják meg (azaz hogy melyik layer hány elemű vektor).
          Ezt simán átmásoljuk <literal>n_units</literal>-ba, ami egy int-ekből álló tömb. A <literal>units</literal> tárolja a vektorainkat, szóval érthető hogy ez miért is double** (n darab vektor matematikailag).
          Természetesen egyrészt magát <literal>units</literal>-ot initelni kell, és az általa mutatott double array-ket is. Ugyan értékeket még nem tudunk, de a szükséges hosszakat igen, hisz ezt a user megadta var arg-ban.
        </para> 
      <para>Annyit vegyünk észre, hogy ha i == 0, akkor nem kérünk helyet egy double array-nek. Ez amiatt van így, mert ez az inputunk, inputot meg nem fogjuk átmásolni, hanem majd <literal>units[0]</literal>-t megadjuk az input címének (hisz ugye units[0] egy double ptr!)</para>
      <para>A másik nagyon fontos dolog, amit észre kell vennünk az az hogy nem malloc-ot használunk hanem new-t. Méghozzá úgy hogy new-nak nem adunk címet ahova hívja a ctor-t, azaz new MEMÓRIÁT IS FOGLAL és még ráadásul MEG IS HÍVJA a ctor-t. Persze kérhettün volna malloc-cal címet és a ptr-et megadva new-nak nem kért volna memóriát csak a megadott címen meghívta volna a ctor-t.</para> 
      <para>Na de most nézzük a weight mátrixot! Gyors kérdés kód előtt: Mit várunk?</para>
      <para>Ugye <literal>weights</literal> egy csomó mátrix, tehát weights = mátrix*? Viszont mátrix egy csomó sor, vagy szám n-es, stb., azaz mátrix=sor*. Sor viszont egy csomó double, vektor=double*. Azaz weights double*** lesz.</para>
<literallayout>     
weights = new double**[n_layers-1];
    std::default_random_engine gen;
    std::uniform_real_distribution&lt;double&gt; dist ( -1.0, 1.0 );
    for ( int i {1}; i &lt; n_layers; ++i ){
      weights[i-1] = new double *[n_units[i]];
      for ( int j {0}; j &lt; n_units[i]; ++j ){
        weights[i-1][j] = new double [n_units[i-1]];
        for ( int k {0}; k &lt; n_units[i-1]; ++k )
        {
          weights[i-1][j][k] = dist ( gen );
        }
      }
    }
</literallayout>
  <para>Ahogy fent láthatjuk, kérünk helyet weights-nek (aki egy double***), aztán weights egyes mátrixainak (double**), mátrixok sorainak (double*) majd a sorok értékeinél egy [-1,1] tartománybeli random számot adunk. </para>
  <para>A sigmoid-ot valamiért a class-ba raktuk(inkább rakjuk majd egy header file-ba inline-olva saját implementációban, hátha kelleni fog máshol is), de nem igényel túl sok magyarázatot.</para>
<literallayout>  
  double sigmoid ( double x ) {
    return 1.0/ ( 1.0 + exp ( -x ) );
  }
</literallayout>
  <para>Most pedig jöhet az <literal>operator()</literal> overload. Ő fogja csinálni azt a mátrix vektor szorzási láncot amit fentebb rajzolgattunk.</para>
  <para>Kicsit álljunk meg, tippeljük meg előre mit fog csinálni!</para>
  <para>Valószínűleg lesz egy argumentuma, ami egy double* lesz. Ez lesz az input layer bemeneti adata. Ezt KELL hogy assignolja units[0]-ra, hisz units[0]-nak nem kértünk egy új double*-t(és jelenleg ráadásul szuper veszélyes, mert nem állítottuk nullptr-re, hanem mem szemét van rajta, szóval ha most meghívnánk akkor jó esetben segfaultolnánk.)</para>
  <para>Ezekután pedig végig fogunk iterálni az összes trafón és elvégezzük őket. DE EMLÉKEZZÜNK n darab vektorunk van, amihez n-1 trafó társul, azaz biztosan n-1-ig fogunk iterálni.</para>
  <para>Egy adott i-edik iterációban pedig i-edik mátrixot i-edik vektorral szorozva i+1-edik vektort fogjuk kapni.</para>
  <para>Technikailag mielőtt elvégezzük i+1 elem kiszámítását, vaószínűleg 0-ra fogjuk állítani, mert adja magát, hogy += használjunk.</para>
  <para>Miután kijönnek az értékek vagy egyben a végén, vagy még benn a loopban, az mátrix-vektor szorzatként kapott i+1 vektor értékét átírjuk  a sigmoid által hozzárendelt értékre</para>
  <para>Nézzük a kódot</para>
<literallayout>  
  double operator() ( double image [] )
  {
    units[0] = image;
    for ( int i {1}; i &lt; n_layers; ++i ){
      for ( int j = 0; j &lt; n_units[i]; ++j ){
        units[i][j] = 0.0;
        for ( int k = 0; k &lt; n_units[i-1]; ++k ){
          units[i][j] += weights[i-1][j][k] * units[i-1][k];
        }
        units[i][j] = sigmoid ( units[i][j] );
      }
    }
    return sigmoid ( units[n_layers - 1][0] );
  }
</literallayout>
  <para>Az egyetlen váratlan dolog, hogy az ouptput vektor 0. elemének értékéhez a sigmoid által hozzárendelt értéket visszaadjuk.
    Biztos a nagyobb progi így működött, azaz hogy valami miatt az output vektor 0. eleme fontos volt neki. Persze ez ne tévesszen meg senkit. Egy klasszifikciós probléma lehet olyan lesz, hogy mondjuk 10 output node lesz, és akkor kell felvillania mondjuk az 5-ös indexűnek mikor 5-öst lát, vagy mondjuk valami játékról van szó, és akkor kell felvillania egy 4 elemű vektor 2 elemének, ha keyboard S lenyomást akarunk szimbolizálni (FPS-eknél ez a hátra)
  </para>
  <para>
    Alább az egész kód félig Cpp félig C-ben:
  </para>
  <programlisting language="c" linenumbering="numbered">
    <textobject><textdata fileref="Caesar/ql_min.cpp"/></textobject>
  </programlisting> 
  <para>
    Alább az egész kód Java-ban kilapított mátrixokkal. Itt az API-ban annyi változás van, hogy a full output vektort visszaadjuk.
  </para>
  <programlisting language="java" linenumbering="numbered">
    <textobject><textdata fileref="Caesar/ql_min.java"/></textobject>
  </programlisting> 
  <para>
    Többszálazással stb. nem foglalkoztam, mert a feladat az array hendlingről szólt. (Backproppal sem, mert explicit ki lett mondva hogy elég a feedforward)
  </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            A Mandelbrot halmaz számításához egy kis matekra lesz szükség. Nagyon vizualizációba most nem fogunk kód oldalról belemenni, mert egy másik alfejezet pont erről fog szólni...
        </para>
<literallayout>
z[0] = 0
z[1] = z[0]^2+c
z[2] = z[1]^2+c
...
z[n] = z[n-1]^2+c 
</literallayout>
        <para>
          Azaz mindig 0, 0 pontból indulunk, majd négyzetét vesszük és egy konstans számot hozzáadunk. Nézzünk pár esetet! Az ábrákon valós tengely vízszintes, míg képzetes függőleges. Az ábrán piros X-el jelöltem a konstanst és az step-eket fekete pontokkal (össze is kötöttem őket).
        </para>
        <figure>
            <title>c = {0,0}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep00.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>c = {0,0}</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <figure>
            <title>c = {0.3 ,0}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep01.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>c = {0.3 ,0}</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <figure>
            <title>c = {0.3 ,0.1}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep02.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>c = {0.3 ,0.1}</phrase>
                </textobject>
            </mediaobject>
        </figure>
         <figure>
            <title>c = {0.3 ,0.2}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep03.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>c = {0.3 ,0.2}</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
         Ha a konstant például 0.3, 0.7 akkor nagyon gyorsan "elszáll" az érték.
        </para>
        <figure>
            <title>c = {0.3 ,0.7}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep08.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>c = {0.3 ,0.7}</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
          Mit is csináltunk tulajdonképpen? Nos, rögzítettük 0,3 re értéket, és elkezdtük "pásztázni" im értékeket 0,1-es lépés közzel.
          A kódban is ezt fogjuk csinálni, csak minden pásztázott ponthoz (re im pár) rögzíteni fogjuk mennyi iteráció után kerültek ki az origó 2 sugarú köréből. 
          Azért hogy ne fusson a végetelenségig, ezért az iterációknak lesz egy teteje.
          Azaz ha a max iter számot elérjük akkor meg fogunk állni.
        </para>
        <para>
          A user megad egy re alsó és felső határt (mettől meddig pásztázunk Re tengelyen), illetve ugyanezt Im tengelyen.
          A lépésszám állítható is lenne, de mivel a legvégén terminálra akarunk írni, ezért ettől most eltekintünk.
        </para>
        <para>
          Tanár Úrtól eltérően én feldaraboltam a kódot, de csak azért hogy egyszerűbb legyen bemutatni.
        </para>
        <para>
          Az első kód részlet egy olyan funkció, aminek adunk egy komplex konstanst és egy max iter számot, és ez a fent bemutatott algoritmust végigcsinálja.
          A visszaadott érték az iter szám. Ha ez alacsony akkor nagyon gyorsan elszállt a számítás, ha magas akkor sokáig stabil volt.
        </para>
<literallayout>
int mandel(
    float c_re, 
    float c_im, 
    int max_iter)
{
  int i = 0;
  float temp=0.0, z_re=0.0, z_im=0.0;
  while ( ( ((z_re*z_re)+(z_im*z_im)) &lt; 4.0 ) &amp;&amp; ( i &lt; max_iter ) )
  {
    temp =(z_re*z_re)-(z_im*z_im)+c_re;
    z_im = 2.0*(z_re*z_im)+c_im;
    z_re=temp;
    i++;
  }
  return i;
}
</literallayout>
        <para>
          A második kód részlet már csak boilerplate kód.
          Erősen átírtam Tanár Úréhoz képest, direkt hogy int**-t használjunk.
          A másik dolog, hogy Tanár Úré valami miatt a második for bodyban számolja c reál és imaginárius részét is érthetőség miatt, én ezt egy picit optimáltam.(elég a külsőben számolni az egyiket)
          Annyi történik, hogy végig járjuk a kapott rácsot és kitöltögetjük, hogy melyik komplex konstans-hoz mennyi iter tartozik.
        </para>
<literallayout>
void apply_mandel(
    int** quad_mx, 
    int re_size, 
    int im_size,
    float re_lo, 
    float re_hi, 
    float im_lo, 
    float im_hi, 
    int max_iter)
{
  
  int re_step,im_step,itercount;
  float d_re,d_im,c_re,c_im;
  if(quad_mx == NULL || re_size &lt; 1 || im_size &lt; 1) return;
  d_re = (re_hi-re_lo)/re_size;
  d_im = (im_hi-im_lo)/im_size;
  for(re_step = 0; re_step &lt; re_size;++re_step){
    c_re = re_lo + d_re * re_step;
    for(im_step = 0; im_step &lt; im_size;++im_step){
      c_im = im_hi - d_im * im_step;
      itercount = mandel( c_re,c_im,max_iter);
      quad_mx[re_step][im_step]=mandel( c_re,c_im,max_iter);
    }
  }
}
</literallayout>
        <para>
          A harmadik rész maga a main. Csak beolvassuk a usertől mely határok között számoljunk, illetve deklaráljuk initeljük az int ptr ptr-t, plusz a végén feltakarítunk.
        </para>
    <programlisting language="c" linenumbering="numbered">
    <textobject><textdata fileref="Mandel/mandel.c"/></textobject>
  </programlisting>
        <figure>
            <title>A Mandelbrot halmaz win, csak iter számok</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelnums.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz win, csak iter számok</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <figure>
            <title>A Mandelbrot halmaz win, színes</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel0.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz win, színes</phrase>
                </textobject>
            </mediaobject>
        </figure>
         <figure>
            <title>A Mandelbrot halmaz win, színes, határ állítás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel1.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz win, színes, határ állítás</phrase>
                </textobject>
            </mediaobject>
        </figure>
        

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
          Png++ helyett SDL2-t fogunk használni, és egyenesen a képernyőre renderelünk.
          A feladat szempontjábó érdekes részek a MandelDraw class-ba kerültek.
        </para>
        <para>
          Az osztály az alábbi állapotváltozókkal rendelkezik. Egyedül a b c és d szorulnak külön magyarázatra.
          Ugye egy valós és képzetes tengelyünk van.
          a és b azt mutatja meg hogy a valós tengelyen mettől meddig száímtunk.
          c és d azt mutatja meg hogy a képzetes tengelyen mettől meddig száímtunk.
        </para>
<literallayout>
int w; // scrren width
int h; // screen height
int iter_lim; // iteration limit for mandel
double a; // 
double b;
double c;
double d;
</literallayout>
      <para>Az egyetlen funkció a render. Ez egy SDL renderer ptr-t kap és elvégzi az értékek számítását és a rendernek megmondja mey pixel milyen rgba számokat kapjon.</para>
      <para>Maga a számítás ugyanaz mint az előbbiekben. j a képzetes része a koordinátáknak, k a valós része.
      j és k-t úgy mappeljük fel a képernyőre, hogy j jelentse a képernyő esetén az y-t (magasság), k pedig x-et azaz hosszat.</para>
<literallayout>
void render(SDL_Renderer *renderer)
{
  int szazalek = 0; // unused
  double dx = ( b - a ) / w;
  double dy = ( d - c ) / h;
  double reC, imC, reZ, imZ;
  int iteracio = 0;
  for ( int j = 0; j &lt; h; ++j ){
    imC = d - j * dy;
    for ( int k = 0; k &lt; w; ++k ){
      reC = a + k * dx;
      std::complex&lt;double&gt; c ( reC, imC );
      std::complex&lt;double&gt; z_n ( 0, 0 );
      iteracio = 0;
      while ( std::abs ( z_n ) &lt; 4 &amp;&amp; iteracio &lt; iter_lim ){
        z_n = z_n * z_n + c;
        ++iteracio;
      }
      SDL_SetRenderDrawColor(renderer, iteracio%255, (iteracio*iteracio)%255,0, 0xff);
      SDL_RenderDrawPoint(renderer, k, j);
    }
    szazalek = ( double ) j / ( double ) h * 100.0;
  }
}
</literallayout>
      <para>
        Ahhoz hogy forduljon például a következő flageket kell használni <literal>g++ mandelcx.cpp -Wl,-subsystem,windows -lmingw32 -lSDL2main -lSDL2</literal>
      </para>
      <figure>
        <title>mandelcx comp</title>
        <mediaobject>
            <imageobject>
                <imagedata fileref="img/mandelcx_comp.png" scale="100"/>
            </imageobject>
            <textobject>
                <phrase>mandelcx comp</phrase>
            </textobject>
        </mediaobject>
    </figure>
    <para>arg-ok nélkül futtatva default értékekkel a következő renderelődik. A programból úgy lehet kilépni, hogy a megnyílt ablakot default bezáró gombot nyomjuk például.</para>
    <figure>
        <title>mandelcx</title>
        <mediaobject>
            <imageobject>
                <imagedata fileref="img/mandelcx.png" scale="100"/>
            </imageobject>
            <textobject>
                <phrase>mandelcx</phrase>
            </textobject>
        </mediaobject>
    </figure>
    <para>A fájl többi része SDL specifikus. Az egyetlen érdekes dolog, hogy a program egy while-ban fut és egy bool változóval kontrolláljuk a kilépést ezen ciklusból.
    A változó alapvetően true értékű, azonban, ha ablakbezárást érzékelünk, akkor ezt átállítjuk.</para>
    <para>Event handling-gel nem játszottunk. A lehető legegyszerűbben valósítottuk meg, ugyanis csak a kilépésre kell figyelni. Az utazóban persze ezt majd kicsit át fogjuk alakítani.</para>
      <programlisting language="c++" linenumbering="numbered">
        <textobject><textdata fileref="Mandel/mandelcx.cpp"/></textobject>
      </programlisting>        
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
          Az előző mandelbrot feladat mintájára, csak a számítási algoritmust illetve a formális paramétereket, és azok technikai kezelését kell módosítani.
        </para>
        <para>De mi is az a biomorph? Nos, emlékezzünk, hogy mandelbrot esetben kézzel 0,0-ból lépegettünk egy az alábbi diagramon meghatározott piros pont (re és im koordináták miatt ugye ez egy komplex szám)-tot adogattunk hozzá miután négyzetre emeltük.</para>
        <para>Azaz piros ponttal körbejárattuk a képernyő által jelentett komplex számsíkot, és minden pontba beírtuk mennyi lépés után szállt el a számítás (vagy kerültünk egy adott origó köéppontú adott R sugarú körön kívülre.)</para>
        <figure>
            <title>mandel step</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep01.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>mandel step</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>Biomoprh-nál egyetlen dolog történik: nem 0,0-ból indulunk hanem egy magadott pontból. Alábbi diagramon kékkel jelöltem egy példát.</para>
        <figure>
            <title>biomorph iter</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/biomorphods.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>biomorph iter</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>Emiatt ugye szükség lesz két új paraméterre: a kezdő pont valós és képzetes koordináta párosára.</para>
        <para>A másik paraméter egy R szám. Ez azért kell, mert az iterációs terminálásának kondícióját megváltoztattuk: Akkor lépünk ki az iterációból, ha vagy valós, vagy képzetes tengelyen R-nél távolabb kerülünk az origótól.</para>
        <para>Az eredeti kódot kicsit tehát módosítani kell!</para>
        <para>std::pow az erdetiben köbös, viszont mi nyuszit akarunk rajzolni, ezért négyzetes kell.</para>
        <para>A másik változtatás, hogy akkor lépünk ki a ciklusból, ha vagy elértük iter_limitet vagy a számított komplex szám távolabb van origótól, mint R, azaz abszolút értékét vesszük. Ez gyakorlatilag a vektor hossza lenne, ha pl. valami 2d-s grafikával dolgoznánk.</para>
<literallayout>
std::complex&lt;double&gt; cc ( reC, imC );
double dx = ( xmax - xmin ) / w;
double dy = ( ymax - ymin ) / h;
for ( int y = 0; y &lt; h; ++y ){
    for ( int x = 0; x &lt; w; ++x ){
        double reZ = xmin + x * dx;
        double imZ = ymax - y * dy;
        std::complex&lt;double&gt; z_n ( reZ, imZ );
        int iteracio = 0;
        for (int i=0; i &lt; iter_lim; ++i){
            z_n = std::pow(z_n, 2) + cc;
            if( std::abs(z_n) &gt; R){
                iteracio = i;
                break;
            }
        }
        SDL_SetRenderDrawColor(renderer, (iteracio * 20)%255, (iteracio* 40)%255, (iteracio* 60)%255 , 0xff);
        SDL_RenderDrawPoint(renderer, x,y);
    }
}
</literallayout>
    <para>Compile esetén g++-nak a szokásos sdl által megkövetelt flag-eket küldjük, azaz <literal>g++ biomorph.cpp -Wl,-subsystem,windows -lmingw32 -lSDL2main -lSDL2</literal></para>
        <figure>
            <title>biomorph comp</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/biomorphcomp.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>biomorph comp</phrase>
                </textobject>
            </mediaobject>
        </figure>
    <para>Ha mindent jól csináltunk akkor, egy biomorph <link xlink:href="https://mathworld.wolfram.com/DouadysRabbitFractal.html">nyuszival</link> kell találkoznunk.</para>
        <figure>
            <title>biomorphnyuszi</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/biomorphnyuszi.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>biomorphnyuszi</phrase>
                </textobject>
            </mediaobject>
        </figure>

        <figure>
            <title>biomorph</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/biomorph.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>biomorph</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <programlisting language="c++" linenumbering="numbered">
          <textobject><textdata fileref="Mandel/biomorph.cpp"/></textobject>
        </programlisting>   
        <para>
            A biomorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para>                                                                                
    </section>                                       

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>SDL2. EventBus-t, vagy signal-slot rendszert DIREKT nem írtunk, de valós életben így kéne... helyette simán az állapotváltozókkal jeleztem a történéseket.</para>
        <para>Argumentumok nélkül futtatható. Debug üzenetekért kimenetet irányítsuk log file-ba stb. Debug log-hoz megfelelő preproc #define-t uncommentelni...</para>
        <para>Zoom-olást bal klikkel indítja az ember. Nyomva tartva a bal gombot téglalapot rajzol a program.</para>
        <figure>
            <title>zoom rect</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandeltrav2_zoom.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>zoom rect</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>A téglalap húzgálásra DIREKT TARTJA a képernyő arányt.</para>
        <para>Bal egérgomb felegendéskor a kijelölt téglalap alapján történik a nagyítás.</para>
        <figure>
            <title>zoom</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandeltrav2_zoom2.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>zoom</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>A nagyítás konkrét frame-jében nem a teljes képet számoljuk. Ehelyett dinamikus számú sornyi pixelt számolunk ki mindig. A lényeg hogy 60 FPS a cél, ha túl sok időt vesz igénybe adott frame-en a dolog, akkor abbahagyjuk a zsámítást, és majd következő frame-ben folytatjuk.</para>
        <para>Ha épp számolódik a background, és újra nagyítunk DIREKT nem tisztítjuk a buffert.
          User szinten emiatt egy érdekes egymásra lapolódás lesz megfigyelhető. Alábbi ábrán egy futó számítás közben újra nagyítottunk.
          Az előző számítási értékek természetesen egyből eltűnnek, ha a jelenleg futó odaér a buffer írásban.
        </para>
        <para>A fentiekből következik, hogy a nagyítás DIREKT "lassul" és "gyorsul" olykor, nem hiba. Ha az épp most számolandó sorok gyorsan elszállnak, akkor gyorsan végez velük azaz szuper gyorsan végezni fog velük.
        Ellenkező esetben ha a neki kiosztott sorok nagyon sokáig benn maradnak az R sugarú Q-beli körben, akkor kevés ilyen sort tud kiszámolni egy frame alatt, ezért úgy fog tűnni. mintha lassulna.</para>
        <figure>
            <title>zoom quick succession</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandeltrav2_zoom_quick_succession.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>zoom quick succession</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>Jobb gombbal kapcsoljuk be a tracert. Ez egy predefined iter számig végig számítja a komplex számokat. Ehhez c komplex számot(amit mindig hozzáadunk) a user egér pozíciója alapján veszi.</para>
        <figure>
            <title>tracer 0</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandeltrav2_tracer0.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>tracer 0</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <figure>
            <title>tracer 1</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandeltrav2_tracer1.png" scale="100"/>
                </imageobject>
                <textobject>
                    <phrase>tracer 1</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>Egér középső gombot vagy görgőt megnyomva visszaugrik default zoomba. 
        Összességében fájt event-ek nélkül, de meg lehet csinálni.
        Huzzah...
        </para>
        <programlisting language="c++" linenumbering="numbered">
          <textobject><textdata fileref="Mandel/mandelcx_utazo2.cpp"/></textobject>
        </programlisting>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            A lényeg, hogy adott egy számítási algoritmus melyet meghívva nem csak a következő értéket, hanem a rákövetkezőt is megkapjuk.
            Azaz az 1. hívásnál kell számítani, de a 2. hívásnál nem kell, hiszen az 1. számítás a 2. értékét is kiszámította előre.
            Azért hogy ezt kezeljük egy egyszerű osztályt fogunk írni.
            Ahhoz hogy ezt a "bufferelést" megoldjuk két változót vezetünk be: magát a tárolt értéket, illetve egy boolean-t, hogy jelenleg úgy szólván szabad-e aktívnak tekinteni a tárolt értéket.
        </para>
<literallayout>
boolean store_empty;
double stored;
</literallayout>
        <para>
            Maga az algoritmus csak simán annyiról szól, hogy ha store_empty true, akkor kell számítást végezni.
            A számítás első eredményét visszaadjuk, a másikat betároljuk, és a store_empty-t false-re állítjuk.
            Ha store_empty false, akkor store_empty-t true-ra állítjuk, hisz úgymond ürítjük a buffert, és visszaadjuk a tárolt értéket.
        </para>
        <para>
          A feladat könnyebb megértéséhez egy hackelt verzió az eredeti java class-ból.
        </para>
      <programlisting language="java" linenumbering="numbered">
        <textobject><textdata fileref="Welch/PolarGen2.java"/></textobject>
      </programlisting>
       <para>
           Alább az eredeti feladat:        
       </para>
      <programlisting language="java" linenumbering="numbered">
        <textobject><textdata fileref="Welch/PolarGen.java"/></textobject>
      </programlisting>
       <para>
          C++ esetben három különbség lesz: random, sqrt és log. 
       </para>
       <para>
          [0,1) tartományon random double generálását végezhetjük az alábbi módon. Ehhez szükség lesz stdio-ra rnd() illetve RAND_MAX miatt.
       </para>
<literallayout>
double rnd01(){return rand() / (RAND_MAX + 1.);}
</literallayout>
        <para>
          sqrt és log a már ismert math lib-ben van, azaz ne felejtsük include-olni.
       </para>
       <programlisting language="c++" linenumbering="numbered">
        <textobject><textdata fileref="Welch/PolarGen.cpp"/></textobject>
      </programlisting>
    </section>        

    <section>
        <title>LZW</title>
        <para>
          Mielőtt neki ugrunk egy kis áttekintés a <link xlink:href="https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat">progpater</link> alapján.
        </para>
        <para>
          A programunk kapni fog egy {0,1} karakterekből (bár lehetnének bitek is) álló mintát. Ez alapján memóriában 
        </para>
<literallayout>
01111001001001000111
</literallayout>
        <para>
          A kapott minta alapján memóriában létre kell hoznunk egy fát.
          A fa csomópontokból áll. Minden csomóponthoz tartozik egy érték illetve lehet két gyermeke, továbbiakban jobb és bal.
          A fa továbbá tartalmaz egy segéd ptr-t arra a csomópontra, ahol éppen állunk.
          A következő szabályok szerint építjük a fát:
        </para>
        <itemizedlist mark="bullet">
          <listitem>
            <para>Alapból a gyökér létezik értéke /, és ezen gyökér csomóponton állunk(erre mutat a segéd ptr).</para>
          </listitem>
          <listitem>
            <para>Ha 0-t kapunk, és létezik bal gyermek, akkor a segéd ptr-rel innentől erre fogunk mutatni.</para>
          </listitem>
          <listitem>
            <para>Ha 0-t kapunk, és nem létezik bal gyermek, akkor segéd ptr által mutatott node bal gyermekeként létrehozzuk. Segéd ptr-rel pedig gyökérre mutatunk innentől.</para>
          </listitem>
          <listitem>
            <para>Ha 1-t kapunk, akkor teljesen szimmetrikusan a fenti két szabályt jobb gyerekre alkalmazzuk.</para>
          </listitem>
        </itemizedlist>
        <para>Pici példácskán, mondjuk 0110-re, nézzük meg hogy működik! Minden lépésnél ábrázolni fogom a fát is! Csillaggal árbázoljuk hol áll éppen a segéd ptr!</para>
<literallayout>
Feldolgozva=[]
---/*
Feldolgozva=[0]
---/*
------0
Feldolgozva=[01]
------1
---/*
------0
Feldolgozva=[011]
------1*
---/
------0
Feldolgozva=[0110]
------1
---------0
---/*
------0
</literallayout>
        <para>Most nézzük meg mi ez az egész max, átlag, szórás!</para>
        <para>Két fogalmat azonban be kell hozzá vezetni. Az egyik a levél, a másik a mélység.</para>
        <para>Egy csomópontot levélnek nevezünk, ha nincsenek gyermekei.</para>
        <para>Egy csomópont mélységén azt értjük (ezen esetben) hogy a hány csomópont érintésével tudunk eljutni gyökér nodeból az adott node-ba.</para>
        <para>Vegyük propateres példát és írjuk fel rá kézzel az értékeket!</para>
<literallayout>
------------1(3)
---------1(2)
------1(1)
---------0(2)
------------0(3)
---------------0(4)
---/(0)
---------1(2)
------0(1)
---------0(2)
melyseg=4
altag=2.750000
szoras=0.957427
</literallayout>
        <para>Max mélység alatt a legnagyobb mélységet értjük, azaz 4-et.</para>
        <para>Átlagmélység a leaf mélységek összege osztva a leaf számmal, azaz:</para>
<literallayout>
hosszak={3,4,2,2}
leafs=4

atlag=4/3+4/4+2/4+2/4
atlag=0.75+1+0.5+0.5
atlag=2.75

</literallayout>
        <para>A teljes fa szórása alatt a szórásösszeg és a levél szám hányadosának négyzetgyökét értjük. Meg kell jegyezni, hogy valójában leaf számnál eggyel kisebb számot használunk 1-nél nagyobb leaf számú esetekben.</para>
        <para>Szórásösszeg, az összes levél szórásának összege.</para>
        <para>Egy node szórása alatt az adott node mélységének átlagmélységtől vett különbségének négyzetét értjük.</para>
<literallayout>
hosszak={3,4,2,2}
leafs=4
atlag=2.75

szorasosszeg=(3-2.75)^2+(4-2.75)^2+(2-2.75)^2+(2-2.75)^2
szorasosszeg=0.0625+1.5625+0.5625+0.5625
szorasosszeg=2.75
szoras=(2.75/4-1)^0.5
szoras=(0.9166667)^0.5
szoras=0.957427
</literallayout>
    <para>Most hogy kézzel kiszámoltuk, írjuk át C-re.</para>
    <para>A C kódban akét komoly eltérés a Tanár Úr féle kódtól:</para>
    <itemizedlist mark="bullet">
      <listitem>
        <para>allokáció/felaszabadításnál a ptr-t kiírjuk standard output-ra</para>
      </listitem>
      <listitem>
        <para>Általános traversalokat használunk funtcion ptr-ekkel</para>
      </listitem>
    </itemizedlist>
    <para>A ptr-ek kilogolása csak amiatt fontos hogy grafikus visszajelzést is kapjunk, hiszen most ugye dinamikusan allokált adatokkal dolgozunk, amelyeket kézileg kell életciklus menedzselni.</para>
<literallayout>
void free_node(int depth, Node* node, UserData*ud)
{
  if(node == NULL) return;
  #ifdef CUSTOM_DEBUG_OUT
    printf("Free node %p\n",node);
  #endif
  free(node);
}
</literallayout>
    <para>Az általános traversal amiatt kellett, hogy egy kicsit az stl-es algorithm-re hajazva, legyen lehetősége a user-nek megadnia, hogy mi történjen, a fa pedig csak a helyes traversalért legyen felelős.</para>
    <para>Nézzünk egy példát!</para>
<literallayout>
void foreach_inorder(int depth,Node* root, traversal_fn fptr, UserData* ud )
{
  if(root == NULL) return;
  foreach_inorder(depth+1,root-&gt;right, fptr, ud );
  fptr(depth,root,ud);
  foreach_inorder(depth+1,root-&gt;left, fptr, ud );
}
</literallayout>
  <para>Láthatóan a fenti funckió simán rekurzívan hívja magát a két child-ra. A fn ptr csak akkor jön be a képbe mikor magát az adott subtree root-ját dolgozzuk fel. UserData csak egy typedef-elt void ptr, hogy a user állapotot is betudjon adni, ne csak viselkedést.
  Egy példa fn amit fn ptr-ként beküldhetünk legyen a print</para>
<literallayout>
void print_node(int depth, Node* node, UserData*ud)
{
  int i;
  if(node == NULL) return;
  for(i=0;i&lt;depth; ++i){printf("---"); }
  printf("%c (%d) %p\n",node-&gt;value, depth,node);
}
</literallayout>
  <para>A számolásokhoz simán végigszaladunk a leafeken és mivel nem tudjuk előre a leaf számot, ezért egy dinamikusan allokált helyre gyűjtjük be a leaf-ek mélységeit. De csinálhattuk volna úgyis hogy többször megyünk végig a leaf-eken és akkor kevesebb memóriát használtun volna, azaz CPU vs. MEM tradeoff.</para>
  <para>Igen... <literal>LeafCountData</literal>-t totál kikerülhettük volna: bedobhattuk volna simán a nyers ptr-t aztán inkrementáltuk volna...</para>
  <para>Alább a progpater-es példa inputként kimeneten.</para>
    <figure>
        <title>Lzw C output</title>
        <mediaobject>
            <imageobject>
                <imagedata fileref="img/btreec.png" scale="100"/>
            </imageobject>
            <textobject>
                <phrase>Lzw C output</phrase>
            </textobject>
        </mediaobject>
    </figure>
    <para>Alább a C forrás</para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Welch/btreec.c"/></textobject>
    </programlisting>
    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
          Az előző feladatban még a free-t is a function ptr-es traversallal csináltuk, azaz az előző feladatban ez részletezésre került.
          Alábbi kód részleten látszik, hogy az előző részben bevezetett módon elég egyszerű a dolog.
        </para>
<literallayout>
  printf("\nPREORDER\n");
  foreach_preorder(0,bt-&gt;root,print_node,NULL);
  printf("\nPOSTORDER\n");
  foreach_postorder(0,bt-&gt;root,print_node,NULL);
</literallayout>
        <para>A hangsúly a fn ptr alkalmazásán van. Ha azt értjük, akkor az alábbi kép nem lesz meglepő.</para>
        <figure>
        <title>Traversals</title>
        <mediaobject>
            <imageobject>
                <imagedata fileref="img/traverslasc.png" scale="100"/>
            </imageobject>
            <textobject>
                <phrase>Traversals</phrase>
            </textobject>
        </mediaobject>
    </figure>
    </section>        
                        
    <section>
        <title>Tag a gyökér</title>
        <para>
          A Twitch-es nbatfai megoldást fogom átszerkeszteni.
          A builderezést és lambdázást a mozgató szemantika részben fogom csinálni, ahol tényleg nullából újra írom.
        </para>
        <para>
          Mivel az nbatfai root ptr-esre alapszik, és azt a következő fejezetben dolgoztam ki, itt effektíve csak egy diff-et írok doksiba.
        </para>
        <para>
          Mielőtt belemegyünk, annyit érdemes tisztázni, hogy ValueType-tól nem várhatjuk el, hogy lesz default ctor-a, így sajnos a tree ctor-ához hozzá kell nyúlni.
        </para>
        <para>
          Magyarul, ha biztosra tudnánk venni, hogy ValueType halmaznak van egy speciális eleme ami a halmaz alját, vagy null-t vagy stb.-t jelentené, akkor nem kéne mindenképpen értéket kérni a tree ctorban.
          Azonban ez elég erős megkötés lenne.
        </para>
        <para>
          Kilenc helyen értem hozzá a kódhoz, ezek tételes felsorolása és magyarázata alább következik.
        </para>
        <para>
          Az első módosítás a tree ctor. Én úgy gondolom érdemes mindenképpen explicit értéket kérni, mert különben arra kéne hagyatkoznunk, hogy ValueType-nak van default ctor-a.
          Természetesen treep-t root címére kell állítanunk.
        </para> 
<literallayout>
BinTree(ValueType rootval) : root(rootval), treep(&amp;root), depth(0)
</literallayout>
        <para>
          Az második módosítás a dtor-t illeti. Mivel root kompozíciós tag, ezért csak a child node-okra kell hívnunk a rekurzív delete-t.
        </para>
<literallayout>
deltree(root.left_child() );
deltree(root.right_child() );
</literallayout>
        <para>
          A harmadik módosítás a bintree leftshiftet érinti. Root ptr-es esetben vizsgálni kell, hogy root létezik-e, viszont ezen esetben ha tree létezik akkor root-is (Java-ban swing-ben van erre sok példa, hogy van egy default úgymond implicit root mindig.).
        </para>
        <para>
          A negyedik módosítás hasonlóan a bintree leftshiftet érinti. Treep-nek magát root-ot nem assignolhatjuk, hanem root címe fog kelleni.
        </para>
<literallayout>
treep = &amp;root;
</literallayout>
        <para>
          Az ötödik módosítás <literal>ZLWTree</literal> template mentesítése. Enélkül az eredeti kód implicit konverziókat fog végezni és a leftshift is rosszul fog működni char-tól eltérő datatype esetén.
        </para>
        <para>
          A hatodik módosítás valójában csak annyi, hogy delegáltuk a node példányosítást BinTree ctor-nak.
        </para>
<literallayout>
ZLWTree() : BinTree&lt;char&gt;('/')
</literallayout>
        <para>
          A hetedik, nyolcadik és kilencedik módosítás valójában csak annyi, hogy root címe kell treep-nek hisz az pointer.
        </para>
        <programlisting language="c++" linenumbering="numbered">
          <textobject><textdata fileref="Welch/zlwtreerootcomp.cpp"/></textobject>
        </programlisting>
        <para>Persze hogy ne legyen baj, akár a ctorba is bepasszolhatjuk argként root és leftshift comparatorban használt value-t</para>
        <programlisting language="c++" linenumbering="numbered">
          <textobject><textdata fileref="Welch/zlwtreerootcomp2.cpp"/></textobject>
        </programlisting>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
          A kísérleti nbatfai twitch adásban látható megoldás lehet egy példa erre.
        </para>
        <para>
          Áttekintve annyiról van szó, hogy a egyszerre egy bináris fát és egy lzw fát fogunk csinálni.
          Kód duplikáció elkerülése végett pedig inheritance-t használunk.
          Apró kellemetlenség hogy egyenesen cpp-be megy, de mozgató szemantikás feladatban a saját megoldásomban úgyis nulláról újraírom az egészet, és ott már header is lesz.
        </para>
        <para>
          Úgy döntöttem <literal>ZLWTree</literal>-t template mentesítem és explicit <literal>BinTree&lt;char&gt;</literal>-ról származtatom, mert ctor és left shift esetében alul definiált lenne.
        </para>
        <para>
          Úgy döntöttünk hogy nesteljük bele a node osztályt.
          Talán ennek a bemutatásával érdemes kezdeni a dolgot:
        </para>
<literallayout>
class Node
  {
    ...
    ValueType value;
    Node* left;
    Node* right;
    int count;
  };
</literallayout>
      <para>ValueType BinTree template paramétere, ezt (mivel inner class), használhatjuk Node esetén is.</para>
      <para>Left right a gyermekekre mutató, ctor-ban nullptr-re initelt pointerek.</para>
      <para>Count a bináris kereső fa miatt fontos állapotváltozó. Egyszerűen annyiról van szó, hogyha például egy Bintree&lt;int&gt; be kétszer left shiftelek mondjuk 9-et, akkor ne két külön node jöjjön létre 9-es value-val. Ehelyett ilyen esetben a már létező 9-es értékű node count állapotváltozóját fogjuk a második 9-es miatt inkrementálni.</para>
      <para>A funkciók csak egyszerű setter-ek getter-ek. Incr count pedig csak egy shortcut, mert a count setter-t get_count()+1 kéne hívni.</para>
      <para>Most nézzük tree állapotváltozóit!</para>
      <para>Root a gyökérre mutató ptr. Treep a fenti manuális példákban a segéd ptr, míg depth egy internal változó, amit a traversalnál fogunk használni annak adminisztrálására, hogy milyen mélyen vagyunk.</para>
      <para>Persze, treep és depth nem kell törvényserűleg BinTree-be rakni. A mozgató szemantikás delegáljuk is majd ezt a felelősséget egy iterátornak ami csak és kizárólag a faépítéséért felelős.</para>
      <literallayout>
template&lt;typename ValueType&gt;
class BinTree
  {
    ...
    Node* root;
    Node* treep;
    int depth;
  };
</literallayout>
    <para>Viselkedések közül a left shift a legfontosabb, hiszen ez a node példányosítást végzi.</para>
<literallayout>
template&lt;typename ValueType&gt;
BinTree&lt;ValueType&gt;&amp; BinTree&lt;ValueType&gt;::operator&lt;&lt;(ValueType value)
{
  if(!treep){
    root = treep = new Node(value);
  }else if(treep-&gt;get_value() == value){
    treep-&gt;incr_count();
  }else if(treep-&gt;get_value() &gt; value){
    if(!treep-&gt;left_child()){
      treep-&gt;left_child(new Node(value));
    }else{
      treep = treep-&gt;left_child();
      *this&lt;&lt;value;
    }
  }else{
    if(!treep-&gt;right_child()){
      treep-&gt;right_child(new Node(value));
    }else{
      treep = treep-&gt;right_child();
      *this&lt;&lt;value;
    }
  }
  treep = root;
  return *this;
}
</literallayout>
    <para>Class-on kívül definiáltuk, de természetesen továbbra is template-es.</para>
    <para>A funkció minden esetben azzal zár hogy visszaugrunk root-ra.</para>
    <para>Ha a value egyenlő azzal a value-va amit a jelenlegi segéd ptr mutat, akkor csak inkrementálni fogjuk.</para>
    <para>Ha a value kisebb akkor bal irányba fogunk "mozdulni".</para>
    <para>Ha balra nincs még node, akkor létrehozunk egy bal gyermek node-ot a jelenleg treep által mutatott node-on.</para>
    <para>Ha balra van már node, akkor treep-t áthelyezzük és rekurzívan újra meghívjuk a funkciót (de ugye nem ugyanaz fog történni, hisz treep már máshol áll!).</para>
    <para>Ha az érték nagyobb akkor teljesen szimmetrikusan jobb irányba végezzük el ugyanezt</para>
    <para>print egy egyszerű inorder bejárást végez. Ezt a C-s példában fn ptr-el, a mozgatósban később pedig functorral fogjuk kiváltani.</para>
    <para>Itt annyit érdemes megjegyezni, hogy depth az <literal>BinTree</literal>osztály tulajdonsága.</para>
<literallayout> 
template&lt;typename ValueType&gt;
void BinTree&lt;ValueType&gt;::print(Node* node, std::ostream&amp; os)
{
  if(node){
    ++depth;
    print(node-&gt;right_child(),os );
    for(int i = 1; i &lt; depth; ++i){os &lt;&lt; "---";}
    os &lt;&lt; node-&gt;get_value() &lt;&lt; " " &lt;&lt; depth &lt;&lt; " " &lt;&lt; node-&gt;get_count() &lt;&lt; std::endl;
    print(node-&gt;left_child(),os );
    --depth;
  }
}
</literallayout>
  <para>deltree csak postorder-ben végig járja a node gyökerű subtree-t és felszabadítja a foglalt memóriát. A C-s kódban ez az a rész amit direkt címre pontosan ki is irattam.</para>
<literallayout>
template&lt;typename ValueType&gt;
void BinTree&lt;ValueType&gt;::deltree(typename BinTree&lt;ValueType&gt;::Node* node)
{
  if(node){
    deltree(node-&gt;left_child() );
    deltree(node-&gt;right_child() );
    delete node;
  }
}
</literallayout>
<para>ZLWTree esetén kicsit más a left shift. Ezt manuálisan levezettük feljebb. Az egyetlen külön említést érdemlő dolog az az hogy, 
  mivel class-on kívül írjuk a definíciót ezért globál namespace-ben nincs csak úgy benne Node varázsütésre.
  Ez látható a node példányosításos sorokban.</para>
<literallayout>
ZLWTree&amp; ZLWTree::operator&lt;&lt;(char value)
{
  if(value=='0'){
    if(!this-&gt;treep-&gt;left_child()){
      typename BinTree&lt;char&gt;::Node* node = new typename BinTree&lt;char&gt;::Node(value);
      this-&gt;treep-&gt;left_child(node);
      this-&gt;treep = this-&gt;root;
    }else{
      this-&gt;treep = this-&gt;treep-&gt;left_child();
    }
  }else{
    if(!this-&gt;treep-&gt;right_child()){
      typename BinTree&lt;char&gt;::Node* node = new typename BinTree&lt;char&gt;::Node(value);
      this-&gt;treep-&gt;right_child(node);
      this-&gt;treep = this-&gt;root;
    }else{
      this-&gt;treep = this-&gt;treep-&gt;right_child();
    }
  }
  return *this;
}
</literallayout>
  <para>Alább látható a zlw progi kimenete</para>
    <figure>
        <title>ZLW out</title>
        <mediaobject>
            <imageobject>
                <imagedata fileref="img/zlwout.png" scale="100"/>
            </imageobject>
            <textobject>
                <phrase>ZLW out</phrase>
            </textobject>
        </mediaobject>
    </figure>
      <programlisting language="c++" linenumbering="numbered">
        <textobject><textdata fileref="Welch/zlwtreerootptr.cpp"/></textobject>
      </programlisting>
    </section>                     

    <section>
        <title>Mozgató és másoló szemantika</title>
        <para>
          Az előbbiekben megírt osztáy(oka)t fogjuk felkészíteni mozgatásra és másolásra.
          Ez a következő viselkedések implementációját vonja maga után:
        </para>
        <itemizedlist mark="bullet">
          <listitem>
            <para>Copy ctor</para>
          </listitem>
          <listitem>
            <para>Copy assigment</para>
          </listitem>
          <listitem>
            <para>Move ctor</para>
          </listitem>
          <listitem>
            <para>Move assigment</para>
          </listitem>
        </itemizedlist>
        <para>
          Először a copy-val és utána  a move-al fogunk foglalkozni.
        </para>
        <para>
          Nézzük a copy ctor-t! Sajnos nem egyszerű a dolgunk. Gondoljunk bele, hogyha másolni akarjuk a fát, 
          akkor a root node-ot át kell másolnunk az újba. Viszont ha itt megállunk, akkor az új root node-unk a régi root node gyerekeire fog muattni,
          és amikor az egyik fa törlődik, akkor szépen ki fogja törölni a másik fa alól is a gyerekeket.
          Emiatt nem elég root-ot másolni, hanem deltree-hez hasonlóan rekurzívan másolni kell minden node-ot, effektíve klónozva a fát.
          Ezt nevezzük deep copy-nak (shallow copy lenne, ha csak pl. root-ot másolnánk.)
          Ilyet automata módon a compiler nem csinál, ezért nekünk kell megírni.
        </para>
        <para>
          Sajnos még mindig van egy baj. Ha a fentiek alapján megírnánk a kódot, akkor lenne két tökéletesen jó fánk A és B.
          Ahogy A-ba shifteljük az értékeket, azok szépen jelennének meg A-ban. Mi lenne B esetben?
        </para>
        <para>
          Nos, azzal a buggal szembesülnénk, hogy ahogy shifteljük B-be az értékeket, azok A-n jelennek meg egy darabig olykor, hiszen B treep-je a régi A egy node-jára mutatna, amíg treep vissza nem ugrana root-ra.
          Hogy ezt elkerüljük a deep copy során treep-t is menedzselni kell, azaz amikor épp azon node-ot másoljuk amin a régi treep van,
          akkor a másik B fa treep-jét az új node-ra állítjuk.
        </para>
<literallayout>
BinTree(const BinTree&amp; old)
{
  #ifdef LOG_TREE_LIFECYCLE
    std::cout&lt;&lt;"btree copy ctor "&lt;&lt; static_cast&lt;void*&gt;(this) &lt;&lt; std::endl;
  #endif
  root = deep_copy(old.root,old.treep);
}
</literallayout>
        <para>
          Deep copy esetén első arg-ként a régi A tree egy node-ját, másodikként a régi treep-t kapjuk.
          Ha a régi node nullptr akkor csak visszaadunk egy nullptr-t.
          Ha azonban létezik, akkor csinálunk egy újat átmásoljuk az értéket (pontosabban a ctor-ba arg-ként küldjük), és átmásoljuk a count int típusú data membert.
          A rekurzív rész most jön, ugyanis a gyerek node-okat nem a régi fa nodejaira akarjuk állítani, hanem újonnan készített node-okra.
          Azaz ezekre újból rekurzívan hívjuk deep_copy-t.
          Ezt persze mind bal mind jobb gyereknél meg kell csinálni.
          A végén ellenőriznünk kell, hogy az a régi node amit jelenleg dolgoztunk fel éppen véletlenül az-e amire a régi treep mutatott.
          Ha ez így van akkor az új fa treep-jét átállítjuk az új node-ra.
        </para>
<literallayout>
Node* deep_copy(Node* old_n, Node* old_treep)
{
  Node* newn = nullptr; 
  if(old_n){
    newn = new Node(old_n-&gt;get_value());
    newn-&gt;left_child(deep_copy(old_n-&gt;left_child(),old_treep));
    newn-&gt;right_child( deep_copy(old_n-&gt;right_child(),old_treep));
    if(old_n==old_treep){this-&gt;treep=newn;}
  }
  return newn;
}
</literallayout>
    <para>
      A következő a move assignment. Itt annyi történik, hogy a régi BinTree instance és az új BinTree instance root illetve treep pointereit megcseréljük.
      Nem kell ki nullptr-ezni a saját root és treep-nket swap előtt, hiszen ha már move assignment hívódik, akkor ezek vagy eleve nullptr-ek, vagy valid ptr-ek.
    </para>
<literallayout>
BinTree&amp; operator=(BinTree&amp;&amp; old)
{
  #ifdef LOG_TREE_LIFECYCLE
    std::cout&lt;&lt;"btree move assign "&lt;&lt; static_cast&lt;void*&gt;(this) &lt;&lt; std::endl;
  #endif
  std::swap(old.root,root);
  std::swap(old.treep,treep);
  return *this;
}
</literallayout>
    <para>
      A következő a move ctor. Itt kihasználjuk move assignmentet.
      Vegyük észre, hogy előtte a saját root és treep-t nullptr-e vesszük fel.
       Ha nem így tennénk akkor ezek uninitialized-ok lennének, magyarul memória szemét lenne rajtuk, és invalid helyekre mutatnának.
    </para>
<literallayout>
BinTree(BinTree&amp;&amp; old)
{
  #ifdef LOG_TREE_LIFECYCLE
    std::cout&lt;&lt;"btree move ctor "&lt;&lt; static_cast&lt;void*&gt;(this) &lt;&lt; std::endl;
  #endif
  root = nullptr;
  treep = nullptr;
  *this=std::move(old);
}
</literallayout>
  <para>
    Copy assignment a copy ctor, move ctor és move assignment ismeretében egy trükkel könnyen megvalósítható.
    Egyszerűen létrehozunk egy temp nevű ctor body scope-an létező lokális BinTree instance-t.
    Ezen BinTree instance copy ctor-ral lemásolja a régit.
    Ezután std::swap-el tmp és a jelenleg this által mutatott BinTree példányok közt cserét hajt végre.
    Mikor elhagyjuk a ctor scope-ot a this által mutatott instance életben marad (ő az old másolat),
    a régi pedig "elpusztul", azaz dtor hívódik az általta mutatott címre majd fel lesz szabadítva az általa foglalt memória terület.
  </para>
<literallayout>
 BinTree&amp; operator=(const BinTree&amp; old)
  {
    #ifdef LOG_TREE_LIFECYCLE
      std::cout&lt;&lt;"btree copy assign "&lt;&lt; static_cast&lt;void*&gt;(this) &lt;&lt; std::endl;
    #endif
    BinTree tmp(old);
    std::swap(*this,tmp);
    return *this;
  }
</literallayout>
        <para>
          Alább a teljes kód.
        </para>
      <programlisting language="c++" linenumbering="numbered">
        <textobject><textdata fileref="Welch/zlwtreerootptr_mv_cp.cpp"/></textobject>
      </programlisting>
        <para>
          Ha a traversalt esetleg egy user supplied lambdára akarjuk cserélni akkor alábbi kódban találhatunk rá megoldást:
          Az előző kódhoz képest itt a számítást is megcsináltuk. Mármint node depth max, átlag, szórás.
        </para>
        <programlisting language="c++" linenumbering="numbered">
        <textobject><textdata fileref="Welch/lzw.cpp"/></textobject>
      </programlisting>
    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Szoftmax Py MNIST</title>
        <para>
            Python
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/j7f9SkJR3oc">https://youtu.be/j7f9SkJR3oc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0">https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0</link> (/tensorflow-0.9.0/tensorflow/examples/tutorials/mnist/), <link xlink:href="https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol">https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol</link>  
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        

<!--
    <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
    
    <section>
        <title>Mély MNIST</title>
        <para>
            Python            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
<!--
    <section>
        <title>Deep dream</title>
        <para>
            Keras            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->                  
    <section>
        <title>Minecraft-MALMÖ</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/bAPSu3Rndi8">https://youtu.be/bAPSu3Rndi8</link>      
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
                
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/z6NJE2a1zIA">https://youtu.be/z6NJE2a1zIA</link>      
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
<!--        
    <section>
        <title>Weizenbaum Eliza programja</title>
        <para>
            Éleszd fel Weizenbaum Eliza programját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->
    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>    
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        

<!--    
    <section>
        <title>Lambda</title>
        <para>
            Hasonlítsd össze a következő programokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
-->    

<!--
    <section>
        <title>Omega</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
      <title>Programozási Alapfogalmak</title>
     <!-- SUBSECTION -->
    <section>
      <title>Gépi kód, assembler, magasabb szintű nyelvek</title>
      <para>         
        Mielőtt beszélünk a típusokról nézzünk egy nem típusos nyelvet! A <citation>NANDTOTETRIS</citation>-hez írtunk egy c++ interpreter jellegű programot, mely úgy viselkedik mintha egy vlós CPU lenne(csak jóval egyszerűbbek az opcode-ok).
        A lényeg, hogy 2 regiszter van. A és D. A "Adress" ugyanis a jump-ok mindig az A-ban lévő értékű címre ugranak. D "Data" register pedig egy "sima" regiszter. "A" regiszterrel a trükközés azért kell, mert így borzasztóan egyszerűve válnak az opcode-ok.
        0-kat és 1-eseket nem akarunk írni, ezért írtunk rá egy assemblert.
        Alább látható egy szuper egyszerű assembly kód erre a teljesen minimalista kis gépre. 
      </para>
<literallayout>
@2
D=A
@3
D=D+A
@0
M=D
</literallayout>
      <para>         
        Direkt a fenti egyszerűbbet mert látható a példán egy gcc -S -el készült sima main-ből ez lesz a körítés miatt.
      </para>
      <programlisting language="c" linenumbering="numbered">
        <textobject><textdata fileref="cbook/assemblyexample.txt"/></textobject>
      </programlisting>
      <programlisting language="c" linenumbering="numbered">
        <textobject><textdata fileref="cbook/chip.hdl"/></textobject>
      </programlisting>
        <para>         
          A lényeg, hogy az assembler (label és egyéb dolgok mellett) elsősorban azt a célt szolgálja, hogy a fenti szöveg átforduljon bytecode-ra.
          Alább látható a fordított gépikód.
        </para>
<literallayout>
0000000000000010
1110110000010000
0000000000000011
1110000010010000
0000000000000000
1110001100001000
</literallayout>
      <para>         
        Sajnos, el kellett engednem a teljes leírást, mert egyszerűen nincs rá idő, de komolyan ajánlom mindenkinek a <citation>NANDTOTETRIS</citation>-t.
        Alább például látszik egy szuper bugyuta kis ALU. Akármennyire bugyuta és tele van csalással a lényeg, hogy közelebb visz a szoftver és hardware találkozásához, ahol az igazi varázslat történik. (Hisz papíron ugyan Gödel megcsinálta, de sok idő kellett mire mindekinek lett macskáskép nézegetője.)
        Másrészről nincs jobb érzés, mint amikor megcsinálja az ember a kapukat, majd ráküldi a kódot és megtudja vele csinálni a "for"-t!
        Tényleg fáj a szívem hogy nincs módom berakni a doksiba. De őszintén ajánlom a könyvet, mert valójában az NEM EGY KÖNYV. Minden fejezet egy minimális elméleti alapozó és utána szuper egyértelmű task-ok vannak, TESZTEKKEL és platformmal együtt. Annyi, hogy én nem szeretem a Java-t mert az Oracle gonosz, ezért csak az assembler-es részt rossz minőségű c++-ban reprodukáltam a <link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Gutenberg/hack">ide</link>.
      </para>
      <para>         
            Ha valakit abszolút nem érdekel a dolog, akkor is egyszer javaslom, csak amiatt, hogy átérezzük, hogy mennyire komoly segítséget adnak a mérnökinfósok és villamos mérnökök nekem illetve nekünk.
      </para>
      <para>         
        Ha pedig valakit a mérnökinfósok sem érdekelnek és nem szeret olvasni, legalább vessen egy pillantást <link xlink:href="https://youtu.be/cgVVZMfLjEI?t=1925">erre</link>.
      </para>
      <para>         
          Nincsenek típusok, minden "szó" N menyiségű bitből álló rendezett 16-os. Műveleteket nem definiálhatunk magunk, hisz azt a CPU csinálja.
        </para>
        <para>         
          Innentől kezdve bármit tanulunk emlékezzünk arra, hogy hasonló lesz a vége. (Persze a valóságban jóval összetettebb, de 1-esek és 0-k lesznek a legadvancedebb cpp kódból a nap végén.)
        </para>
        <para>         
          A típus megadja a gépnek hogy mikor írtunk egy programot és ráengedjük a lexert, parsert, compilert vagy interpretert akkor mit fogadjon el egyáltalán.
          Azaz hogy milyen elemei lehetnek. Azaz a típus egy halmazként is felfogható, melynek elemei a lehetséges értékek.
          Halmazoknál ugye felsorolhatjuk, de akár ha pro-k vagyunk szabályokkal is megadhatjuk (emlékezzünk a természetes számok halmazán successor-ra, vagy akár a modulo kongruencia osztályokra egészeknél)
        </para>
        <para>         
          A típus megadja a gépnek hogy milyen műveleteket és hogyan kell végezni.
          Például egy bool-t ha negálunk más történik, mintha egy int-et. Sőt, sokszor nem is lehet bizonyos dolgokat értelmezni, például Várterész Tanárnő nem nagyon szorozgatott igaz-t hamis-sal (majd később belemegyünk a szorzásba, most simán csak gondoljunk gyerekkorunkban tanultakra).
        </para>
        <para>         
          A típus megadja a gépnek hogy hogyan kell interpretálni az adatot. Például gondoljunk egy egyszerű C struct-ra, van két char fieldje "foo" és "bar". Elrakjuk valahova a memóriába (és tároljuk a címét), majd kis idő múlva kellene az "b" field. Honnan fogjuk tudni, hogy a sok bit közül hol kezdődnek a "b" field bitjei illetve, hogy hány bitből is áll?
          Például erre (is) ad válazt a primitív char típus.
        </para>
        <para>         
          Amit még nagyon fontos lefektetni, az az hogy inheritance, primitív típus, template mind csak fluff és eyecandy a CPU szempontjából. Előbb utóbb mindenből 0101 0011 1111 0000 lesz. Igen igen 32 64, plusz valójában nem egy szó kerül be stb. de a lényeg hogy mindent számokra képezünk le. Az összes többi dolog csak és kizárólag azért kell, mert az ember biológiailag nem 0 és 1 olvasásra és nagy sebességű aritmetikai műveletek elvégzésére fajlődött hanem az ágakon tekergő kígyók elől való elugrálásra.
        </para>
        <para>         
          A tankönyv említi hogy forrásszöveget írunk, amelyből aztán két mágiával lehet gépi kód. Compiler-es és interpreter-es. Ez a valóságban sajnos nem ilyen egyértelmű. Nézzünk például egy Java-s példát. Igen compiled, de...mégis a VM stack machine-en fut. A stack machine csak egy absztrakció, nem a tiszta vas. Ez is a középpontja az Java azon ígéretének mi szerint "write once, run before Oracle sues you for using VM without paying your subscription for server side usage".
        </para>
        <para>         
          Másik Java példa: Project Lombok. Fel annotáljuk meta nyelven a forrás szöveget, és a class file-ba belegeneráljuk a boilerplate code-ot, anélkül, hogy telenyomnánk vele a source-t.
        </para>
        <para>         
          Másik Java példa: Spring, xml vagy reflection (annotation) based meta adatok. Igen a forrás fájl része, de egy framework használja az adatokat...
        </para>
        <para>         
          És a akkor a kedvencem: Írok egy progit C-ben. Mondjuk egy macskáskép játék. A business logic-ot direkt C helyett Lua-ban írom, magyarul a C programom tartja számon a Lua state-t. A programom compiled, viszont ha a lua szkriptet változtatom alatta akkor gond nélkül hot swappelhetem mondjuk szerver oldalon. Most akkor része a business logic a programomnak? Vagy a programom egy hyper program ami önmaga nem a macskás játék? De hát a grafikus funkciók C-ben vannak írva? A lényeg, hogy nem ilyen egyértelmű a dolog.
        </para>
        <para>
          Arról pedig már ne is beszéljünk, amit egy JIT compiler egy átlagos hétfő délután csinál.
        </para>
      
        <para>         
          A tankönyv ezután belemegy a fordító programok világába. Ez ahogy láttuk nem egy merev dolog, de ennél még rosszabb is történhet. Egyes "compiler"-ek azért vannak hogy C-kódot generáljanak valami deklaratív jellegű nyelvből. De ennél még rosszabb, hogy van aminek az a célja hogy C kódot fordítson Javascriptre.
          A fordítás általános feladatai a tankönyv szerint a következőek:
          <itemizedlist>
            <listitem>
                <para>lexikális elemzés</para>
            </listitem>
            <listitem>
                <para>szintaktikai elemzés</para>
            </listitem>
            <listitem>
                <para>szemantikai elemzés</para>
            </listitem>
            <listitem>
                <para>kódgenerálás</para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          A könyv kiemeli, hogy lehet szó előfordítókról. 
          Most egy tanulságos történet: Java spring-based web server. 
          Hibernate előtti időszak, szóval perzisztenciát from scratch. 
          Amerikaiak úgy döntöttek, hogy egy perzisztens class-t annotációkkal fognak "dekorálni" (ez akkor még nagy szó volt, mert ez még az xml config-os spring era), 
          és technikai okokból, ha ez megtörtént, az annotációkban megjelölt információk alapján a SUPER class auto generálni fogjuk. 
          Igen <literal>Derived extends Base</literal> és Base még nem volt kész, hanem Derived alapján jött létre "automatán" a Derived annotált source kód alapján.
          Például olyan célt szolgált, hogy a null check-ek validálások, propertyeventchanged küldések stb. ne kézzel íródjanak.
          <link xlink:href="https://www.ptc.com/en/products/plm/plm-products/windchill">Ő az</link>. Az már egy másik cseresznye a tortán, hogy nem a hétköznapi módon csináltak Product táblát, Employee táblát stb., 
          hanem például TypeIdentifier, AttributeTypeIdentifier és hasonló táblák voltak, azaz runtime lehetett új "típusokat" létrehozni, úgy hogy ezek nem csak a field-eket örökölték, hanem viselkedést is (igen a munka nagyrésze az application layerben ment).
          </para>
          <para>A könyv kitér rá, és tényleg nagyon fontos a linker. Egyébként így elsőre prog 1-ből az lesz az előnye, hogy nem kell mindig az egészet újra fordítani. Persze ha nem kell mindig újra fordítani. Persze a compile-olgatásnak és linkelgetésnek is meg van a maga ára. Például ha ritkán változó dologról van szó, akkor lehet precompiled header-ekkel dolgozni.</para>
          <para>Na jó...de mi ez az egész linkelés? Pl. C++ esetén a compilation unit Foo, illetve van egy FooMain-ünk ahol használjuk. Külön külön fordítjuk, és ha minden rendben akkor végül együtt kell működniük majd, tehát linkelésnél valamilyen módon a FooMain beli használathoz társítani kell a Foo beli implementációt. A szerződés az együttműködésre Foo.hpp.</para>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/Foo.hpp"/></textobject>
          </programlisting>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/Foo.cpp"/></textobject>
          </programlisting>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/FooMain.cpp"/></textobject>
          </programlisting>
          <figure>
              <title>Foo és Foo Main</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/foocompile.png" scale="100"/>
                  </imageobject>
                  <textobject>
                      <phrase>Foo és Foo Main</phrase>
                  </textobject>
              </mediaobject>
          </figure>
          <para>
          Na jó... de mi történik, ha megváltozik az a field? Mi van ha kifele int-et mutatok, de valójában másképp akarom tárolni?
          </para>
          <para>
          Amíg a hpp változatlan addig azt csinálok implementációban amit akarok!
          </para>
          <para>
          De...szóval mi van ha esetleg az a implementációjához akarok hozzányúlni. Bad luck! Hpp-t módosítani kell és akkor már nem tudnak ellened linke...VÁRJUNK CSAK!
          </para>
          <para>
          Egy kis trükközéssel encapsulating kivitelezhető ezen kívánságra is, csak kompozíciót kell alkalmazni és egy struct-ba wrappelni amit rejteni kívánunk.
          </para>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/FooABI.hpp"/></textobject>
          </programlisting>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/FooABI.cpp"/></textobject>
          </programlisting>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/FooABIMain.cpp"/></textobject>
          </programlisting>
          <figure>
              <title>FooABI és FooABI Main</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/fooabicompile.png" scale="100"/>
                  </imageobject>
                  <textobject>
                      <phrase>FooABI és FooABI Main</phrase>
                  </textobject>
              </mediaobject>
          </figure> 
          <para>A nevekben felfedezhető ABI az <literal>Application Binary Interface</literal> szóra utal. Erről most nem írok részletesen, de mint ahogy az <literal>Application Programming Interface</literal> azaz API jó ha konzisztens tud maradni például egy library különböző verziói között, addig a gép számára hasonlóan jó dolog ha az ABI nem változik.</para>
          <para>A tankönyvet régen írták, de igen, továbbra is nagyon fontos hogy ki hogyan és mihez kapcsolódik, viszont mivel telt múlt azóta az idő, vannak új trükkök!</para>
          <para>A betöltés egy nagyon fontos dolog. Miért is? A gépekben az adat, az eljárás és a macskás képek nem különülnek el. Minden adat. Vicces túlzással élve a számítógép valójában egy ipari lyukasztó gép amit, nos lényegében lyukasztott kártyákkal programozunk, innentől kezdve ő kilyukasztja az utasítás kártyát ha kell, és ha kell lefuttatja a kilyukasztott végterméket egyaránt ha beadjuk neki. Számára lyuk-lyuk egyre megy.</para>
          <para>Betöltés</para>
          <para>C++, C, Java oldalról nehéz megérteni a betöltést. Nézzük assemblyvel egy egyszerű példán:</para>
<literallayout>
   @0
   D=M
   @INFINITE_LOOP
   D;JLE 
   @counter
   M=D
   @SCREEN
   D=A
   @address
   M=D
(LOOP)
   @address
   A=M
   M=-1
   @address
   D=M
   @32
   D=D+A
   @address
   M=D
   @counter
   MD=M-1
   @LOOP
   D;JGT
(INFINITE_LOOP)
   @INFINITE_LOOP
   0;JMP
</literallayout>
    <para>A lényeg, hogy van egy LOOP label-em. Ez egy hely a kódban ahova ugorhatok. Hogy ugrom oda? Long story short <literal>@LOOP</literal>-al betárolom LOOP helyét majd   <literal>JGT</literal>-vel ugrom.</para>
    <para>Ok. Pszeudokódban megy, de...Mennyi is a LOOP label címe? Mármint konkrétan nekem kellene, hogy az most akkor 0111 0111 0111 1111? Honnan tudom?</para>
    <para>Naív válasz: Oké, 0 memória címre lesz betöltve a programom, szóval simán kiszámolom hogy az @address(hisz oda fogok ugrani, mert a LOOP az csak egy sajtos papír "tag", tag alatt az angol tag-et értem)</para>
    <para>Ez egy tökéletes megoldás lehet Nintendo-n, vagy nem tudom... valami ROM-on!</para>
    <para>De akkor mi van, ha én nem oda kerülök, hanem mondjuk már előttem vannak dolgok, mondjuk egy macskáskép sokszorosító?</para>
    <para>Egyszerű megoldás: Akkor derüljön ki LOOP értéke, mikor én elhelyezésre kerülök! Zseniális!</para>
    <para>Viszont...nos, innentől kezdve én elmozdíthatatlan vagyok! Pontosabban elmozdíthatnak, de mivel a LOOP egy konkrét érték, ezért ha arébb raknak, akkor rossz területre fog hivatkozni.</para>
    <para>És akkor például itt jöhetnek trükkös megoldások a cím újra számításra, vagy esetleg arra, hogy én ne direktbe hivatkozzak egyenesen a fizikai címre, hanem magamhoz képest relatív.</para>
    <para>Java esetben ez másképp van hiszen egy stack machine-be pakolunk dolgokat, ami az Oracle szerint write once run...</para>
    <para>Persze a VM egyébként egy <link xlink:href="https://youtu.be/JvBT4XBdoUE?t=1126">nagyon jó dolog</link>. Vagy például az eve online <link xlink:href="https://www.eveonline.com/">Stackless Python</link>-t használ ami egyébként ugyanúgy a unmutabilityt választotta, hasonlóan az Erlang-hoz</para>         
    <para>Interpreternél ugye nincs szükség ekkora hercehurcára, kivéve ha van szükség. Mármint például egyes interpretált nyelveknél direkt egy előfordított formába rkhatjuk a szkriptet és akkor kicsit gyorsítani tudunk a dolgokon.</para>
    <para>Interpreteres esetekben persze mindig ott a lehetőség, hogy a CPU intenzív dolgokat natívba rakjuk. Pl. a <link xlink:href="https://www.klei.com/games/dont-starve">dont starve</link> esetén Lua intézi az üzleti logikát, ami az állatok párzási időszakban erősödő agressziójáért felelős, de a grafika, fizika, collision C/C++ oldalon van tartva. Azért nem mondok tiszta Cpp-t, mert Lua raw c ptr-eket fogad, illetve C-s callbackek szolgálnak hook-ként a lifecycle eventekre (magyarul ha a Lua gc elakar takarítani valamit, és az egy küldő kódból származó raw ptr, akkor egy user defined c callback-et hív ezen ptr-el. Mi például itt tudjuk az átküldött címre hívni a destruktort explicit, utána visszakerül lua-nak az irányítás. Azért nincs free vagy delete, mert az is customizeable, azaz lehet például, hogy mi írunk alá memory managementet, mert folyamatosan az OS-től kérni apró chunkokat elég lassú.).</para>
    <para>Ezzel az egész résszel az volt a célom, hogy kifejezzem, hogy a könyv nagyon jó, de már régóta eltűntek azok az éles határok, illetve mivel nem láttam pontos definíciót ezért nehéz egyáltalán megtámadni is.</para>
    <para>Természetesen a lexikális elemzés során megtörténik a forrás szöveg lexikális egységekre történő bontása. Ez ma is így van.</para>
    <para>Egyébként viszont az is egy érdekes kérdés, hogy a Cpp type system az imperatív nyelvbe hogy kerül bele. Mármint arra a vicces dologra akarom felhívni a figyelmet, hogy mondjuk én egy extends-el egy abszolút nem imperatív dolgot csinálok, a type inference pedig...nos ennél kevésbé imperatív dolog nincs. Persze, igen, C-style cast.</para>
    <para>Most bele lehetne menni szárazon a BNF-be, de ennél aranyosabb a Q={"l","3","t",a++b | a,b eleme Q} Szóval <link xlink:href="https://youtu.be/dFexYse8UF0?t=234">l33t</link>, de Várterész Tanárnő egyébként szó szerint ilyen "elemzést végzett", amikor felírta az ábécét és a szabályokat.</para>
    <para>A szintaktikai szabályok kicsit hajlékonyak, például ha Tanárnő hiányzik, akkor emlékezzünk arra, hogy a <literal>-Wpedantic</literal>(pl: field initialization sorrend csak a deklarációs sorrendben megengedett) </para>
    <para>Imperatív nyelveknél a programozó mondja meg hogy hogyan, ezért tele van bugokkal. Mellette szól viszont, hogy <link xlink:href="http://judy.sourceforge.net/">gyorsabb kódot lehet így írni az elméletileg lehetségesnél</link> </para>
    <para>Deklaratív nyelveknék a programozó nem mondja meg hogyan. Emiatt nincs hiba. Technikailag. De természetesen abszolút nem az fog történi amire az ember gondol és sok szerencsét a Prolog debuggolással.</para>
    <para>Imperatív nyelvekhez még talán annyit, hogy...nos az OOP nagyon jó dolog. Bizonyos feladatokra. Folyamatos vessző paripám az <link xlink:href="https://github.com/alecthomas/entityx">ECS</link>. Nem ez nem egy nyelv, hanem egy megközelítési forma. Az egész arról szól hogy passzív adatstruktúráim vannak és a viselkedést megvalósító részeket megpróbálom (bár általában nehéz) állapot mentesíteni. Szerintem az OOP az emberi intuíciót és a problémákról történő gondolkodást elősegíti, de semmilyen bizonyíték nincs arra, hogy karbantartható codebase-hez vezet. (Például a <link xlink:href="http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/">Tony Hawk</link>) Vannak olyan nyelvek melyek az interface-t (vagy teljesen absztrakt class-t) preferálják, és kigyomlálták a hétköznapi java-ban burjánzó inheritance fákat, erdőket.</para>      
    <para>A forrás fájlunkban emberileg értelmezhető szöveget írunk karakterek felhasználásával. A nyelv amin írjuk egy megfelelő abécéből (Logika emlékszünk?) és ezek alkalmazási szabályaiból áll</para>
        <para>
        Lexikális egységek a következőek
          <itemizedlist>
            <listitem>
                <para>többkarakteres szimbólum</para>
                <para>Pl.: ++, --, azaz ahelyett hogy valami furcsa új szimbólumot használnánk technikailag több szimbólum együttese alkot együtt egy szimbólumot. Például gondoljunk arra, hogy egyszerű abécé betűkkel mondjuk csinálunk egy olyan nyelvet amibe kéne egzisztenciális kvantor, és azt találnánk ki, hogy az <literal>ee</literal> jelentse azt.</para>
            </listitem>
            <listitem>
                <para>szimbolikus név</para>
                <para>Azonosító, adott nyelv szintaktikai szabályai szerint olykor például kötelezően betűvel kezdődő karakter sorozat. A lényeg hogy ezt használjuk a dolgot elnevezésére. Azaz például egy változóra hog hivatkozzunk az azonosítóját írosgatjuk be a forrásszövege.</para>
                <para>Kulcs szó, a nyelv által védett, különös jelentősséggel bíró név. Például a <literal>for</literal> mely érezhetően ahhoz kell, hogy jelezzük, hogy ami utána jön abból valami loop jellegű dolog legyen. Turing fejezetben konkrétan a nyelvi spec-cel is foglalkoztunk optional-östől mindenesetül, ezért erre most nem térek ki.</para>
                <para>Standard azonosító, melynek a nyelv tulajdonít jelentést. Pl.: Null</para>
            </listitem>
            <listitem>
                <para>címke</para>
                <para>Ugráláshoz kell, hogy hova ugorjunk! Hogy mondjuk meg hova kéne ugorni, mindezt menedzselhetően? Adjunk egy címkét annak a sornak ahova ugorni akarunk! Fentebbi assembly kódban a loop-olás miatt láttunk labelt.</para>
            </listitem>
            <listitem>
                <para>megjegyzés</para>
            </listitem>
            <listitem>
                <para>literál</para>
                <para>Nyelv által megengedett szabályok szerinti karakterlánc mellyel konkrét értéket tudunk bevinni. Egzotikus példa a cpp14 szabványos bit megadásos 0b01101010.</para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Sorok fontossága szerint
          <itemizedlist>
            <listitem>
                <para>Kötött formátumú nyelvek</para>
                <para>Egy sor, egy utasítás. Legjobb példa az előbb már említett assembly (kis trükkel, hisz a label maga ugyan egy sor ott, de úgy írtam meg a parsert, hogy azt kikapja véglegesből hisz az csak meta adat :)</para>
            </listitem>
            <listitem>
                <para>Szabad formátumú nyelvek</para>
                <para>Ok, ha az új sor nem a vége a dolognak, akkor viszont meg kell valahol állni, ugye?! Nos ezt vagy explicit jelezzük pl. C, vagy khm... js!.</para>
            </listitem>
            
          </itemizedlist>
        </para>
    </section>
     <!-- SUBSECTION -->
    <section>
      <title>Adattípusok</title>
      <para>         
          (28) tartomány, műveletek, reprezentáció, egyszerű, összetett, mutató  
      </para>       
    <para>
      Típusok, röviden felfoghatóak: lehetséges értékek halmaza + halmaz elemeken értelmezhető műveletek + reprezentáció együttese ként.
          <itemizedlist>
            <listitem>
                <para>numerikus - pl.: (C)int, (C)float</para>
            </listitem>
            <listitem>
                <para>karakteres - pl.: (C)char</para>
            </listitem>
            <listitem>
                <para>karakterlánc - pl.: ezt általában nem igazi primitív, hanem a nyelv mellé adott alap library része, például Erlang-ban egyébként egy lista</para>
            </listitem>
            <listitem>
                <para>logikai - pl.: (C) bool</para>
            </listitem>
            <listitem>
                <para>felsorolásos - pl.: (C) enum</para>
            </listitem>
            <listitem>
                <para>sorszámozott - pl.: (Pascal) byte, word, int, ...</para>
            </listitem>
          </itemizedlist>
        </para>
        <para>         
          A nyelv által definiált egyszerű típusokból van lehetőség új strukturált típusok összerakására ezek az összetett típusok.
        </para>
        <para>         
          A típusnak pedig végül kell hogy legyen valami azonosítója, hogy tudjunk rá a későbbiekben hivatkozni.
        </para>
        <para>       
          A mutató típusról kicsit külön érdemes beszélni. A mutató egy tárbeli címre mutat vagy <link xlink:href="https://www.youtube.com/watch?v=YYkOWzrO3xg">NULL</link>-ra.
          Érdemes tudni, hogy a mutatott cím egyáltal milyen típus. Azaz a <literal>char* foo</literal> ptr típusú, viszont amire mutat azt char-ként fogja "interpretálni". Persze egy int-et tároló mem területre rámehetünk egy char ptr-rel gond nélkül.
        </para>
        </section>
         <!-- SUBSECTION -->
        <section>
          <title>A nevesített konstans</title>
          <para>         
              (34) név, típus, érték
          </para>
          <para>         
              Szerintem a könyvbeli preprocesszor-os példa technikailag nem igaz. Az hogy a preproceszor mit csinál már a Turing-os fejezetben bemutattam, plusz mutattam olyat is amikor makró alkalmaz makrót ami kódot injektál. Na egy ilyen esetben látszik hogy a preprocesszor csak egy "szövegszerkesztő" eszköz, nem a nyelv része, plusz úgy ütöm felül a a define-okat ahogy akarom.
          </para>
          <para>         
              Ellenben a <literal>const int = 6;</literal> egy konstans. típus, const qualifier, és értékadás, just like God intended.
              Ha már itt tartunk akkor itt a világ legmegbízhatóbb Java kódja, ami viszont olykor mégis hibát okozhat (assuming that it wont get optimized away): <literal>private static void foo(){};</literal>. He. He.
          </para>
        </section>
        <!-- SUBSECTION -->
        <section>
          <title>A változó</title>
          <para>         
              (35) név, attribútumok, cím, érték
          </para>
          <para>         
              A változóknak négy komponense van:
              <itemizedlist>
            <listitem>
                <para>név - pl.: user defined, scope-on belül egyedi</para>
            </listitem>
            <listitem>
                <para>attribútumok - pl.: típus, vagy qualifiers</para>
            </listitem>
            <listitem>
                <para>cím - stack, heap vagy manual</para>
            </listitem>
            <listitem>
                <para>érték - értékadás, itt annyit érdemes megjegyezni, hogy attól hogy létrehozom és kap címet, azt nem lehet várni hogy a tár tiszta legyen, úgyhogy érdemes lehet initelni.</para>
            </listitem>
            <listitem>
                <para>felsorolásos - pl.: (C) enum</para>
            </listitem>
            <listitem>
                <para>sorszámozott - pl.: (Pascal) byte, word, int, ...</para>
            </listitem>
          </itemizedlist>
          </para>
        </section>
         <!-- SUBSECTION -->
        <section>
          <title>Alapelemek az egyes nyelvekben</title>
      
          <para>(39) innen csak a C nyelves rész persze</para>
          <para>
            Aritmetikai típusok
            <itemizedlist>
              <listitem>
                  <para>integrális - egész (int, short[int], long[int]) : signed unsigned-ról már turingban írtam példával együtt </para>
              </listitem>
              <listitem>
                  <para>integrális - karakter (char)</para>
              </listitem>
              <listitem>
                  <para>integrális - felsorolásos (enum)</para>
              </listitem>
              <listitem>
                  <para>valós - (float, double, long double) </para>
              </listitem>
            </itemizedlist>
          </para>
          
          <para>
            Származtatott típusok
            <itemizedlist>
              <listitem>
                  <para>tömb</para>
                  <para>Memóriában garantáltan egymás mellé kerülő hasonló típusú értékek. Azért ilyen furcsán írtam le mert ez a lényeg.
                  Miért ez a lényeg? Nos, ha array-be tárolok valami akkor a cache miatt array-t nagyon gyorsan tudok "végig iterálni". Ez BORZASZTÓAN jól tud jönni.
                  Persze sajnos hátulütője, hogy előre tudni kell a hosszt amennyit foglalni akarunk...
                  </para>
              </listitem>
              <listitem>
                  <para>függvény </para>
              </listitem>
              <listitem>
                  <para>mutató </para>
                  <para>Architektúrától függő. Hossza pl. 64 bit, 32 bit. Ez egy sima egyszerű szám. 
                  Csak azáltal lesz különleges hogy általában a számot RAM hozzáférésre használjuk, de tényleg csak egy szám (főként void ptr esetén, hisz ott már nem cipel maga mellé meta adatként a mutatott adat típusát illető komoly információt).
                  Egyébként cpp-ben szoktuk nyers ptr-nek is nevezni, mert ma már csak akkor használjuk ha nagyon fontos.</para>
              </listitem>
              <listitem>
                  <para>struktúra </para>
                  <para>A user a meglévő típusokból (akár újonnan létrehozott structokból) rakhat össze újakat. Az ABI esetén említett struct-os kód példa bemutatja hogyan lehet abuzálni.</para>
              </listitem>
              <listitem>
                  <para>union </para>
                  <para>Ahelyett hogy beszélgetünk róla itt van valami production code-ból(random CAD program). Embrace the C!</para>
                  <programlisting language="c" linenumbering="numbered">
                    <textobject><textdata fileref="Gutenberg/union.c"/></textobject>
                  </programlisting>
              </listitem>
              <listitem>
                  <para>void </para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
       <section>
          <title>Kifejezések</title>
          <para>Kifejezésekkel a program egy adott pontján ismert értékekből újakat határozunk meg. 
                <literal>Értékük</literal> és <literal>típusok</literal> van.
          </para>
          <para>
            Formálisan operátorból, operandusokból és csoportosító jelekből állnak (pl. zárójel).
          </para>
          <para>
            Attól függgően hány operanduson történik, beszélhetünk unáry, binary, ternary stb. kifejezésekről. (Hehe funkcionális nyelveknél currying...)
          </para>
          <para>
            
          </para>
          <para>
            A kifejezések több fajta alakban leírhatóak. Suliban az egyiket szoktuk meg, a gépek meg egy másikat. :)
            <itemizedlist>
              <listitem>
                  <para>prefix</para>
                  <para>
                    (* 3 5 )
                  </para>
              </listitem>
              <listitem>
                  <para>infix</para>
                  <para>
                    ( 3 * 5 )
                  </para>
              </listitem>
              <listitem>
                  <para>postfix</para>
                  <para>( 3 5 * )</para>
              </listitem>
            </itemizedlist>
          </para>
          <para>
            Amikor a kifejezés értéke meghatározódik, azt kiértékelésnek is lehet nevezni, de Turing-ban adtam példát lambda kalkulusban normál formára hozásra. (Hisz a kiértékelés az, hogy normálformára hozzuk, ami lambdában nem mindig jelenti azt hogy pl. egy "számot" kapunk, lehet egy lambda absztrakció lesz a vége.)
          </para>
          <para>
            A műveletek végrehajtási sorrendje a következő lehet
            <itemizedlist>
              <listitem>
                  <para>felírási sorrend - balról jobbra</para>
              </listitem>
              <listitem>
                  <para>anti felírási sorrend - jobbról balra</para>
              </listitem>
              <listitem>
                  <para>precedencia alapján</para>
                  <para>Igen van olyan nyelv ahol magát a precedenciát is meg lehet adni...sőt ha két argunk van akkor infixben is lehet használni... De ez persze nem a C :)</para>
                  <para>Ha infixnél nem vagyunk biztosak abban hogy mi is lesz a sorrend, zárójelezzünk...</para>
              </listitem>
            </itemizedlist>
          </para>
          <para>
            Ahhoz hogy ki lehessen értékelni egy operátor alkalmazását operandusokon érdemes tudni az operandusokat. A C erről nem köt meg semmit szabványban.
          </para>
          <para>
            Ahol logikai kifejezések szerepelnek, ott rövidzárral nem feltétlenül fut le az egész, hisz az eredmény tudható anélkül is.
            Például egy vicces nyelv független példa:
          </para>
<literallayout>
TömbNemÜres ÉS TömbNulladikElemeÖt 
HAMIS ÉS ? = HAMIS 
</literallayout>
          <para>
            Fontos hogy a két operanduson lehet-e alkalmazni az operátort. Ahhoz hogy ezt eldöntsük kell a típus.
          </para>
          <para>
           Két programozási eszköz típusa azonos ha (...valóságban megint nem ennyire egyszerű de hadd menjen)
            <itemizedlist>
              <listitem>
                  <para>deklaráció egyenértékőség</para>
                  <para>egyszerre ugyanazzal a típussal deklarálódtak</para>
              </listitem>
              <listitem>
                  <para>név egyenértékőség</para>
                  <para>ugyanaz a típus név</para>
              </listitem>
              <listitem>
                  <para>struktúra egyenértékőség</para>
                  <para>összetett típusúak és szerkezetük megegyezik</para>
              </listitem>
            </itemizedlist>
          </para>
          <para>típuskényszerítéses nyelvnél ha különböző típusúak az operandusok, akkor type conversion lesz.
          Ilyen esetben a nyelv leszögezi hogy milyen konverziók történnek és hogyan.</para>
          <para>
            típus egyenértékűségnél megtörténhet de... most ugorjunk el a könyvtől. A lényeg a következő:
            Ezeket a nyelveket régen találták ki, de a következőről van szó: Van mondjuk A típus és B típus, ezek mind egy meta C típusba tartoznak és a művelet definiálva van a C-n, szóval B-n és A-n is menni fog (nem sima inheritance-re gondolok C superrel, inkább olyan jellegű mint pl. a Bácsó Tanár Úr által említett Abel csoport).
            Amiatt van ez a kernel panic a fogalom tárban mert amikor ezek a nyelvek születtek akkor nagyon gyorsan jöttek ki az új architektúrák int, aztán long int is kellett stb.
            Szóval inkább arra koncentráltak hogy polcra kerüljön a termék.
          </para>
          <para>
            Felfele cast-olni gond nélkül lehet(int-&gt;float), de lefele castolni(float-&gt;int) nem egyértelmű. Mármint nem csak annyi a kérdés, hogy befogok-e férni, hanem például ha A teljesen C "típusú" lenne akkor A "részhalmaza" lenne C-nek C pedig "A"-nak ez pedig nagyon nincs így.
            A tény hogy ez nincs normálisan formalizálva, nem customizeable csak builtin az arra enged következtetni, hogy még mindig van hova fejlődni.
          </para>
          <para>
            Konstans kifejezés (cpp-ben constexpr) compile time dől el. Ebből következik, hogy konstansokat vagy beégetett literálokat lehet benne használni csak.
          </para>
          <para>
            A könyv most ad egy rövid leírást a lehetséges operátorokról és precedencia táblázatról. Én ebbe most nem megyek bele inkább itt egy példa egy másik nyelvből hogy lehet megadni a fent említett dolgokat:
          </para>

<literallayout>
infixr precedence nm1 nm2 ...
</literallayout>
        <para>
           Annyit jelent hogy infix esetben right associative, utána egy szám amivel megadjuk a precedencia számát után pedig.
           Long story short, alább egy left associative infix dolog amire a "+" szimbólummal lehet hivatkozni. Huzzah!
          </para>
<literallayout>
infixl 5 _+_
</literallayout> 
        </section> 
    </section>
    
    
    
    
    <section>
      <title>Programozás bevezetés</title>
      <para>                
          <citation>KERNIGHANRITCHIE</citation> (2nd edition)
      </para>
      <para>
        Előző alfejezetben a <citation>JUHASZ</citation> könyv kapcsán már lementünk assemblyig és vissza, szóval itt nem fogunk újra arról beszélni hogy mi az a bool, csak az új dolgok.
      </para>
      <section>
          <title>Functions</title>
         
         <para>
            C funkciók
          </para>   
    
<literallayout>
return_type fn_name (void | formal_param_list)
{
  decls
  statements
}
</literallayout>
          <para>
            C-ben láthatóan statement után nem lehet decl. Ez például cpp-bennem így van, hisz pl a for scope-ban lokálisan deklarálhatunk i-t.
          </para>
          <para>
            Másik dolog a forward decl. Ha valahol használunk egy funkciót, akkor előtte a deklarációját már említeni kell.
          </para>
<literallayout>
int main ()
{
  int bar;
  bar = foo();
  return 0;
}

int foo(void) {return 0;}
</literallayout>
        <para>Ez nem jó, hisz bar=foo() esetén összeköti a szemöldökét a compiler, hiszen nincs deklarálva foo (jó esetben :).</para>
<literallayout>
int foo(void);

int main ()
{
  int bar;
  bar = foo();
  return 0;
}

int foo(void) {return 0;}
</literallayout>

        <para>Azaz előre deklaráltuk forward decl...</para>
       </section>

        <section>
          <title>Pass by value</title>
          <para>C-ben function call-ok esetén tisztán értékeket adunk át. Felmerül a probléma, ok, de az lzw binfámat C free functionökkel akkor hogyan tudom változtatni. Emlékszünk még a raw ptr-ekre?
            Nos mivel az csak egy egyszerű memória cím, ezért szépen átpasszoljuk a mem címet. Totál mindegy hogy a cím másolódik, hisz csak egy 64 bites minta. Ezekután ha megkaptuk akkor a funkcióban már csinálhatjuk a mellékhatást kedvünk szerint!
          </para>
        </section>
        <section>
          <title>Extern</title>
          <para>Fenti példában <literal>bar</literal> csak <literal>main scope-jában, vagy ez alatti scope-ban látható (pl. valami loop-ban hivatkozhatunk bar-ra)</literal></para>
          <para>Másik lényeges dolog, hogy bar addig él amíg main él.</para>
          <para>Ez... nos ezen probléma feloldására van az extern.</para>
          <para>Extern, tehát externális az összes funkcióhoz képest, minden funkción kívüli stb. Ne ijedjünk meg semmi bonyolult</para>
<literallayout>
int counter;

void foo(void);

int main ()
{
  extern int counter;
  int bar;
  counter = 0;
  foo();
  foo();
  bar = counter;
  return 0;
}

void foo(void)
{
extern int counter;
counter = counter + 1;
return;
}
</literallayout>
        </section>
       
       
      <section>
          <title>Escaping</title>
          <para>
            A <citation>JUHASZ</citation>-ban már beszéltünk változókról, viszont string literal-oknál az escape kimaradt.
            Annyiról van szó, hogy egyes speciális karaktereket nem lehet csakúgy beírni, hisz különleges jelentéssel bírnak azon kontextusban.
            Egyszerű példa &gt; xml-ben :). String literalba ugye hogyan írunk idézőjelet? Előtte esscape-elni kell.
          </para>
        </section>
        <section>
          <title>Char vs char array</title>
          <para>
            A C-ben külön char és charray literal van. Egyik ' a másik "-t használ. Nagyon nem ugyanaz ezáltal 'a', és "a".
          </para>
        </section>
       
        <section>
          <title>Decl</title>
          <para>
            Deklarációknál ha hasonló típusú változókról van szó egy sorban is deklarálhatjuk őket. Inicializálni = jellel tudunk.
          </para>
<literallayout>
int a,b,c;
a = b = c = 5;
</literallayout>
        </section>
        
        
        <section>
          <title>Cast</title>
          <para>
            Explicit tudunk castolni. Például osztást akarunk végezni két nem nulla term. számon. és lebegőpontosat akarunk visszakapni. Ekkor érdemes (lehet) az operandusokat explicit castolni float-ba.
            Érdekesebb példa c library-kben gyakran a callbackek void ptr-t fogadnak be hogy a felhasználó testreszabhassa:
          </para>
<literallayout>
int MyCallback(void* userData)
{
  int* le_a = (int*) userData;
}

int main()
{
  int a = 0;
  do_library(MyCallback,&amp;a);
}
</literallayout>
        </section>
        
        
        <section>
          <title>Ternary</title>
          <para>
            Ha Kondícionális expression igaz akkor :-tól balra, különben jobbra. a= (b&gt;c) ? b : c;
          </para>  
        </section>
    </section> 

    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
    </section>        
</chapter>     
            
</part>                                                              

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Második felvonás</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>A BPP algoritmus Java megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        

    <section>
        <title>Java osztályok a Pi-ben</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     
    
    
            
</part>                                                              


    <bibliography xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Irodalomjegyzék</title>
    <bibliodiv>
        <title>Általános</title>
        <biblioentry xml:lang="hu">
            <abbrev>MARX</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>György</firstname>
                        <surname>Marx</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Gyorsuló idő</title>
            <publisher>
                <publishername>
                    Typotex
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>
        <biblioentry xml:lang="hu">
            <abbrev>JUHASZ</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>István</firstname>
                        <surname>Juhász</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Magas sznitű programozási nyelvek</title>
            <publisher>
                <publishername>
                    mobiDiák
                </publishername>
            </publisher>
            <pubdate>2008</pubdate>
        </biblioentry>        
    </bibliodiv> 
    <bibliodiv>
        <title>C</title>
        <biblioentry>
            <abbrev>KERNIGHANRITCHIE</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Brian W.</firstname>
                        <surname>Kernighan</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dennis M.</firstname>
                        <surname>Ritchie</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A C programozási nyelv</title>
            <publisher>
                <publishername>Bp., Műszaki</publishername>
            </publisher>
            <pubdate>1993</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>C++</title>
        <biblioentry>
            <abbrev>BMECPP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Zoltán</firstname>
                        <surname>Benedek</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Tihamér</firstname>
                        <surname>Levendovszky</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Szoftverfejlesztés C++ nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2013</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Lisp</title>
        <biblioentry>
            <abbrev>METAMATH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Gregory</firstname>
                        <surname>Chaitin</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>META MATH! The Quest for Omega</title>
            <publisher>
                <publishername>
                    <link xlink:href="http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf">http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf</link>
                </publishername>
            </publisher>
            <pubdate>2004</pubdate>
        </biblioentry> 
        <biblioentry>
            <abbrev>SICP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Harold</firstname>
                        <surname>Abelson</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Structure and Interpretation of Computer Programs</title>
            <publisher>
                <publishername>
                    <link xlink:href="https://web.mit.edu/alexmv/6.037/sicp.pdf">MIT</link>
                </publishername>
            </publisher>
            <pubdate>1996</pubdate>
        </biblioentry> 
    </bibliodiv>   
    <bibliodiv>
        <title>My Little Ponys</title>
        <biblioentry>
            <abbrev>DENOTATIONALSEMANTICS</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Lloyd</firstname>
                        <surname>Allison</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A practical introduction to denotational semantics</title>
            <publisher>
                <publishername>
                    <link xlink:href="https://www.cambridge.org/core/books/practical-introduction-to-denotational-semantics/80122D52B49F175D38E0478EA45D4EDD">Cambridge University Press</link>
                </publishername>
            </publisher>
            <pubdate>1986</pubdate>
        </biblioentry>
        <biblioentry>
            <abbrev>PROGLANGS</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Robert</firstname>
                        <surname>Harper</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Practical Foundations for Programming Language</title>
            <publisher>
                <publishername>
                    <link xlink:href="https://www.cambridge.org/core/books/practical-introduction-to-denotational-semantics/80122D52B49F175D38E0478EA45D4EDD">Carnegie Mellon University</link>
                </publishername>
            </publisher>
            <pubdate>2016</pubdate>
        </biblioentry>
        <biblioentry>
            <abbrev>NANDTOTETRIS</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Noam</firstname>
                        <surname>Nisan</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>The Elements of Computing Systems</title>
            <publisher>
                <publishername>
                    <link xlink:href="https://www.nand2tetris.org/">Homepage of the book</link>
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>
        <biblioentry>
            <abbrev>CHISOMORPH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Morten Heine B</firstname>
                        <surname>Sorensen</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Lectures on the Curry-Howard Isomorphism</title>
            <publisher>
                <publishername>
                    <link xlink:href="https://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf">Pdf</link>
                </publishername>
            </publisher>
            <pubdate>1998</pubdate>
        </biblioentry>
    </bibliodiv>   

    
</bibliography>     
          
            <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>                 
</acknowledgements>     

</book>
