<chapter xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Reverse engineering - UML class diagram</title>
        <section>
            <title>Feladat</title>
            <para>
            UML osztálydiagram rajzolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
kapcsolatára a forráskódban és a diagramon, lásd még: <link xlink:href="https://youtu.be/Td_nlERlEOs">youtube felvétel egy régi előadásról</link> .
Lásd fóliák!
            </para>
        </section>
        <section>
            <title>Asszociáció, Aggregáció, Kompozíció</title>
            <para>
                Próbáltam általánosságban informálisan felírni.
                A probléma az hogy doméntől függően (SQL,Java,C++ stb.) más és más módon használják őket.
            </para>
            <para>
                Amit kiakartam fejezni az szerintem érthető lesz annak ellenére, hogy nem vagyok matematikus.
            </para>
            <para>
                Amire a feladat utalni akar az a kompozíció és aggregáció közötti különbség.
                Mind a kettő egy viszonyt fejez ki.
                Csináltam egy példát, előre is elnézést kérek a honfoglalós dologért, nem poénkodni akartam, hanem szükségem volt egy olyan doménre, ahol egy entitás elpusztulása egy másik entitás elpusztulását kell hogy kiváltsa, de átruházható ownership-el(mert ugye honfoglaló őseink a lovaikat maguk mellé temették, de egy lovukat el is ajándékozhatták).
            </para>
            <figure>
                <title>Honfoglaló UML</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="l03/uml/agg-comp.png" scale="50" />
                    </imageobject>
                    <textobject>
                        <phrase>Honfoglaló UML</phrase>
                    </textobject>
                </mediaobject>
            </figure>
            <para>
                Tiszta asszociáció-ra azért példa a "dad", mert "dad"-re semmilyen kontrollt nem gyakorol egy Person példány, csak tud a létezéséről.
            </para>
            <para>
                Aggregáció-ra azért példa a "horse", mert "horse"-ot el kell pusztítania valakinek, de az elpusztítás felelőssége (hisz ez az ownership valós lényege) átruházható.
            </para>
            <para>
                Kompozíció-ra azért példa a "body", mert a "body" nem átruházható és a birtokos pusztulása magával vonja a "body" pusztulását.
            </para>
            <para>
                Jelen példában nem foglalkozunk azzal, hogy ha A R B relációról van szó és (a,b) a reláció része(a eleme A, b eleme B) - azaz a látja b-t - akkor b látja-e a-t.
                Ezzel majd úgyis fogunk eleget szenvedni Hibernate esetén :)
            </para>
            <para>
                Sajnos Java-ban a VM miatt ezt nem lehet teljesen egyértelműen átültetni gyakorlatba.
                A probléma az, hogy minden field-ünk vagy egy primitív típus, vagy egy objektum referencia.
            </para>
            <para>
                Az elpusztítás felelőssége minden körülmények között a VM felelőssége, aminek konkrét megvalósítását ő Garbage Collectorok által végzi el.
            </para>
            <para>
                C++ esetén azonban konkrét kontrollunk van!
                Nézzünk egy példát kompozícióra:
            </para>
            <literallayout>
class Horse{
public:

};

class HungarianPerson{
public:

    Horse h;
};
            </literallayout>
            <para>
                Ugye látható a fenti ábrából, hogy egy HungarianPerson objektum konkrét bit mintájában lesz egy rész ami a Horse bitmintáját fogja leírni.
                Ezt értsd úgy, hogy ha rámegyek a memória területre ahol a HungarianPerson példány kezdődik és byte-onként sizeof HungarianPerson-ig olvasom (ugyanis lehet packed és akkor nem törődik a szóhatárral) akkor ott lesz benne valahol a Horse instance összes értéke (jelen esetben azért nem lesz benne, mert egyik osztálynak sincsenek adattároló tagjai).
            </para>
            <para>
                Nézzünk egy aggregációs példát:
            </para>
            <literallayout>
class Horse{
public:

};

class HungarianPerson{
public:
    ~HungarianPerson(){
        if(h != nullptr){
            delete h;
        }
    }
    Horse* h;
};
            </literallayout>
            <para>
                Ugye látható a fenti ábrából, hogy egy HungarianPerson objektum konkrét bit mintájában lesz egy rész ami egy memória cím lesz. Ezen a memória címre ha "elmegyünk" akkor ott fogjuk találni a konkrét Horse instance állapotát leíró bitmintát.
                Ami még nagyon fontos megjegyezni, hogy HungarianPerson példány halála előtt felszabadítja a Horse példány által lefoglalt memória területet.
            </para>
            <literallayout>
class Horse{
public:

};

class HungarianPerson{
public:
    Horse* h;
};
            </literallayout>
            <para>
                Utolsó példában pedig egy olyan asszociáció látható, ahol semmilyen életciklus menedzsmentet nem vállal egy HungarianPerson instance.
                Ami még nagyon fontos megjegyezni, hogy ha HungarianPerson nem szabadítja fel a Horse instance-t (ha létezik), akkor valakinek valahol mégis meg kell ezt tennie.
            </para>
            <para>
                A Java ettől ahogy azt már mondtuk eltér a GC miatt:
            </para>
            <literallayout>
class Horse{
};

class HungarianPerson{
    Horse h;
};
            </literallayout>
            <para>
                A fenti példában a Horse instance akkortól kezdve LEHET HOGY TÖRLŐDIK(felszabadul az általa foglalt hely), amitől kezdve már egyetlen referencia sem mutat rá. 
                A LEHET HOGY TÖRLŐDIK szó szerint azt jelenti ahogy hangzik. Lehet soha, lehet egyből, a JVM specifikáció nem tartalmaz megkötést a gc konkrét bekövetkezési időpontjáról.
            </para>
            <para>
                A Java-nak ez az egyik nagy előnye az olyan programozási nyelvekhez képest amikkel AAA játékokat csinálnak.
                Hogy jön ide az AAA játék, mi köze a Java-nak ehhez?
                A probléma az, hogy egy játék során nagyon nagy mennyiségű memória művelet szükséges, és emiatt nagyon pontos kontrollra van szükség.
                A GC jó, de általános. Mint minden általános megoldás az esetek 80%-ban frankón működik, viszont azáltal hogy általános pont az optimalizáltsága látja kárát ennek.
                Persze a Java ettől nem rossz nyelv, csak tudni kell hogy mi az a terület amiben erős és ott kell használni.
                (Csak hogy példát hozzak: A Java ökoszisztémában nagyon komoly support van dependencia kezelésre, pl. maven stb. C++ esetén...hát...vannak megoldás jellegű dolgok, de valójában egy zabolázatlan vad nyugat az egész.) 
            </para>
        </section>
        <section>
            <title>IntelliJ</title>
            <para>
           IntelliJ-vel generált UML alább látható. Jelenleg azon küzdök, hogy használható UML legyen belőle ne csak az alább látható színes de nem szabványos ábra.
           Plusz azt még mindig nem értem, hogy miért kell a UML-t lerántani ilyen alacsony szintre.
           Itt most a UML class diagram-ot "from scratch" értem, nem a forrásból generált esetet.
           Nekem az a benyomásom, hogy a UML class diagram az architekurális terv vázlata, és nem kell tartalmaznia minden utolsó method-ot, mert csökkenti az olvashatóságot.
           Ugyanúgy, mint a gépészeti rajzokon is a felületi érdességet csak ott jelöljük ahol annak komoly szerepe van, egyébként meg megadunk egy általánosat, abba pedig főként nem folyunk bele, hogy hogyan lesz felkészülékezve mert az a gyártástechnológián dől el.
           Persze bizonyos esetekben lehet értelme az ilyen tervezésnek is, pl. RationalRose, de ez abszolút nem általános.
           Ha a method-ok részleteire vagyok kíváncsi az a Javadoc-ban lesz úgyis.
           Hogy mit értek architekurális terv (vízió) alatt? <link xlink:href="https://support.ptc.com/help/wnc/r11.2.0.0/en/Windchill_Help_Center/images/BasicCustomization-rds.10.222.4.jpg">Például ezt.</link>
            </para>
            <figure>
                <title>Binfa UML</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="l03/uml-java/BaseTree.png" scale="60" />
                    </imageobject>
                    <textobject>
                        <phrase>Binfa UML</phrase>
                    </textobject>
                </mediaobject>
            </figure>
        </section>
        <section>
            <title>Egyéb</title>
            <para>
                A legújabb eclipse-hez még nem készültek jó plugin-ok (persze vannak pénzesek). Jelenleg azután keresgélek, hogy melyik régebbi Eclipse-nél van legalább egy stable dolog, ami nested class-októl nem esik össze...
            </para>
        </section>
    </section>

    <section>
        <title>BPMN</title>
        <section>
            <title>Feladat</title>
            <para>
            Rajzoljunk le egy tevékenységet BPMN-ben! 
            </para>
        </section>
        <section>
            <title>Megoldás</title>
            <para>
                Feladatként egy Promotion folyamatot választottam PLM rendszerben.
            </para>
            <para>
                PLM rendszerek főként bináris mérnöki dokumentumok életciklus kezeléséről szólnak. 
                Ha egy gépész megtervez egy autót CAD-ben az ezeregy alkatrészből, alkatrész előfordulásból, alösszeállításból áll, és mivel gyakran nagyon sok különböző részleg dolgozik közösen, ezért egyfajta verzió követés és változás követés szükséges.
            </para>
            <para>
                A Promotion-nel lehet sok apró változtatást elfogadni és új verzióra léptetni egy terméket.
                Biztos ismerős lehet a katonai filmekből a dolog.
                Például Sherman Mark II. Nos, pontosan erről van szó, csak mondjuk Bentley-be való fröccsöntött pohártartókkal (igen, be kell vallanom, nem annyira szexisek mint egy Sherman tank, viszont meglepően sokat fizet értük a Bentley).
            </para>
            <para>
                 A Promotion folyamat erősen testreszabható, én direkt egy egyszerűt választottam.
            </para>
            <figure>
                <title>BPMN Promotion</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="l03/bpmn/promotion.png" scale="60" />
                    </imageobject>
                    <textobject>
                        <phrase>BPMN Promotion</phrase>
                    </textobject>
                </mediaobject>
            </figure>
            <para>
                 A Promotion folyamatot user-ek indítják, és effektíve szerver oldalon létezik egy PromotionNotice nevezetű perzisztens objektum.
                 Ez az objektum tárolja az összes, a folyamat szempontjából szükséges, adatot.
            </para>
            <para>
                A folyamat első lépése annak eldöntése hogy kinek adja ki a rendszer a felülvizsgálat munkáját.
                Szerver oldalon létezik egy business rule engine, ami long story short egy xml fájlból, vagy UI-on történt settingekből(ne menjünk bele, régi dolog, jsp-t használ), olvassa be a cég business admin-ja által előre megírt szabályokat.
                Ilyen szabály az is, hogy kik tartoznak lehetséges reviewer csoportba.
                Ebből a csoportból választ a BusinessRule engine.
            </para>
            <para>
                A user-t visszakapva a workflow engine ad neki egy új task-ot (olyan mint az SAP, tehát a user ha belép a profiljába látja a taskjait stb.).
                A user a review elvégzi és aztán vissza jelez. Ezzel az ő feladatának vége.
            </para>
            <para>
                Ha minden rendben volt, akkor a PromotionNotice object állapotát megváltozatja a workflow engine. Ezentúl az összes a PromotionNotice-hoz rendelt dolgot magasabb verzióra emeli.
            </para>
            <para>
                Ha a reviewer nem engedi át, akkor ezen példában átállítódik a PromotionNotice státusza majd véget ér a folyamat.
            </para>
            <para>
                A valóságban sok helyen nem így szeretik használni (mert így minden visszadobás után új PromotionNotice képződik), hanem eldobás esetén visszaküldetik a tervezőknek, és mikor a tervezők megoldottak minden problémát amit a reviewer észrevett, akkor ugyanaz a PromotionNotice kerül megint review alá. 
                Ezt általában úgy érik el, hogy a nem elfogadott ágat visszakötik a folyamatba.
            </para>
        </section>
    </section>

    <section>
        <title>EPAM: Neptun tantárgyfelvétel modellezése UML-ben</title>
        <section>
            <title>Feladat</title>
            <para>
            Modellezd le a Neptun rendszer tárgyfelvételéhez szükséges objektumokat UML diagram segítségével.
            </para>
        </section>
        <section>
            <title>Megoldás</title>
            <para>
                A feladat megoldásához a gyakvezér által mutatott <link xlink:href="http://app.genmymodel.com">genmymodel</link>-t használtam.
            </para>
            <para>
                    Ezt a feladatot én úgy értettem, hogy a tantárgy felvételhez szükséges adathordozó objektumokat kell tervezni, és azt sem in-depth. 
                    Azért gondolom, mert egy kicsit overkill lenne elvárni az összes service, controller stb. modellezését, főként hogy a feladatot egy heti csokorból egy darab.
                    Ennek szellemiségében próbáltam dolgozni.
            </para>
            <para>
                    Ezen leírásban próbálok okot adni pár első ránézésre furcsa döntésemnek.
            </para>
            <figure>
                <title>Tantárgy regisztráció UML</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="l03/uml-course-reg/uml-course-reg.png" scale="60" />
                    </imageobject>
                    <textobject>
                        <phrase>Tantárgy regisztráció UML</phrase>
                    </textobject>
                </mediaobject>
            </figure>
            <section>
                <title>Deleted</title>
                <para>
                    A deleted field mögött annyi a tervezési ötlet, hogy nem szeretjük a hard delete-t. Tekintetbe véve az intézményben jellemző általános káoszt nincs az az Isten, hogy én valós DB szintű törlést kiadjak.
                    Ez ráadásul elég gyakori.
                    A másik fontos oka az az, hogy ha az admin tényleg törölni akar stb. akkor tudja időzíteni. Pl.: Kihirdeti a karbantartást, pénteken csinál egy backup-ot és utána a halott elemeket törölheti, mindezt pedig kontrollált, saját maga által felügyelt körülmények között.
                    Harmadik fontos oka, hogy egy update nem viszi annyira le a runtime performance-t mint egy tötlési kaszkád.
                </para>
            </section>
            <section>
                <title>ID eyecandy</title>
                <para>
                    ID. Az azonosítók elég problémásak. Mivel országos szintű szabályokat kell betartani, ezért a user-ek String jellegű ID-kat szeretnek.
                    A probléma ezzel az, hogy így a legfontosabb dolgot (primary key) odaadtuk bürokratáknak akik nem feltétlen foglalkoznak a valósággal.
                    A lényeg annyi, hogy valahogyan elkéne érni "hard" id-k használatát a valós működésre míg "soft" id-kat használni, hogy a bürokraták is boldogak legyenek.
                    Magyarul ha az én neptun kódom AAAAAA, akkor NE ez legyen a primary key. A primary key legyen csak egy gép generálta Long, a "soft" id pedig csak eyecandy.
                    Nagyon félek attól, hogyha bürokráciára hagyjuk az ID generálást akkor clash lesz.
                    A jó hír, hogy az átlag user vagy business admin nem is fog tudni a valós ID létezéséről, ha nem mutogatjuk front end-en.
                </para>
            </section>
            <section>
                <title>Tantárgy-Kurzus</title>
                <para>
                    Tantárgy-Kurzus. Óriási problémám hogy egy tantárgyhoz 0 vagy n kurzus tartozhat, ezt pedig nem kezeli le jelenleg a neptun.
                    Azon agyaltam, hogy szét kéne szakítani.
                    Példa problémás tárgyra: Munkavédelem (nincs előadás, se gyakorlat, se labor).
                </para>
                <para>
                    Egy probléma viszont maradt, a modellbe implicit bele van kódolva egy általam kitalált dolog.
                    Ez pedig a kurzus fajtája.
                    Mivel más field rögzíti az előadást (0..1) és a gyakorlati kurzusokat (0..n), itt nagyon sok minden össze lett mosva.
                    Ez egy borzasztóan rossz megoldás, de jelenleg ez jutott eszembe. (Pl. nem kezeli a hajdúszoboszlói kihelyezett óvónő képzésen felmerülő külsős óvoda látogatós órákat. Btw this is not a joke, google it up, it is a fully legit thing.)
                </para>
            </section>
            <section>
                <title> Kurzus-Óra</title>
                <para>
                        Ez a legtrükkösebb rész. Ez nincs megoldva a Neptun-ban sem.
                        Jöjjön a példa: "Az egyházszakadás története: Luther és az Angular 2.0"
                        Ez a tárgy szeminárium jellegű, azaz 4-szer kerül megrendezésre egy félévben, minden alkalommal máshol.
                        Jelenleg ezt a Neptun a következő módon kezeli: felvesznek egy placeholder kurzust fake attribútumokkal és megjegyzés mezőbe beírják, hogy mikor hol.
                </para>
                <para>
                        Ehelyett lehetne azt a megoldást követni, hogy létrehozzuk az összes várható órát és kapcsoljuk a kurzushoz.
                        Hogy az admin haja ne hulljon ki, persze csökkenteni lehet a workload-ot, hogyha autogeneráljuk.
                        Például ha heti rendszerességű a tárgyat választ egy form-on akkor mi ennek hatására le fogjuk generálni mind a 14-et. 
                </para>
                <para>
                        Ezzel egyben lehetne kezelni a két heti bontásban működő dolgokat (A és B hét), illetve a random levelezős képzéses dolgokat.
                </para>
                <para>
                        Azt teljesen jogos ellenérvként el tudom fogadni, hogy ez túl sok plusz adat stb., viszont legalább valahogy kezeli a problémát.
                </para>
            </section>
            <section>
                <title>Composite Keys</title>
                <para>
                    A KISS miatt kerülném a kompozit kulcsokat, de egyet beraktam a UML-be pont amiatt hogy felhozhassam az esetet.
                </para>
                <para>
                    A problémám az a kompozit kulcsokkal(ebben a példában), hogy az egyszerű esethez képest (PK egy konkrét field) trükkös az implementálása, illetve ha meggondoljuk magunkat kompozitról nagyon nehéz lesz átállni.
                </para>
            </section>
            <section>
                <title>DataTypes</title>
                <para>
                    Ez az egyetlen dolog aminek nincs értelme, csak kiakartam próbálni.
                </para>
            </section>
        </section>
    </section>

    <section>
        <title>EPAM: Neptun tantárgyfelvétel UML diagram implementálása</title>
        <section>
            <title>Feladat</title>
            <para>
           Implementáld le az előző feladatban létrehozott diagrammot egy tetszőleges nyelven.
            </para>
        </section>
        <section>
            <title>EPAM alapján</title>
            <para>
                    Az EPAM-os modellt megnézve éreztem hogy elég un-YAGNI lett az előző feladat UML-je (mikor csináltam még nem volt meg az EPAM-os referencia), úgyhogy egyszerűsítettem az előző feladatot.
                    Mindezt azért tettem, hogy egyetlen problémára kiemelve fókuszálhassunk.
                    Az EPAM-os dologban nem tudom hogy lehet megoldani azt az esetet, amikor egy msc-s tanít is meg tanul is.
                    Erre egy megoldás kezdemény lehetne az hogy a UserData(pl. name)-ról leválasztjuk a szerepvállalást mint oktatott, vagy oktató. 
                    Ezután pedig valami junction table-höz hasonló módon oldjuk meg a kapcsolatot.
                    Alább egy UML bemutatja a dolgot.
            </para>
            <figure>
                <title>Course Reg 2 UML</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="l03/uml-course-reg/uml-course-reg2.png" scale="50" />
                    </imageobject>
                    <textobject>
                        <phrase>Course Reg 2 UML</phrase>
                    </textobject>
                </mediaobject>
            </figure>
            <para>
            Ez nem a legjobb megoldás. 
            Például tovább lehetne bontani a dolgot, létre kéne hozni egy Link class-t mely egy UserData-t köt össze egy Course-al, és a role fajtája egy enum-ból vett érték lehetne.
            Ennek az a problémája hogy a type system-en kívül kezeli az üzleti logikát, viszont előnye az, hogy így könnyen konfigurálhatóak lennének az üzleti kényszerek.
            </para>
            <para>
            Azaz, például azt a döntést, hogy ki milyen role-t tölthet be akár a konkrét adattárolási szint felé is helyezhetnénk. 
            Magyarul a persistence layer simán engedné, hogy egy bsc-s órát tartson, csak az Application Layer-ben az adott service nem enegedné, de ezt is configuráció alapján..
            </para>
            <para>
            A Java class-okat a UML-ből generáltam a <link xlink:href="http://app.genmymodel.com">genmymodel</link> segítségével.
            Annyit el kell mondani, hogy természetesen manuálisan utána kellett munkálni elég sok mindent.
            De szerintem a feladat célja nem az volt, hogy megmutassa hogy mennyire 100%-osan működik az UML-ből java generálás. 
            Sokkal inkább szerintem az volt a cél, hogy megismertessen minket a UML legfőbb erősségével a kommunikáció grafikussá tételével.
            Itt a kommunikáció alatt azt értem, hogy a tervezési szándékot át kell adni, és ezt kommunikálhatjuk szóban, sajtos cetlire írva, vagy UML-el. 
            A UML ugyan sok időt igényel, de még mindig kevesebbet, mint egy félreértett beszélgetés után a codebase újraíratása.
            </para>
            <para>
            A Java class-okat <link xlink:href="https://github.com/rkeeves/bhax-derived/tree/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/l03/uml-course-reg">ezen a címen</link> lehet megtalálni.
            </para>


            
        </section>
    </section>

    <section>
        <title>OO modellezés</title>
        <section>
            <title>Feladat</title>
            <para>
           Írj egy 1 oldalas esszét arról, hogy OO modellezés során milyen elveket tudsz követni (pl.: SOLID, KISS, DRY, YAGNI).
                <link xlink:href="https://blog.cleancoder.com/uncle-bob/2018/08/28/CraftsmanshipMovement.html">Btw, Uncle Bob took a SOLID dump on the Agile scene way-waaay back.</link>.
           A témához Jeszenszky Tanár Úr  <link xlink:href="https://arato.inf.unideb.hu/jeszenszky.peter/download/prt/presentations/oo.pdf">egyik hasznos diasorát</link> használtam a sok-sok általa elérhetővé tett közül.
            </para>
        </section>

        <section>
            <title>SOLID</title>
            <para>
            A <literal>SOLID</literal> egy betűszó. Jelentése a következő:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                    S - Single Responsibility Principle
                    </para>
                </listitem>
                <listitem>
                    <para>
                    O - Open/Closed Principle
                    </para>
                </listitem>
                <listitem>
                    <para>
                    L - Liskov Substitution Principle
                    </para>
                </listitem>
                <listitem>
                    <para>
                    I - Interface Segregation Principle
                    </para>
                </listitem>
                <listitem>
                    <para>
                    D - Dependency Inversion Principle
                    </para>
                </listitem>
            </itemizedlist>
            <section>
                <title>Single Responsibility Principle</title>
                <para>Ez ez elv annyit takar hogy egy nagy problémát próbáljunk egymástól független részproblémákra osztani, és ezen részproblémákat ha lehetséges egy-egy objektum kezelje.</para>
                <para>
                Persze ez nem mindig követhető teljesen, hiszen a valós életben bizonyos üzleti indokok meggátolhatják ezt. 
                Egy másik nagyon fontos ok arra, hogy megszegjük az az optimalizálás.(avagy mi mindent tud számolni egy vertex shader). 
                </para>
                <para>
                    Sok-sok példát lehet hozni (fogok hozni én is), de egy balta egyszerűségű példa a standard kimenetre írás. 
                    Azáltal hogy std out-ra írunk mentesülünk a file descriptor problémakörtől stb. a user pedig abba folyatja a kimenetet amibe akarja.
                </para>
                <para>
                    Java esetére szűkítve Objektumokban, Osztályokban gondolkodunk.
                    Az elvre például lehetne azt hozni use case-ként(direkt egy "buta" dolog), hogy egy Person objektum-nak tudnia kell-e, hogy ma születésnapja van-e az adott Person-nek?
                </para>
                <literallayout>
class Person{
    String name;
    Date dob;

    boolean hasBdayToday(){...}
}
                </literallayout>
                <para>
                    Mármint, ha a Person objektum egyetlen felelőssége (a név és többin kívül) a születési idő betárolása, akkor három dolgot is nyerünk:
                </para>
                <literallayout>
class Person{
    String name;
    Date dob;
}


class AgeService{
    boolean hasBdayToday(Date dob){
        ...
    }
}
                </literallayout>
                <para>
                    1. Ugye kimozgattuk a "születésnapos-e?" számítást, tehát nagy valószínűséggel a date of birth a Person-ból fogjuk venni továbbra is, de maga a Person osztály már csak egy passzív adatstruktúra.
                </para>
                <para>
                    2. Mivel "születésnapos-e?" metódust kihoztuk a Person osztályból, mostmár nem kell egy teljes Person példányt létrehozni teszt célból.
                </para>
                <para>
                    3. Mivel "születésnapos-e?" metódust kihoztuk a Person osztályból, mostmár ha kell bárminek a születésnaposságát eldönthetjük, hiszen az egyetlen argumentumunk a születési idő.
                </para>
            </section>
            <section>
                <title>Open/Closed Principle</title>
                <para>
                    Értsd: nyitott a bővítésre, zárt a módosításra, avagy új funkcionalitás hozzáadását támogató kódot kell írnunk, azonban az eddigi szerződések betartásával.
                </para>
                <para>
                            Miért is fontos ez?
                            A módoításra való zártság amiatt szükséges mert különben úgy járunk mint az Angular 2 hahaha ksözönöm az Oscart.
                            Viccet félretéve, ha egy létező interface, class, abstract class-ba kénytelenek vagyunk belenyúlni, és ez a módosításunk törlés, akkor ez azzal jár, hogy lehet hogy más kódrészek, melyek ettől függtek idáig, innentől nem fognak működni.
                </para>
                <para>
                            Tegyük fel valami <link xlink:href="https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html">plugin</link>-t írunk egy progihoz.
                            Tegyük fel a fő progi adott, ez induláskor létrehoz gombokat a GUI-n. Ezek a gombok a főprogi alapfunkciói:
                </para>
                <literallayout>
class Prog{
    void start(){
        buttons.add( new FileButton());
        buttons.add( new EditButton());
    }
}
                </literallayout>
                <para>
                            A kérdés most az, hogy akkor hogyan fogják tudni a plugin-ok a saját gombjaikat hozzáadni?
                            Ugye a következő megoldást nem követhetjük, mert akárhányszor a cégünk előrukkol egy új pluginnal, annyiszor kell a fő progit módosítani:
                </para>
                <literallayout>
class Prog{
    void start(){
        buttons.add( new FileButton());
        buttons.add( new EditButton());
        buttons.add( new PayToWinButton());
        buttons.add( new LootBoxButton());
       
    }
}
                </literallayout>
                <para>
                            Sőt, tegyük fel bizonyos plugin-oknak csak egy speckó licensz esetén szabad elindulniuk:
                </para>
                <literallayout>
class Prog{
    void start(){
        buttons.add( new FileButton());
        buttons.add( new EditButton());
        if(licenses.has("CashGrab")){
            buttons.add( new PayToWinButton());
            if(licenses.has("UseLoopholeInUSGamblingRegulations")){
                buttons.add( new LootBoxButton());
            }  
        }
    }
}
                </literallayout>
                <para>
                            Ajjaj, ez elég rosszul néz ki! 
                            Mostmár nem csak hogy a főprogi példányosítja a gombokat, de mostmár ő is kezeli a licenszelést.
                            Akárhányszor van valami új dolog, az magában a főprogiban okoz változást.
                            Sőt, még rosszabb: Ha valamelyik plugin elszáll startup közben, akkor az egész programnak vége.
                </para>
                <para>
                            A megoldásnak valami olyasminek kéne lennie, hogy valamilyen módon el tudjuk érni, hogy újabb gombokat lehessen hozzáadni, anélkül hogy a többi részben kárt okoznánk. 
                </para>
                <literallayout>
interface LicenseManager{
    void has(String featureName);
}

interface Plugin{
    List&lt;Button&gt; startup(LicenseManager lm) throws PluginStartupError;
}

class PayToWinPlugin implements Plugin{
    List&lt;Button&gt; startup(LicenseManager lm) throws PluginStartupError{
        List&lt;Button&gt; l = new ArrayList&lt;Button&gt;();
        if(lm.has("CashGrab")){
            l.add( new PayToWinButton());
            if(lm.has("UseLoopholeInUSGamblingRegulations")){
                l.add( new LootBoxButton());
            }  
        }
    }
}

class CorePlugin implements Plugin{
    List&lt;Button&gt; startup(LicenseManager lm) throws PluginStartupError{
        List&lt;Button&gt; l = new ArrayList&lt;Button&gt;();
        l.add( new FileButton());
        l.add( new EditButton());
    }
}

class Prog implements LicenseManager{
    void start(){
        // load plugin classes from specific dir
        for(Plugin plugin : plugins){
            try{
                buttons.addAll(plugin.startup(this));
            }catch(...){
                // handle err
            }
        }
    }
}
                </literallayout>
                <para>
                            A fenti megoldással a plugin-ok annyi gombot regisztrálnak amennyit akarnak, és nem a mi feladatunk a licensz feature-ök check-je, csak a licensz feature-öket tároló objektum vagy service továbbítása a plugin felé.
                            Egyébként csak azért listában adják vissza a gombokat, mert egyszerűre akartam fogni (és ez a legegyszerűbb módja annak, hoghya mindjuk egy 2 gombot regisztráló plugin elhal a második gomb regisztrációnál akkor rollback-elnünk kell az elsőt. Persze ez csak egy gagyi iskolai példa).
                </para>
            </section>
            <section>
                <title>L - Liskov Substitution Principle</title>
                <para>
                            A Liskov elveket nem lehet elégszer gyakorolni. Ugyan már más feladatban is foglalkoztunk vele, most nézzünk egy Vehicle példát megcsavarva!
                </para>
                <literallayout>
class Vehicle{
    void takeSeat();
    void startEngine();
    void go();
}

class Car extends Vehicle{
    void takeSeat(){
        //...
    }
    void startEngine(){
         //...
    }
    void go(){
        //...
    }
}

class Boat extends Vehicle{
    void takeSeat(){
        //...
    }
    void startEngine(){
         //...
    }
    void go(){
        //...
    }
}

class Roller extends Vehicle{
    void takeSeat(){
        throw new NotImplementedError();
    }
    void startEngine(){
        throw new NotImplementedError();
    }
    void go(){
        //...
    }
}
                </literallayout>
                <para>
                          A fenti kód amiatt problémás, mert ahol lehet használni Vehicle-t ott nem biztos hogy lehet használni Roller-t. 
                          Innentől kezdve bárhol ahol használjuk Vehicle-t try-catch-elni kell.
                </para>
            </section>
            <section>
                <title>Interface Segregation</title>
                <para>
                    Nagy interface-eket kisebbekké kell tenni ha lehetséges.
                    De miért is jó ez?
                </para>
                <para>
                    Sajnos nem tudom kihagyni a Collections-t mert gyönyörú példa, és szerintem megérthető, hogy nem az interface-ekhez van köze igazából.
                    Szerintem sokkal inkább arról van szó, hogy csak olyan dolgokat várjunk el, melyekre valóban szükség lesz.
                </para>
                <para>
                    Tegyük fel, hogy kapni akarunk egy listát amin egyszer végig fogunk menni, no random access.
                    Ebben az esetben túl is specifikálhatjuk a dolgot:
                </para>
                <literallayout>
interface Foo{
    void bar(LinkedList&lt;String&gt; l);
}
                </literallayout>
                <para>
                    A bökkenő az, hogy egy ArrayList-et nem fogunk tudni elfogadni, annak ellenére, hogy az pedig képes lenne erre.
                    (Ha pedig átírjuk ArrayList-re, akkor pedig LinkedList-el lesz baj.)
                    Írjuk akkor át így:
                </para>
                <literallayout>
interface Foo{
    void bar(List&lt;String&gt; l);
}
                </literallayout>
                <para>
                    Ez már akár jó is lehet, de igazságszerint, még ennél is kevesebbre van szükség.
                    Például akarjuk a contains methodpt használni? Nem.
                    Nos, mivel a Collections-t próbálták ezen elvek szerint készíteni mielőtt jött az Orac...mármint mivel ezen elvek szerint készítették, ezért lehetünk még specifikusabbak:
                </para>
                <literallayout>
interface Foo{
    void bar(Iterator&lt;String&gt; l);
}
                </literallayout>
                <para>
                    Ez már akár jó is lehet, de igazságszerint, még ennél is kevesebbre van szükség.
                    Például akarjuk a contains methodpt használni? Nem.
                    Nos, mivel a Collections-t próbálták ezen elvek szerint készíteni mielőtt jött az Orac...mármint mivel ezen elvek szerint készítették, ezért lehetünk még specifikusabbak:
                </para>
                <literallayout>
public class Main implements Iterator&lt;String&gt;{

	private int current = 0;
	
	public static void main(String[] args) {
		Foo foo = new Foo() {
			@Override
			public void bar(Iterator&lt;String&gt; l) {
				l.forEachRemaining(System.out::println);			
			}
			
		};
		Iterator&lt;String&gt; it  = Arrays.asList("a","b","c").iterator();
		foo.bar(it);
		foo.bar(new Main());

	}

	@Override
	public boolean hasNext() {
		return current &lt; 3;
	}

	@Override
	public String next() {
		return ""+current++;
	}

}
                </literallayout>
                <para>
                        A fenti példából látszik, hogy még egy "mock" jellegű iterátort is tudtunk faragni a Main class-ból.
                        Az egész tanulsága az, hogy ezt csak azért tudtuk megtenni, mert a Collections interface-ei elég granulárisak.
                        Tudom, hogy ennél fancybb példát is lehetne csinálni, mint pl. a Baeldung-os Zookeeper-ös, de ezen példa amiatt jó, hogy gyakrabban fog előfordulni életünkben mint egy állatkerti dolog.
                </para>
            </section>
            <section>
                <title>Dependency Inversion</title>
                <para>
                    A magasabb szintű komponensek ne függjenek az alacsonyabb szintű komponensektől.
                    Azaz próbáljunk absztrakciós szinteket létrehozni és lehetőleg ezeken belül maradni.
                    Tegyük fel valami játékot írunk:
                </para>
                <literallayout>
class App{
    OpenGLRenderer opengl;

    App(){
        opengl = new OpenGLRenderer();
        opengl.init();
    }

    void onRender(){
       renderDefaultRect();
    }

    void renderDefaultRect(){
        float[] vertices = {
            -0.5f, 0.5f, 0f,
            -0.5f, -0.5f, 0f,
            0.5f, -0.5f, 0f,
            0.5f, -0.5f, 0f,
            0.5f, 0.5f, 0f,
            -0.5f, 0.5f, 0f
        };
        FloatBuffer verticesBuffer = BufferUtils.createFloatBuffer(vertices.length);
        verticesBuffer.put(vertices);
        verticesBuffer.flip();
        vertexCount = 6;
        // do more stuff
    }

    void stop(){
        opengl.cleanup();
    }
}
                </literallayout>
                <para>
                    A fenti kód részlet nagyon jól tudna működni.
                    A probléma az, hogy innentől kezdve OpenGL-el működünk.
                    Bármit is rajzolunk annak a vége OpenGL lesz.
                    De mi van ha Vulkan-t akarunk?
                </para>
                <para>
                    A másik probléma, hogy mikor egy sima téglalapot akarunk, akkor is vertexbuffer-ekkel kell szórakoznunk.
                    Ami pedig még rosszabb, hogy ha ezeket a low level dolgokat a játék kódjában is használjuk akkor 
                    maga a játék logikájának is lesz egy dependenciája az OpenGL-re. 
                    A megoldás az, hogy létrehozunk egy magasabb szintű Renderer interface-t, és a játékban ezt fogjuk hívogatni.
                </para>
                <literallayout>
interface Renderer{
    void drawDefaultRect();
}

class App{
    Renderer rend;

    App(){
        
    }

    void init(){
        if(isVulkan())
            rend = new VulkanRenderer();
        else 
            rend = new OpenGLRenderer();
        rend.init();
    }

    void onRender(){
        rend.drawDefaultRect();
    }

    void stop(){
        rend.cleanup();
    }
}
                </literallayout>
                <para>
                    A fenti kód magasabb szintű műveletekkel foglalkozik. Például inicializálás, feltakarítás, illetve összetetebb dolgok, például quad-ok rajzolgatásával.
                </para>
            </section>
            <section>
                <title>DRY - Don't Repeat Yourself</title>
                <para>
                        Ezzel az elvvel nem lehet vitatkozni. Egy az egyben és szó szerint alkalmazandó.
                        A kód duplikáció rossz a karbantarthatatlanság miatt.
                </para>
                <para>
                        Vegyünk egy egyszerű példát: ez a docbook.
                </para>
                <para>
                        Ha a forrásfájlokból a kódrészleteket nem include-olnám, hanem bemásolnám egy literallayout-ba, akkor minden alkalommal mikor hozzányúlok a fájlhoz újra átkéne másolnom a kódrészletet a doksiba.
                </para>
                <para>
                        Ami viszont még fontosabb, és szerintem nem egyértelmű a DRY-ban, hogy ez nem csak kódról szól.
                        A világunkban a redundancia mindig plusz problémákhoz vezet, emiatt általában csak akkor engedünk teret redundáns rendszereknek, mikor biztonsági szempontból kell egy fallback plan.
                </para>
                <para>
                        A DRY-t a fentiek mellett azonban lehet arra is használni, hogy könnyen megláthassuk hol lehetne javítani egy mástól örökölt kódot.
                        Ha kód duplikációt látunk akkor nagy valószínűséggel alkalmazhatunk valami mintát a kikerülésére. Sőt ha egyik mintával sem lehet megoldani, akkor gyakran egy elég komoly érv lehet az eredeti design újragondolására.
                </para>
                <para>
                        Véleményem szerint az egyetlen probléma a DRY alkalmazásával pontosan a sikere: mindenki gyorsan megérti, egyetért vele, és kerüli megsértését minden áron.
                        A a Util class-ok megjelenése és elburjánzása egy codebase-ben szerintem emiatt alakul ki.
                        A Util class-ok alatt azt értem, hogy hozzám hasonló naív junior-ok tudják hogy nem szabad kódot ismételni, ezért bevágják egy BlaBlaUtil class-ba, mert még nincs neki igazi hely ahova tartozzon.
                        Utána jön egy másik ember (vagy akár ugyanaz), és mivel már van egy BlaBlaUtil a következő apróságot is berakja oda.
                        Utána kiszervezik a fejlesztést <link xlink:href="https://en.wikipedia.org/wiki/Pune">valahova</link>, ahol meg már szabálynak veszik, hogy minden ami nem egyből eldöntehető az egyenesen megy a Util class-ba. 
                        A Util class így a végén rendelkezni fog 1000 sorral, 300 methoddal.
                        Ami pedig még fontosabb, hogy mivel főként kis static methodok vannak benne, ezért összevissza mindenki függ ettől a behemótra nőtt BlaBlaUtilClass-tól.
                        Legvégül pedig jön a kérdés, hogy kinek a felelőssége a class karbantartása?
                        Senkinek, hiszen mindenkié és egyszerre senkié sem.
                </para>
            </section>
            <section>
                <title>YAGNI - You Aren't Gonna Need It</title>
                <para>
                        Ez az elv, gondolom én, azért szükséges, mert kissé ellensúlyozni kell azt a késztetést, hogy előre megtervezzünk minden részletet, minden lehetséges körülmény fennállásakor, minden igényt és lehetséges jövőbeli igényt kielégítve.
                        A YAGNI sértésére egy <link xlink:href="https://robertsspaceindustries.com/">példa</link>.
                       
                </para>
                <para>
                     Ez az elv szerintem kicsit rosszul van megfogalmazva. Szerintem sokkal érthetőbb lenne a célja, ha az opportunity cost-al érvelnénk.
                     Szerintem érdemesebb lenne úgy megfogalmazni hogy mikor rászánsz egy órát egy feature-re, egyben el is veszel egy potenciális órát egy másiktól.
                </para>
            </section>
            <section>
                <title>KISS - Keep it simple stupid</title>
                <para>Ez az elv annyit jelent, hogy próbáljunk az egyszerűségre törekedni.
                    Akármilyen jól hangzik sokszor ezt nem lehet megtenni (pl.: egy olyan API-val dolgozunk mely megköti kezünket).
                    Az elv szerintem nem azt jelenti, hogy bármi áron törekedjünk az egyszerűségre, sokkal inkább ha létezik több megoldás egy problémára, akkor ne hagyjuk ki a megoldások értékelési szempontjai közül az egyszerűséget.
                </para>
                <para>
                        Ezt az elvet amiatt tartom problémásnak kicsit, mert nem jól definiálható az hogy mi számít egyszerűnek.
                </para>
            </section>
        </section>
    </section>
</chapter>                
