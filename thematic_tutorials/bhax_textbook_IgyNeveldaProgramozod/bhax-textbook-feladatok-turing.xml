<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C <link xlink:href="https://youtu.be/hQCG2AwzTxA">végtelen ciklusokat</link>, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó: <link xlink:href="">No link</link>
        </para>
        <para>
            Megoldás forrása:
            <itemizedlist>
              <listitem>
                <para><link xlink:href="">Basic For infinite</link></para>                     
              </listitem>
              <listitem>
                <para><link xlink:href="">For sleep with Torvalds</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="">While infinite</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="">For sleep with both Torvalds and a greedy company</link></para>
              </listitem>
            </itemizedlist>
        </para>
        <para>
            Számos módon hozhatunk és hozunk létre végtelen ciklusokat. 
            Vannak esetek, amikor ez a célunk, például egy szerverfolyamat fusson folyamatosan és van amikor egy
            bug, mert ott lesz végtelen ciklus, ahol nem akartunk. Saját péláinkban ilyen amikor a <link xlink:href="https://youtu.be/WfbTbPEEJxI?t=9971">PageRank algoritmus</link> 
            rázza az 1 liter vizet az internetben, de az iteráció csak nem akar konvergálni...
        </para>                    
        <para>
            Egy mag 100 százalékban:               
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/thefor.c"/></textobject>
        </programlisting>   
        <para>        
        vagy az olvashatóbb, de a programozók és fordítók (szabványok) között kevésbé hordozható
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/infty-f_torvalds.c"/></textobject>
        </programlisting>        
        <para>
            Azért érdemes a <literal>for(;;)</literal> hagyományos formát használni, 
            mert ez minden C szabvánnyal lefordul, másrészt
            a többi programozó azonnal látja, hogy az a végtelen ciklus szándékunk szerint végtelen és nem szoftverhiba. 
            Mert ugye, ha a <literal>while</literal>-al trükközünk egy nem triviális 
            <literal>1</literal> vagy <literal>true</literal> feltétellel, akkor ott egy másik, a forrást
            olvasó programozó nem látja azonnal a szándékunkat.
        </para>                        
        <para>
            OS independens             
        </para>        
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/infty-w.c"/></textobject>
        </programlisting>         
        <para>
            OS dependens-re példa, hisz a sleep rendszerhívás.    
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/infty-f.c"/></textobject>
        </programlisting>        
        <para>
          Egyébként a <literal>gcc</literal> mellé betudunk passzolni flageket. Például <literal>-DALMA</literal>-val gyakorlatilag azt mondjuk a preprocesszornak, hogy vegye úgy mintha <literal>#define ALMA</literal>.
          Ez pontosan annyira szép mint amennyire elegáns, de ez van.
        </para>
        <para>
            Ha belenézel az STL-be, akkor az is tele lesz ilyenekkel, hisz különböző OS-ekkel kell tudni használni, és a rendszerhívások átlalában eltérőek.
            Egyébként ha valami IDE-vel dolgozol, ott gyakran még szépen be is szürkíti azokat a részeket a kódban amelyeket ki fog hagyni.
            Itt semmi mágia nem történik, hanem simán nem a forráskódod megy a compiler-nek, hanem előtte van egy preprocesszor, ami feldolgozza ezeket az utasításokat.
            Makrók ugyanilyenek. Tehát nem runtime kiértékelhető az <literal>#ifdef</literal> hanem egy utasítás a preprocesszornak.
            Leggyakrabban <literal>#ifdef</literal>-el header guard-ként fogsz találkozni (vele kb. ekvivalens a nem mindenhol támogatott <literal>#pragma once</literal>).
        </para>
    </section>
    <section>
      <title>Lefagyott, nem fagyott, akkor most mi van?</title>
      <para>
          Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
      </para>
      <para>
          Megoldás videó: <link xlink:href="">No link</link>
      </para>
      <para>
          Megoldás forrása:
          <itemizedlist>
              <listitem>
                <para><link xlink:href="">Turing 100 (pseudocode)</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="">Turing 1000 (pseudocode)</link></para>
              </listitem>
          </itemizedlist>
      </para>
      <para>
          Tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
          függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne végtelen ciklus:              
      </para>
      <programlisting language="c" linenumbering="numbered">
        <textobject><textdata encoding="UTF-8" fileref="Turing/t100.c"/></textobject>
      </programlisting>           
      <para>
          A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
          <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
          akár önmagára
          <screen><![CDATA[T100(T100)
false]]></screen>  
          ezt a kimenetet adja.          
      </para>
      <para>
          A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
          Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
      </para>
      <programlisting language="c" linenumbering="numbered">
        <textobject><textdata fileref="Turing/t1000.c"/></textobject>
      </programlisting>                     
      <para>
        Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                            
        <itemizedlist>
            <listitem>
                <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
            </listitem>
            <listitem>
                <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
            </listitem>
        </itemizedlist>
        akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
        függvényt, azaz a T100 program nem is létezik.                
      </para>
      <para>
        Szerintem Tanár Úr leírása tök jó volt. Nincs szívem hozzányúlni.
        Mivel technikailag nem lehet többet hozzárakni, ezért inkább egy kis kulturális plusz:
        A borbély az aki azok haját vágja, akik nem teszik meg ezt saját maguknak.
        De a borbély vágja-e a saját haját?
        Nos, tegyük fel levágja:
        Ebben az esetben ő levágta a haját egy olyan embernek aki egyébként ezt megteszi saját magának.
        Ok, tegyük fel nem vágja:
        Viszont ebben az esetben nem vágja a saját haját, aka lehetne a saját ügyfele, viszont ha most levágja akkor kezdődik az egész elölről <link xlink:href="https://en.wikipedia.org/wiki/Russell%27s_paradox">Russel's paradox</link>.
      </para>
  </section>            
  <section>
    <title>Változók értékének felcserélése</title>
    <para>
      Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
      használata nélkül!
    </para>
    <para>
      Megoldás videó: <link xlink:href="">No Link</link>
    </para>
    <para>
      Megoldás forrása:
      <itemizedlist>
      <listitem>
        <para><link xlink:href="">Swap XOR</link></para>
      </listitem>
      <listitem>
        <para><link xlink:href="">Swap Subtract</link></para>
      </listitem>
      <listitem>
        <para><link xlink:href="">Swap Multiplication</link></para>
      </listitem>
      <listitem>
        <para><link xlink:href="">Swap Ptr</link></para>                   
      </listitem>
    </itemizedlist>
    </para>
    <para>
        Több megoldási lehetőség is van, ezeket fogjuk a következő bekezdésekben bemutatni.
    </para>
    <para>
        Swap by bitwise xor
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/swap_xor.cpp"/></textobject>
    </programlisting>  
    <para>
        Swap by subtraction
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/swap_subtract.cpp"/></textobject>
    </programlisting>  
    <para>
        Swap by multiplication
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/swap_mult.cpp"/></textobject>
    </programlisting>  
    <para>
        Ez az utolsó csak egy picit behozza a pointer-eket a képbe.
        Ezekkel ha még nem értjük mi van, ne aggódjunk.
        Minden pointert érdemes egy címként felfogni.
        Azaz ha létezik egy int változónk foo néven akkor foo-nak van ugye egy értéke, illetve egy címe.
        A cím az amit a ptr megtestesít (na jó nem, de most így elég...).
        Természetesen funckiókra is mutathatunk.
        Sőt, ha már valaha láttunk C kódot, akkor valószínűleg belefutottunk már callback-ekbe stb.
        Aka akár funkciókat és bepasszolhatunk funkciókba.
        <link xlink:href="https://youtu.be/MFUgDYwyC2s?t=60">Ez egy totál handy dolog, biztos nem lesz rossz vége!</link>
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/swap_ptr.cpp"/></textobject>
    </programlisting>  
  </section>                     
  <section>
    <title>Labdapattogás</title>
    <para>
        Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
        nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! Nem írhatsz hozzá DLC-t, és ne legyen benne lootbox, mert nem ez EA vagyunk.
    </para>
    <para>
        Megoldás videó: <link xlink:href=""></link>
    </para>
    <para>
        Megoldás forrása:
        <itemizedlist>
          <listitem>
              <para><link xlink:href="">Necessary header for terminal manip</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="">Ball C</link></para>
          </listitem>
        </itemizedlist>
    </para>
    <para>
        Ennek a feladatnak az volt a lényege, hogy megismertessen low level trükkökkel.
        Természetesen ez minket totál hidegen hagy. Úgyhogy inkább nézzük meg, hogy például egy játék-ot hogyan lehet passzív adatsruktúrákkal felépíteni.
        Alább található egy link egy manapság erősen hype-olt programtervezési módra (Pl.: Unity is hasonló)
        <link xlink:href="https://github.com/alecthomas/entityx">Entity Component System C++</link>. Egyébként ha belenézel és valami nagyon nincs rendben <link xlink:href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">a template super definíciójával</link>, nos hát igen.
    </para>
    <para>
      Az egész feladat self-explanatory, úgyhogy inkább nézz rá <link xlink:href="https://github.com/ikalnytskyi/termcolor">erre</link>. Ez egy pici header only project OS independens terminál szín kezelésre. Huzzah!
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/ball.c"/></textobject>
    </programlisting>  
  </section>                     
  <section>
    <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
    <para>
        Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
        Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
    </para>
    <para>
        Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link>, 
        <link xlink:href="https://youtu.be/KRZlt1ZJ3qk">https://youtu.be/KRZlt1ZJ3qk</link>, 
        <link xlink:href=""></link>.
    </para>
    <para>
        Megoldás forrása: <link xlink:href="Turing/bogomips.c">
            <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/bogomips.c</filename>
        </link>
    </para>
    <para>
      Ha valakinek van gyereke, vagy gyerek ismerőse és ezt az egészet játékosan akarja neki elmagyarázni akkor van egy szuper aranyos kis könyv ami mellé adnak ingyen progikat és a nullából építhet otthon egy pici számítógépet kapuktól tetris játékig bezárólag. <link xlink:href="https://www.nand2tetris.org/">Ez az</link>
   </para>
    <para>
        Szóhossz alatt a gépi szavak hosszát értjük.
        Mi ez az egész gépi szó dolog?
        Túlzott részletezés nélkül a következő. A gépünk logikai kapukból épül fel (meg még sok másból). Röviden ezek egy "bit" műveletre képesek. Ha pl. 8 "bit"-et akarunk egyszerre kezelni, akkor egy bites kapukból összelehet legózni.
        Ezek a "kábelhágcsók" a valóságban nem kábelek, és "belevannak égetve" a "vasba". A kapuk is "belevannak égetve" a "vasba".
        Azaz az, hogy egy menetben max mennyi kábelnyit tudunk kezelni a gyártott gép specialitása.
        Egy mittudomén 5 bit-es gépet azért (sem) lehet upgrade-elni 2020 bit-essé, mert a "beégetett kábelhágcsó"-k száma 5, és pont, vége a mondatnak.
        A szó egy picit más. A lényeg hogy a proci-ba ha küldünk mondjuk 01101-t, akkor ez valójában mi?
        Nos intel stb. gyártótól eltérő, de pl. a mi gagyi esetünkben legyen a következő szabály:
        Az első bit ha 0 akkor robbanjon fel a gép. Ha az első bit 1, akkor a többi bit által reprezentált idő múlva robbanjon fel.
        Azaz 01101-re felrobban egyből, 10001-re pedig egy másodperc múlva robban fel.
    </para>
    <para>
        Változtassunk a specifikáción, lesz a procinak egy regisztere:
        Ha az első bit 0 akkor olvassunk a többi négy bit által megadott ram címről és tegyük be a regiszterbe.
        Ha az első bit 1 akkor írjunk a többi négy bit által megadott ram címre azt ami jelenleg a regiszterben van.
        Hát...ez így nem frankó, hiszen annak ellenére, hogy a gépünk technikailag képes lenne 5bites címek kezelésére, az instrukciók miatt nem lehet.
        Szóval, blablabla emiatt van double word stb. de most abba ne menjünk bele hogy az Intel miért okozta a Spectre-t, Meltdown-t stb. (tippecske: évről évre egyre többet várt tőlük a piac, ők meg - mint jó kapitalista - csaltak és cache-be raktak olyat is ami nem biztos hogy kellett a kódnak, pl.: conditionaltől függetlenül két ágát kicsit előre számítani. Végeredményt lehetett látni a híradóban.).
    </para>
  </section>                     
  <section>
    <title>Helló, Google!</title>
    <para>
        Írj olyan C programot, amely egy több milliárd(haha ne ne...elég lesz kevesebb srsly) honlapból álló hálózatra kiszámolja az N lap Page-Rank 
        értékét, és <link xlink:href="https://youtu.be/WfbTbPEEJxI?t=9971">nem lesz belőle baj egy szenátusi kihallgatáson</link>!
    </para>
    <para>
        Megoldás videó: <link xlink:href=""></link>
    </para>
    <para>
        Megoldás forrása:
        <itemizedlist>
          <listitem>
              <para><link xlink:href="">C' le magnifique</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="">STL Iterator</link></para>
          </listitem>
          <listitem>
              <para><link xlink:href="">Purely STL Vector</link></para>
          </listitem>
        </itemizedlist>
    </para>
    <para>
      Pagerank C jelleggel
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/pagerank_c.cpp"/></textobject>
    </programlisting> 
    <para>
      Pagerank STL Iterators
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/pagerank_iter.cpp"/></textobject>
    </programlisting> 
    <para>
      Pagerank STL Vector
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/pagerank_vec.cpp"/></textobject>
    </programlisting> 
  </section>
  <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
    <title>A Monty Hall probléma</title>
    <para>
        Írj szimulációt a Monty Hall problémára!
    </para>
    <para>
        Megoldás videó: <link xlink:href="">No link</link>
    </para>
    <para>
        Megoldás forrása: <link xlink:href="">No link</link>
    </para>
    <para>
        Gondolkodjunk úgy hogy két stratégia van: "nem választunk újra" és "újra választunk".
        Alábbi kódban "nem választunk újra" esetben N lehetőség közül 1/N valószínűségünk van nyerni.
        Viszont ha tudjuk hogy "nem választunk újra" veszített, és a fazon már kinyitott egy ajtót, akkor N-2-ből kell csak választanunk.
        Utolsó sorban kiírja az nbatfai és ezen kód is sanity check jelleggel a két startégia nyertes kimeneteleinek összegét, ami N=3 esetben egyenlő N-nel.
        Magasabb N-nél ez nem így van, hisz ha "nem választunk újra" veszített és a fazon kinyitottegy ajtót és N>3 akkor nekünk kisebb mint 100% esélyünk van "újra választunk"-kal nyerni.
    </para>
    <programlisting language="c" linenumbering="numbered">
      <textobject><textdata fileref="Turing/monty_hall.cpp"/></textobject>
    </programlisting> 
  </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>

        <para>
            A természetes számok építőelemei a prímszámok. Abban az értelemben, 
            hogy minden természetes szám előállítható prímszámok szorzataként.
            Például 12=2*2*3, vagy például 33=3*11.
        </para>
        <para>
            Prímszám az a természetes szám, amely csak önmagával és eggyel 
            osztható. Eukleidész görög matematikus már Krisztus előtt tudta, 
            hogy végtelen sok prímszám van, de ma sem tudja senki, hogy 
            végtelen sok ikerprím van-e. Két prím ikerprím, ha különbségük 2.
        </para>
        <para>
            Két egymást követő páratlan prím között a legkisebb távolság a 2, 
            a legnagyobb távolság viszont bármilyen nagy lehet! Ez utóbbit 
            könnyű bebizonyítani. Legyen n egy tetszőlegesen nagy szám. 
            Akkor szorozzuk össze n+1-ig a számokat, azaz számoljuk ki az 
            1*2*3*… *(n-1)*n*(n+1) szorzatot, aminek a neve (n+1) faktoriális, 
            jele (n+1)!.
        </para>
        <para>
            Majd vizsgáljuk meg az a sorozatot:
        </para>    
        <para>
            (n+1)!+2, (n+1)!+3,… , (n+1)!+n, (n+1)!+ (n+1) ez n db egymást követő azám, ezekre (a jól ismert
            bizonyítás szerint) rendre igaz, hogy            
        </para>    
        <itemizedlist>
            <listitem>
                <para>(n+1)!+2=1*2*3*… *(n-1)*n*(n+1)+2, azaz 2*valamennyi+2, 2 többszöröse, így ami osztható kettővel</para>
            </listitem>
            <listitem>
                <para>(n+1)!+3=1*2*3*… *(n-1)*n*(n+1)+3, azaz 3*valamennyi+3, ami osztható hárommal</para>
            </listitem>
            <listitem>
                <para>...</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n-1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n-1)*valamennyi+(n-1), ami osztható (n-1)-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+n=1*2*3*… *(n-1)*n*(n+1)+n, azaz n*valamennyi+n-, ami osztható n-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n+1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n+1)*valamennyi+(n+1), ami osztható (n+1)-el</para>
            </listitem>
        </itemizedlist>
        <para>
            tehát ebben a sorozatban egy prim nincs, akkor a (n+1)!+2-nél 
            kisebb első prim és a (n+1)!+ (n+1)-nél nagyobb első 
            prim között a távolság legalább n.            
        </para>    
        <para>
            Az ikerprímszám sejtés azzal foglalkozik, amikor a prímek közötti 
            távolság 2. Azt mondja, hogy az egymástól 2 távolságra lévő prímek
            végtelen sokan vannak.
        </para>    
        <para>
            A Brun tétel azt mondja, hogy az ikerprímszámok reciprokaiból képzett sor összege, azaz
            a (1/3+1/5)+ (1/5+1/7)+ (1/11+1/13)+... véges vagy végtelen sor konvergens, ami azt jelenti, hogy ezek
            a törtek összeadva egy határt adnak ki pontosan vagy azt át nem lépve növekednek, 
            ami határ számot B<subscript>2</subscript> Brun konstansnak neveznek. Tehát ez
            nem dönti el a több ezer éve nyitott kérdést, hogy az ikerprímszámok halmaza végtelen-e? 
            Hiszen ha véges sok van és ezek
            reciprokait összeadjuk, akkor ugyanúgy nem lépjük át a B<subscript>2</subscript> Brun konstans értékét, 
            mintha végtelen 
            sok lenne, de ezek már csak olyan csökkenő mértékben járulnának hozzá a végtelen sor összegéhez, 
            hogy így sem lépnék át a Brun konstans értékét.     
        </para>
        <para>
            Ebben a példában egy olyan programot készítettünk, amely közelíteni próbálja a Brun konstans értékét.
            A repó <link xlink:href="../../../bhax/attention_raising/Primek_R/stp.r">
                <filename>bhax/attention_raising/Primek_R/stp.r</filename>
            </link> mevű állománya kiszámolja az ikerprímeket, összegzi
            a reciprokaikat és vizualizálja a kapott részeredményt.
        </para>
        <programlisting language="R">
<![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>

library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]>
        </programlisting>        
        <para>
            Soronként értelemezzük ezt a programot:
        </para>                
        <programlisting language="R">
<![CDATA[ primes = primes(13)]]>
        </programlisting>        
        <para>
            Kiszámolja a megadott számig a prímeket.             
        </para>
        <screen>
<![CDATA[> primes=primes(13)
> primes
[1]  2  3  5  7 11 13
]]>
        </screen>
                
        <programlisting language="R">
<![CDATA[ diff = primes[2:length(primes)]-primes[1:length(primes)-1]]]>
        </programlisting>        
        <screen>
<![CDATA[> diff = primes[2:length(primes)]-primes[1:length(primes)-1]
> diff
[1] 1 2 2 4 2
]]>
        </screen>        
        <para>
            Az egymást követő prímek különbségét képzi, tehát 3-2, 5-3, 7-5, 11-7, 13-11.
        </para>
        <programlisting language="R">
<![CDATA[idx = which(diff==2)]]>
        </programlisting>        
        <screen>
<![CDATA[> idx = which(diff==2)
> idx
[1] 2 3 5
]]>
        </screen>              
        <para>
            Megnézi a <varname>diff</varname>-ben, hogy melyiknél lett kettő az eredmény, mert azok az ikerprím párok, ahol ez igaz.
            Ez a <varname>diff</varname>-ben lévő 3-2, 5-3, 7-5, 11-7, 13-11 külünbségek közül ez a 2., 3. és 5. indexűre teljesül.
        </para>
        <programlisting language="R">
<![CDATA[t1primes = primes[idx]]]>
        </programlisting>  
        <para>
            Kivette a primes-ból a párok első tagját. 
        </para>
        <programlisting language="R">
<![CDATA[t2primes = primes[idx]+2]]>
        </programlisting>        
        <para>
            A párok második tagját az első tagok kettő hozzáadásával képezzük.
        </para>
        <programlisting language="R">
<![CDATA[rt1plust2 = 1/t1primes+1/t2primes]]>
        </programlisting>        
        <para>
            Az 1/t1primes a t1primes 3,5,11 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t1primes
[1] 0.33333333 0.20000000 0.09090909
]]>
        </screen>                      
        <para>
            Az 1/t2primes a t2primes 5,7,13 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/t2primes
[1] 0.20000000 0.14285714 0.07692308
]]>
        </screen>                      
        <para>
            Az 1/t1primes + 1/t2primes pedig ezeket a törteket rendre összeadja.
        </para>
        <screen>
<![CDATA[> 1/t1primes+1/t2primes
[1] 0.5333333 0.3428571 0.1678322
]]>
        </screen>                      
        <para>
            Nincs más dolgunk, mint ezeket a törteket összeadni a 
            <function>sum</function> függvénnyel.
        </para>
        
        <programlisting language="R">
<![CDATA[sum(rt1plust2)]]>
        </programlisting>    
        <screen>
<![CDATA[>   sum(rt1plust2)
[1] 1.044023
]]>
        </screen>            
        <para>
            A következő ábra azt mutatja, hogy a szumma értéke, hogyan nő, egy határértékhez tart, a 
            B<subscript>2</subscript> Brun konstanshoz. Ezt ezzel a csipettel rajzoltuk ki, ahol először a fenti 
            számítást 13-ig végezzük, majd 10013, majd 20013-ig, egészen 990013-ig, azaz közel 1 millióig.
            Vegyük észre, hogy az ábra első köre, a 13 értékhez tartozó 1.044023.
        </para>
        <programlisting language="R">
<![CDATA[x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")]]>
        </programlisting>          
        <figure>
            <title>A B<subscript>2</subscript> konstans közelítése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrunKorok.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <para>
          Az nbatfai program C++-ban bitset-tel. (Bitset miatt compile time tudnunk kell N-et.)
        </para>
        <programlisting language="c" linenumbering="numbered">
          <textobject><textdata fileref="Turing/primes.cpp"/></textobject>
        </programlisting>
        <figure>
            <title>Az c++ B<subscript>2</subscript> konstans közelítés eredményei</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/brun.png" scale="100" />
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/VkMFrgBhN1g">https://youtu.be/VkMFrgBhN1g</link>
                    </para>    
                </listitem>                
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/aF4YK6mBwf4">https://youtu.be/aF4YK6mBwf4</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>
    <section>
      <title>Minecraft csiga</title>
      <para>
        Csinálj csigaként körbe-körbe menő mozgást Malmo-ben! (És éld túl, hogy lehal a géped, mert túlmelegszik.)
      </para>
      <para>
          Megoldás videó: <link xlink:href="">No link</link>
      </para>
      <para>
          Megoldás forrása:
          <itemizedlist>
              <listitem>
                <para><link xlink:href="">Folyamatos mozgásos csiga xml</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="">Folyamatos mozgásos kód</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="">Diszkrét mozgásos csiga xml</link></para>
              </listitem>
              <listitem>
                <para><link xlink:href="">Diszkrét mozgásos csiga kód</link></para>
              </listitem>
          </itemizedlist>
      </para>
      <para>
          Az első részfeladat folyamatos mozgás esetéről szól. Itt semmi feedback nincs (pl.: PID kontroll), simán váltogatjuk hogy az ágens forduljon-e vagy sem. 
      </para>
      <programlisting language="python" linenumbering="numbered">
        <textobject><textdata encoding="UTF-8" fileref="Turing/turning.py"/></textobject>
      </programlisting>           
      <para>
          A második részfeladat diszkrét mozgás esetéről szól. Itt például megemlíthetjük, hogy a 3x3x3-as "látótér adatokat" egy vektorban kapjuk meg.
      </para>
      <programlisting language="python" linenumbering="numbered">
        <textobject><textdata encoding="UTF-8" fileref="Turing/gridaccessor.py"/></textobject>
      </programlisting> 
      <para>
        Egy másik érdekes dolog, hogy az összes observation adat-ot egy string-ben kapjuk, amit json formában kell parseolni, majd ennek különböző fieldjeit nézegethetjük.
      </para>
      <programlisting language="python" linenumbering="numbered">
        <textobject><textdata encoding="UTF-8" fileref="Turing/observationadapter.py"/></textobject>
      </programlisting> 
      <para>
        Utolsó sorban, pedig waypointokat generálunk kifele növekevő spirál alakban. Az ágens a waypoint iter által számított legújabb waypointot közelíti, majd egy bizonyos hibahatáron belül, úgy tekinti elérte és kér újat.
      </para>
      <programlisting language="python" linenumbering="numbered">
        <textobject><textdata encoding="UTF-8" fileref="Turing/wpiter.py"/></textobject>
      </programlisting> 
  </section> 
</chapter>                
