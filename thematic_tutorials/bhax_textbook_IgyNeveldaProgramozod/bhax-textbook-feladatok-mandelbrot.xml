<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            A Mandelbrot halmaz számításához egy kis matekra lesz szükség. Nagyon vizualizációba most nem fogunk kód oldalról belemenni, mert egy másik alfejezet pont erről fog szólni...
        </para>
<literallayout>
z[0] = 0
z[1] = z[0]^2+c
z[2] = z[1]^2+c
...
z[n] = z[n-1]^2+c 
</literallayout>
        <para>
          Azaz mindig 0, 0 pontból indulunk, majd négyzetét vesszük és egy konstans számot hozzáadunk. Nézzünk pár esetet! Az ábrákon valós tengely vízszintes, míg képzetes függőleges. Az ábrán piros X-el jelöltem a konstanst és az step-eket fekete pontokkal (össze is kötöttem őket).
        </para>
        <figure>
            <title>c = {0,0}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep00.png" scale="100" />
                </imageobject>
                <textobject>
                    <phrase>c = {0,0}</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <figure>
            <title>c = {0.3 ,0}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep01.png" scale="100" />
                </imageobject>
                <textobject>
                    <phrase>c = {0.3 ,0}</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <figure>
            <title>c = {0.3 ,0.1}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep02.png" scale="100" />
                </imageobject>
                <textobject>
                    <phrase>c = {0.3 ,0.1}</phrase>
                </textobject>
            </mediaobject>
        </figure>
         <figure>
            <title>c = {0.3 ,0.2}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep03.png" scale="100" />
                </imageobject>
                <textobject>
                    <phrase>c = {0.3 ,0.2}</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
         Ha a konstant például 0.3, 0.7 akkor nagyon gyorsan "elszáll" az érték.
        </para>
        <figure>
            <title>c = {0.3 ,0.7}</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelstep08.png" scale="100" />
                </imageobject>
                <textobject>
                    <phrase>c = {0.3 ,0.7}</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
          Mit is csináltunk tulajdonképpen? Nos, rögzítettük 0,3 re értéket, és elkezdtük "pásztázni" im értékeket 0,1-es lépés közzel.
          A kódban is ezt fogjuk csinálni, csak minden pásztázott ponthoz (re im pár) rögzíteni fogjuk mennyi iteráció után kerültek ki az origó 2 sugarú köréből. 
          Azért hogy ne fusson a végetelenségig, ezért az iterációknak lesz egy teteje.
          Azaz ha a max iter számot elérjük akkor meg fogunk állni.
        </para>
        <para>
          A user megad egy re alsó és felső határt (mettől meddig pásztázunk Re tengelyen), illetve ugyanezt Im tengelyen.
          A lépésszám állítható is lenne, de mivel a legvégén terminálra akarunk írni, ezért ettől most eltekintünk.
        </para>
        <para>
          Tanár Úrtól eltérően én feldaraboltam a kódot, de csak azért hogy egyszerűbb legyen bemutatni.
        </para>
        <para>
          Az első kód részlet egy olyan funkció, aminek adunk egy komplex konstanst és egy max iter számot, és ez a fent bemutatott algoritmust végigcsinálja.
          A visszaadott érték az iter szám. Ha ez alacsony akkor nagyon gyorsan elszállt a számítás, ha magas akkor sokáig stabil volt.
        </para>
<literallayout>
int mandel(
    float c_re, 
    float c_im, 
    int max_iter)
{
  int i = 0;
  float temp=0.0, z_re=0.0, z_im=0.0;
  while ( ( ((z_re*z_re)+(z_im*z_im)) &lt; 4.0 ) &amp;&amp; ( i &lt; max_iter ) )
  {
    temp =(z_re*z_re)-(z_im*z_im)+c_re;
    z_im = 2.0*(z_re*z_im)+c_im;
    z_re=temp;
    i++;
  }
  return i;
}
</literallayout>
        <para>
          A második kód részlet már csak boilerplate kód.
          Erősen átírtam Tanár Úréhoz képest, direkt hogy int**-t használjunk.
          A másik dolog, hogy Tanár Úré valami miatt a második for bodyban számolja c reál és imaginárius részét is érthetőség miatt, én ezt egy picit optimáltam.(elég a külsőben számolni az egyiket)
          Annyi történik, hogy végig járjuk a kapott rácsot és kitöltögetjük, hogy melyik komplex konstans-hoz mennyi iter tartozik.
        </para>
<literallayout>
void apply_mandel(
    int** quad_mx, 
    int re_size, 
    int im_size,
    float re_lo, 
    float re_hi, 
    float im_lo, 
    float im_hi, 
    int max_iter)
{
  
  int re_step,im_step,itercount;
  float d_re,d_im,c_re,c_im;
  if(quad_mx == NULL || re_size &lt; 1 || im_size &lt; 1) return;
  d_re = (re_hi-re_lo)/re_size;
  d_im = (im_hi-im_lo)/im_size;
  for(re_step = 0; re_step &lt; re_size;++re_step){
    c_re = re_lo + d_re * re_step;
    for(im_step = 0; im_step &lt; im_size;++im_step){
      c_im = im_hi - d_im * im_step;
      itercount = mandel( c_re,c_im,max_iter);
      quad_mx[re_step][im_step]=mandel( c_re,c_im,max_iter);
    }
  }
}
</literallayout>
        <para>
          A harmadik rész maga a main. Csak beolvassuk a usertől mely határok között számoljunk, illetve deklaráljuk initeljük az int ptr ptr-t, plusz a végén feltakarítunk.
        </para>
    <programlisting language="c" linenumbering="numbered">
    <textobject><textdata fileref="Mandel/mandel.c"/></textobject>
  </programlisting>
        <figure>
            <title>A Mandelbrot halmaz win, csak iter számok</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelnums.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz win, csak iter számok</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <figure>
            <title>A Mandelbrot halmaz win, színes</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel0.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz win, színes</phrase>
                </textobject>
            </mediaobject>
        </figure>
         <figure>
            <title>A Mandelbrot halmaz win, színes, határ állítás</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel1.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz win, színes, határ állítás</phrase>
                </textobject>
            </mediaobject>
        </figure>
        

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>        
A <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link> pontban vázolt
ismert algoritmust valósítja meg a repó <link xlink:href="../../../bhax/attention_raising/Mandelbrot/3.1.2.cpp">
                <filename>bhax/attention_raising/Mandelbrot/3.1.2.cpp</filename>
            </link> nevű állománya.
        </para>
        
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }

  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>        
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            A biomorfokra (a Julia halmazokat rajzoló bug-os programjával) 
            rátaláló Clifford Pickover azt hitte természeti törvényre 
            bukkant: <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link> (lásd a 2307. oldal aljától).
        </para>       
        <para>
            A különbség a <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link>
            és a Julia halmazok között az, hogy a komplex iterációban az előbbiben a c változó, utóbbiban pedig állandó. 
            A következő Mandelbrot csipet azt mutatja, hogy a c befutja a vizsgált összes rácspontot.
        </para>       
        <programlisting language="c++">
<![CDATA[  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }
]]>
        </programlisting>        
        <para>
            Ezzel szemben a Julia halmazos csipetben a cc nem változik, hanem minden vizsgált
            z rácspontra ugyanaz.
        </para>
        <programlisting language="c++">
<![CDATA[    // j megy a sorokon
    for ( int j = 0; j < magassag; ++j )
    {
        // k megy az oszlopokon
        for ( int k = 0; k < szelesseg; ++k )
        {
            double reZ = a + k * dx;
            double imZ = d - j * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {
                z_n = std::pow(z_n, 3) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
]]>
        </programlisting>                         
        
        <para>
            A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para>       
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }

    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>                                 
                                          
                                                                            
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518</link>
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
