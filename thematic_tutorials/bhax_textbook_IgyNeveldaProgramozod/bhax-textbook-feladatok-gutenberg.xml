<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
      <title>Programozási Alapfogalmak</title>
     <!-- SUBSECTION -->
    <section>
      <title>Gépi kód, assembler, magasabb szintű nyelvek</title>
      <para>         
        Mielőtt beszélünk a típusokról nézzünk egy nem típusos nyelvet! A <citation>NANDTOTETRIS</citation>-hez írtunk egy c++ interpreter jellegű programot, mely úgy viselkedik mintha egy vlós CPU lenne(csak jóval egyszerűbbek az opcode-ok).
        A lényeg, hogy 2 regiszter van. A és D. A "Adress" ugyanis a jump-ok mindig az A-ban lévő értékű címre ugranak. D "Data" register pedig egy "sima" regiszter. "A" regiszterrel a trükközés azért kell, mert így borzasztóan egyszerűve válnak az opcode-ok.
        0-kat és 1-eseket nem akarunk írni, ezért írtunk rá egy assemblert.
        Alább látható egy szuper egyszerű assembly kód erre a teljesen minimalista kis gépre. 
      </para>
<literallayout>
@2
D=A
@3
D=D+A
@0
M=D
</literallayout>
      <para>         
        Direkt a fenti egyszerűbbet mert látható a példán egy gcc -S -el készült sima main-ből ez lesz a körítés miatt.
      </para>
      <programlisting language="c" linenumbering="numbered">
        <textobject><textdata fileref="cbook/assemblyexample.txt"/></textobject>
      </programlisting>
      <programlisting language="c" linenumbering="numbered">
        <textobject><textdata fileref="cbook/chip.hdl"/></textobject>
      </programlisting>
        <para>         
          A lényeg, hogy az assembler (label és egyéb dolgok mellett) elsősorban azt a célt szolgálja, hogy a fenti szöveg átforduljon bytecode-ra.
          Alább látható a fordított gépikód.
        </para>
<literallayout>
0000000000000010
1110110000010000
0000000000000011
1110000010010000
0000000000000000
1110001100001000
</literallayout>
      <para>         
        Sajnos, el kellett engednem a teljes leírást, mert egyszerűen nincs rá idő, de komolyan ajánlom mindenkinek a <citation>NANDTOTETRIS</citation>-t.
        Alább például látszik egy szuper bugyuta kis ALU. Akármennyire bugyuta és tele van csalással a lényeg, hogy közelebb visz a szoftver és hardware találkozásához, ahol az igazi varázslat történik. (Hisz papíron ugyan Gödel megcsinálta, de sok idő kellett mire mindekinek lett macskáskép nézegetője.)
        Másrészről nincs jobb érzés, mint amikor megcsinálja az ember a kapukat, majd ráküldi a kódot és megtudja vele csinálni a "for"-t!
        Tényleg fáj a szívem hogy nincs módom berakni a doksiba. De őszintén ajánlom a könyvet, mert valójában az NEM EGY KÖNYV. Minden fejezet egy minimális elméleti alapozó és utána szuper egyértelmű task-ok vannak, TESZTEKKEL és platformmal együtt. Annyi, hogy én nem szeretem a Java-t mert az Oracle gonosz, ezért csak az assembler-es részt rossz minőségű c++-ban reprodukáltam a <link xlink:href="https://github.com/rkeeves/bhax-derived/blob/master/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Gutenberg/hack">ide</link>.
      </para>
      <para>         
            Ha valakit abszolút nem érdekel a dolog, akkor is egyszer javaslom, csak amiatt, hogy átérezzük, hogy mennyire komoly segítséget adnak a mérnökinfósok és villamos mérnökök nekem illetve nekünk.
      </para>
      <para>         
        Ha pedig valakit a mérnökinfósok sem érdekelnek és nem szeret olvasni, legalább vessen egy pillantást <link xlink:href="https://youtu.be/cgVVZMfLjEI?t=1925">erre</link>.
      </para>
      <para>         
          Nincsenek típusok, minden "szó" N menyiségű bitből álló rendezett 16-os. Műveleteket nem definiálhatunk magunk, hisz azt a CPU csinálja.
        </para>
        <para>         
          Innentől kezdve bármit tanulunk emlékezzünk arra, hogy hasonló lesz a vége. (Persze a valóságban jóval összetettebb, de 1-esek és 0-k lesznek a legadvancedebb cpp kódból a nap végén.)
        </para>
        <para>         
          A típus megadja a gépnek hogy mikor írtunk egy programot és ráengedjük a lexert, parsert, compilert vagy interpretert akkor mit fogadjon el egyáltalán.
          Azaz hogy milyen elemei lehetnek. Azaz a típus egy halmazként is felfogható, melynek elemei a lehetséges értékek.
          Halmazoknál ugye felsorolhatjuk, de akár ha pro-k vagyunk szabályokkal is megadhatjuk (emlékezzünk a természetes számok halmazán successor-ra, vagy akár a modulo kongruencia osztályokra egészeknél)
        </para>
        <para>         
          A típus megadja a gépnek hogy milyen műveleteket és hogyan kell végezni.
          Például egy bool-t ha negálunk más történik, mintha egy int-et. Sőt, sokszor nem is lehet bizonyos dolgokat értelmezni, például Várterész Tanárnő nem nagyon szorozgatott igaz-t hamis-sal (majd később belemegyünk a szorzásba, most simán csak gondoljunk gyerekkorunkban tanultakra).
        </para>
        <para>         
          A típus megadja a gépnek hogy hogyan kell interpretálni az adatot. Például gondoljunk egy egyszerű C struct-ra, van két char fieldje "foo" és "bar". Elrakjuk valahova a memóriába (és tároljuk a címét), majd kis idő múlva kellene az "b" field. Honnan fogjuk tudni, hogy a sok bit közül hol kezdődnek a "b" field bitjei illetve, hogy hány bitből is áll?
          Például erre (is) ad válazt a primitív char típus.
        </para>
        <para>         
          Amit még nagyon fontos lefektetni, az az hogy inheritance, primitív típus, template mind csak fluff és eyecandy a CPU szempontjából. Előbb utóbb mindenből 0101 0011 1111 0000 lesz. Igen igen 32 64, plusz valójában nem egy szó kerül be stb. de a lényeg hogy mindent számokra képezünk le. Az összes többi dolog csak és kizárólag azért kell, mert az ember biológiailag nem 0 és 1 olvasásra és nagy sebességű aritmetikai műveletek elvégzésére fajlődött hanem az ágakon tekergő kígyók elől való elugrálásra.
        </para>
        <para>         
          A tankönyv említi hogy forrásszöveget írunk, amelyből aztán két mágiával lehet gépi kód. Compiler-es és interpreter-es. Ez a valóságban sajnos nem ilyen egyértelmű. Nézzünk például egy Java-s példát. Igen compiled, de...mégis a VM stack machine-en fut. A stack machine csak egy absztrakció, nem a tiszta vas. Ez is a középpontja az Java azon ígéretének mi szerint "write once, run before Oracle sues you for using VM without paying your subscription for server side usage".
        </para>
        <para>         
          Másik Java példa: Project Lombok. Fel annotáljuk meta nyelven a forrás szöveget, és a class file-ba belegeneráljuk a boilerplate code-ot, anélkül, hogy telenyomnánk vele a source-t.
        </para>
        <para>         
          Másik Java példa: Spring, xml vagy reflection (annotation) based meta adatok. Igen a forrás fájl része, de egy framework használja az adatokat...
        </para>
        <para>         
          És a akkor a kedvencem: Írok egy progit C-ben. Mondjuk egy macskáskép játék. A business logic-ot direkt C helyett Lua-ban írom, magyarul a C programom tartja számon a Lua state-t. A programom compiled, viszont ha a lua szkriptet változtatom alatta akkor gond nélkül hot swappelhetem mondjuk szerver oldalon. Most akkor része a business logic a programomnak? Vagy a programom egy hyper program ami önmaga nem a macskás játék? De hát a grafikus funkciók C-ben vannak írva? A lényeg, hogy nem ilyen egyértelmű a dolog.
        </para>
        <para>
          Arról pedig már ne is beszéljünk, amit egy JIT compiler egy átlagos hétfő délután csinál.
        </para>
      
        <para>         
          A tankönyv ezután belemegy a fordító programok világába. Ez ahogy láttuk nem egy merev dolog, de ennél még rosszabb is történhet. Egyes "compiler"-ek azért vannak hogy C-kódot generáljanak valami deklaratív jellegű nyelvből. De ennél még rosszabb, hogy van aminek az a célja hogy C kódot fordítson Javascriptre.
          A fordítás általános feladatai a tankönyv szerint a következőek:
          <itemizedlist>
            <listitem>
                <para>lexikális elemzés</para>
            </listitem>
            <listitem>
                <para>szintaktikai elemzés</para>
            </listitem>
            <listitem>
                <para>szemantikai elemzés</para>
            </listitem>
            <listitem>
                <para>kódgenerálás</para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          A könyv kiemeli, hogy lehet szó előfordítókról. 
          Most egy tanulságos történet: Java spring-based web server. 
          Hibernate előtti időszak, szóval perzisztenciát from scratch. 
          Amerikaiak úgy döntöttek, hogy egy perzisztens class-t annotációkkal fognak "dekorálni" (ez akkor még nagy szó volt, mert ez még az xml config-os spring era), 
          és technikai okokból, ha ez megtörtént, az annotációkban megjelölt információk alapján a SUPER class auto generálni fogjuk. 
          Igen <literal>Derived extends Base</literal> és Base még nem volt kész, hanem Derived alapján jött létre "automatán" a Derived annotált source kód alapján.
          Például olyan célt szolgált, hogy a null check-ek validálások, propertyeventchanged küldések stb. ne kézzel íródjanak.
          <link xlink:href="https://www.ptc.com/en/products/plm/plm-products/windchill">Ő az</link>. Az már egy másik cseresznye a tortán, hogy nem a hétköznapi módon csináltak Product táblát, Employee táblát stb., 
          hanem például TypeIdentifier, AttributeTypeIdentifier és hasonló táblák voltak, azaz runtime lehetett új "típusokat" létrehozni, úgy hogy ezek nem csak a field-eket örökölték, hanem viselkedést is (igen a munka nagyrésze az application layerben ment).
          </para>
          <para>A könyv kitér rá, és tényleg nagyon fontos a linker. Egyébként így elsőre prog 1-ből az lesz az előnye, hogy nem kell mindig az egészet újra fordítani. Persze ha nem kell mindig újra fordítani. Persze a compile-olgatásnak és linkelgetésnek is meg van a maga ára. Például ha ritkán változó dologról van szó, akkor lehet precompiled header-ekkel dolgozni.</para>
          <para>Na jó...de mi ez az egész linkelés? Pl. C++ esetén a compilation unit Foo, illetve van egy FooMain-ünk ahol használjuk. Külön külön fordítjuk, és ha minden rendben akkor végül együtt kell működniük majd, tehát linkelésnél valamilyen módon a FooMain beli használathoz társítani kell a Foo beli implementációt. A szerződés az együttműködésre Foo.hpp.</para>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/Foo.hpp"/></textobject>
          </programlisting>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/Foo.cpp"/></textobject>
          </programlisting>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/FooMain.cpp"/></textobject>
          </programlisting>
          <figure>
              <title>Foo és Foo Main</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/foocompile.png" scale="100" />
                  </imageobject>
                  <textobject>
                      <phrase>Foo és Foo Main</phrase>
                  </textobject>
              </mediaobject>
          </figure>
          <para>
          Na jó... de mi történik, ha megváltozik az a field? Mi van ha kifele int-et mutatok, de valójában másképp akarom tárolni?
          </para>
          <para>
          Amíg a hpp változatlan addig azt csinálok implementációban amit akarok!
          </para>
          <para>
          De...szóval mi van ha esetleg az a implementációjához akarok hozzányúlni. Bad luck! Hpp-t módosítani kell és akkor már nem tudnak ellened linke...VÁRJUNK CSAK!
          </para>
          <para>
          Egy kis trükközéssel encapsulating kivitelezhető ezen kívánságra is, csak kompozíciót kell alkalmazni és egy struct-ba wrappelni amit rejteni kívánunk.
          </para>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/FooABI.hpp"/></textobject>
          </programlisting>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/FooABI.cpp"/></textobject>
          </programlisting>
          <programlisting language="c" linenumbering="numbered">
            <textobject><textdata fileref="cbook/FooABIMain.cpp"/></textobject>
          </programlisting>
          <figure>
              <title>FooABI és FooABI Main</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/fooabicompile.png" scale="100" />
                  </imageobject>
                  <textobject>
                      <phrase>FooABI és FooABI Main</phrase>
                  </textobject>
              </mediaobject>
          </figure> 
          <para>A nevekben felfedezhető ABI az <literal>Application Binary Interface</literal> szóra utal. Erről most nem írok részletesen, de mint ahogy az <literal>Application Programming Interface</literal> azaz API jó ha konzisztens tud maradni például egy library különböző verziói között, addig a gép számára hasonlóan jó dolog ha az ABI nem változik.</para>
          <para>A tankönyvet régen írták, de igen, továbbra is nagyon fontos hogy ki hogyan és mihez kapcsolódik, viszont mivel telt múlt azóta az idő, vannak új trükkök!</para>
          <para>A betöltés egy nagyon fontos dolog. Miért is? A gépekben az adat, az eljárás és a macskás képek nem különülnek el. Minden adat. Vicces túlzással élve a számítógép valójában egy ipari lyukasztó gép amit, nos lényegében lyukasztott kártyákkal programozunk, innentől kezdve ő kilyukasztja az utasítás kártyát ha kell, és ha kell lefuttatja a kilyukasztott végterméket egyaránt ha beadjuk neki. Számára lyuk-lyuk egyre megy.</para>
          <para>Betöltés</para>
          <para>C++, C, Java oldalról nehéz megérteni a betöltést. Nézzük assemblyvel egy egyszerű példán:</para>
<literallayout>
   @0
   D=M
   @INFINITE_LOOP
   D;JLE 
   @counter
   M=D
   @SCREEN
   D=A
   @address
   M=D
(LOOP)
   @address
   A=M
   M=-1
   @address
   D=M
   @32
   D=D+A
   @address
   M=D
   @counter
   MD=M-1
   @LOOP
   D;JGT
(INFINITE_LOOP)
   @INFINITE_LOOP
   0;JMP
</literallayout>
    <para>A lényeg, hogy van egy LOOP label-em. Ez egy hely a kódban ahova ugorhatok. Hogy ugrom oda? Long story short <literal>@LOOP</literal>-al betárolom LOOP helyét majd   <literal>JGT</literal>-vel ugrom.</para>
    <para>Ok. Pszeudokódban megy, de...Mennyi is a LOOP label címe? Mármint konkrétan nekem kellene, hogy az most akkor 0111 0111 0111 1111? Honnan tudom?</para>
    <para>Naív válasz: Oké, 0 memória címre lesz betöltve a programom, szóval simán kiszámolom hogy az @address(hisz oda fogok ugrani, mert a LOOP az csak egy sajtos papír "tag", tag alatt az angol tag-et értem)</para>
    <para>Ez egy tökéletes megoldás lehet Nintendo-n, vagy nem tudom... valami ROM-on!</para>
    <para>De akkor mi van, ha én nem oda kerülök, hanem mondjuk már előttem vannak dolgok, mondjuk egy macskáskép sokszorosító?</para>
    <para>Egyszerű megoldás: Akkor derüljön ki LOOP értéke, mikor én elhelyezésre kerülök! Zseniális!</para>
    <para>Viszont...nos, innentől kezdve én elmozdíthatatlan vagyok! Pontosabban elmozdíthatnak, de mivel a LOOP egy konkrét érték, ezért ha arébb raknak, akkor rossz területre fog hivatkozni.</para>
    <para>És akkor például itt jöhetnek trükkös megoldások a cím újra számításra, vagy esetleg arra, hogy én ne direktbe hivatkozzak egyenesen a fizikai címre, hanem magamhoz képest relatív.</para>
    <para>Java esetben ez másképp van hiszen egy stack machine-be pakolunk dolgokat, ami az Oracle szerint write once run...</para>
    <para>Persze a VM egyébként egy <link xlink:href="https://youtu.be/JvBT4XBdoUE?t=1126">nagyon jó dolog</link>. Vagy például az eve online <link xlink:href="https://www.eveonline.com/">Stackless Python</link>-t használ ami egyébként ugyanúgy a unmutabilityt választotta, hasonlóan az Erlang-hoz</para>         
    <para>Interpreternél ugye nincs szükség ekkora hercehurcára, kivéve ha van szükség. Mármint például egyes interpretált nyelveknél direkt egy előfordított formába rkhatjuk a szkriptet és akkor kicsit gyorsítani tudunk a dolgokon.</para>
    <para>Interpreteres esetekben persze mindig ott a lehetőség, hogy a CPU intenzív dolgokat natívba rakjuk. Pl. a <link xlink:href="https://www.klei.com/games/dont-starve">dont starve</link> esetén Lua intézi az üzleti logikát, ami az állatok párzási időszakban erősödő agressziójáért felelős, de a grafika, fizika, collision C/C++ oldalon van tartva. Azért nem mondok tiszta Cpp-t, mert Lua raw c ptr-eket fogad, illetve C-s callbackek szolgálnak hook-ként a lifecycle eventekre (magyarul ha a Lua gc elakar takarítani valamit, és az egy küldő kódból származó raw ptr, akkor egy user defined c callback-et hív ezen ptr-el. Mi például itt tudjuk az átküldött címre hívni a destruktort explicit, utána visszakerül lua-nak az irányítás. Azért nincs free vagy delete, mert az is customizeable, azaz lehet például, hogy mi írunk alá memory managementet, mert folyamatosan az OS-től kérni apró chunkokat elég lassú.).</para>
    <para>Ezzel az egész résszel az volt a célom, hogy kifejezzem, hogy a könyv nagyon jó, de már régóta eltűntek azok az éles határok, illetve mivel nem láttam pontos definíciót ezért nehéz egyáltalán megtámadni is.</para>
    <para>Természetesen a lexikális elemzés során megtörténik a forrás szöveg lexikális egységekre történő bontása. Ez ma is így van.</para>
    <para>Egyébként viszont az is egy érdekes kérdés, hogy a Cpp type system az imperatív nyelvbe hogy kerül bele. Mármint arra a vicces dologra akarom felhívni a figyelmet, hogy mondjuk én egy extends-el egy abszolút nem imperatív dolgot csinálok, a type inference pedig...nos ennél kevésbé imperatív dolog nincs. Persze, igen, C-style cast.</para>
    <para>Most bele lehetne menni szárazon a BNF-be, de ennél aranyosabb a Q={"l","3","t",a++b | a,b eleme Q} Szóval <link xlink:href="https://youtu.be/dFexYse8UF0?t=234">l33t</link>, de Várterész Tanárnő egyébként szó szerint ilyen "elemzést végzett", amikor felírta az ábécét és a szabályokat.</para>
    <para>A szintaktikai szabályok kicsit hajlékonyak, például ha Tanárnő hiányzik, akkor emlékezzünk arra, hogy a <literal>-Wpedantic</literal>(pl: field initialization sorrend csak a deklarációs sorrendben megengedett) </para>
    <para>Imperatív nyelveknél a programozó mondja meg hogy hogyan, ezért tele van bugokkal. Mellette szól viszont, hogy <link xlink:href="http://judy.sourceforge.net/">gyorsabb kódot lehet így írni az elméletileg lehetségesnél</link> </para>
    <para>Deklaratív nyelveknék a programozó nem mondja meg hogyan. Emiatt nincs hiba. Technikailag. De természetesen abszolút nem az fog történi amire az ember gondol és sok szerencsét a Prolog debuggolással.</para>
    <para>Imperatív nyelvekhez még talán annyit, hogy...nos az OOP nagyon jó dolog. Bizonyos feladatokra. Folyamatos vessző paripám az <link xlink:href="https://github.com/alecthomas/entityx">ECS</link>. Nem ez nem egy nyelv, hanem egy megközelítési forma. Az egész arról szól hogy passzív adatstruktúráim vannak és a viselkedést megvalósító részeket megpróbálom (bár általában nehéz) állapot mentesíteni. Szerintem az OOP az emberi intuíciót és a problémákról történő gondolkodást elősegíti, de semmilyen bizonyíték nincs arra, hogy karbantartható codebase-hez vezet. (Például a <link xlink:href="http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/">Tony Hawk</link>) Vannak olyan nyelvek melyek az interface-t (vagy teljesen absztrakt class-t) preferálják, és kigyomlálták a hétköznapi java-ban burjánzó inheritance fákat, erdőket.</para>      
    <para>A forrás fájlunkban emberileg értelmezhető szöveget írunk karakterek felhasználásával. A nyelv amin írjuk egy megfelelő abécéből (Logika emlékszünk?) és ezek alkalmazási szabályaiból áll</para>
        <para>
        Lexikális egységek a következőek
          <itemizedlist>
            <listitem>
                <para>többkarakteres szimbólum</para>
                <para>Pl.: ++, --, azaz ahelyett hogy valami furcsa új szimbólumot használnánk technikailag több szimbólum együttese alkot együtt egy szimbólumot. Például gondoljunk arra, hogy egyszerű abécé betűkkel mondjuk csinálunk egy olyan nyelvet amibe kéne egzisztenciális kvantor, és azt találnánk ki, hogy az <literal>ee</literal> jelentse azt.</para>
            </listitem>
            <listitem>
                <para>szimbolikus név</para>
                <para>Azonosító, adott nyelv szintaktikai szabályai szerint olykor például kötelezően betűvel kezdődő karakter sorozat. A lényeg hogy ezt használjuk a dolgot elnevezésére. Azaz például egy változóra hog hivatkozzunk az azonosítóját írosgatjuk be a forrásszövege.</para>
                <para>Kulcs szó, a nyelv által védett, különös jelentősséggel bíró név. Például a <literal>for</literal> mely érezhetően ahhoz kell, hogy jelezzük, hogy ami utána jön abból valami loop jellegű dolog legyen. Turing fejezetben konkrétan a nyelvi spec-cel is foglalkoztunk optional-östől mindenesetül, ezért erre most nem térek ki.</para>
                <para>Standard azonosító, melynek a nyelv tulajdonít jelentést. Pl.: Null</para>
            </listitem>
            <listitem>
                <para>címke</para>
                <para>Ugráláshoz kell, hogy hova ugorjunk! Hogy mondjuk meg hova kéne ugorni, mindezt menedzselhetően? Adjunk egy címkét annak a sornak ahova ugorni akarunk! Fentebbi assembly kódban a loop-olás miatt láttunk labelt.</para>
            </listitem>
            <listitem>
                <para>megjegyzés</para>
            </listitem>
            <listitem>
                <para>literál</para>
                <para>Nyelv által megengedett szabályok szerinti karakterlánc mellyel konkrét értéket tudunk bevinni. Egzotikus példa a cpp14 szabványos bit megadásos 0b01101010.</para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Sorok fontossága szerint
          <itemizedlist>
            <listitem>
                <para>Kötött formátumú nyelvek</para>
                <para>Egy sor, egy utasítás. Legjobb példa az előbb már említett assembly (kis trükkel, hisz a label maga ugyan egy sor ott, de úgy írtam meg a parsert, hogy azt kikapja véglegesből hisz az csak meta adat :)</para>
            </listitem>
            <listitem>
                <para>Szabad formátumú nyelvek</para>
                <para>Ok, ha az új sor nem a vége a dolognak, akkor viszont meg kell valahol állni, ugye?! Nos ezt vagy explicit jelezzük pl. C, vagy khm... js!.</para>
            </listitem>
            
          </itemizedlist>
        </para>
    </section>
     <!-- SUBSECTION -->
    <section>
      <title>Adattípusok</title>
      <para>         
          (28) tartomány, műveletek, reprezentáció, egyszerű, összetett, mutató  
      </para>       
    <para>
      Típusok, röviden felfoghatóak: lehetséges értékek halmaza + halmaz elemeken értelmezhető műveletek + reprezentáció együttese ként.
          <itemizedlist>
            <listitem>
                <para>numerikus - pl.: (C)int, (C)float</para>
            </listitem>
            <listitem>
                <para>karakteres - pl.: (C)char</para>
            </listitem>
            <listitem>
                <para>karakterlánc - pl.: ezt általában nem igazi primitív, hanem a nyelv mellé adott alap library része, például Erlang-ban egyébként egy lista</para>
            </listitem>
            <listitem>
                <para>logikai - pl.: (C) bool</para>
            </listitem>
            <listitem>
                <para>felsorolásos - pl.: (C) enum</para>
            </listitem>
            <listitem>
                <para>sorszámozott - pl.: (Pascal) byte, word, int, ...</para>
            </listitem>
          </itemizedlist>
        </para>
        <para>         
          A nyelv által definiált egyszerű típusokból van lehetőség új strukturált típusok összerakására ezek az összetett típusok.
        </para>
        <para>         
          A típusnak pedig végül kell hogy legyen valami azonosítója, hogy tudjunk rá a későbbiekben hivatkozni.
        </para>
        <para>       
          A mutató típusról kicsit külön érdemes beszélni. A mutató egy tárbeli címre mutat vagy <link xlink:href="https://www.youtube.com/watch?v=YYkOWzrO3xg">NULL</link>-ra.
          Érdemes tudni, hogy a mutatott cím egyáltal milyen típus. Azaz a <literal>char* foo</literal> ptr típusú, viszont amire mutat azt char-ként fogja "interpretálni". Persze egy int-et tároló mem területre rámehetünk egy char ptr-rel gond nélkül.
        </para>
        </section>
         <!-- SUBSECTION -->
        <section>
          <title>A nevesített konstans</title>
          <para>         
              (34) név, típus, érték
          </para>
          <para>         
              Szerintem a könyvbeli preprocesszor-os példa technikailag nem igaz. Az hogy a preproceszor mit csinál már a Turing-os fejezetben bemutattam, plusz mutattam olyat is amikor makró alkalmaz makrót ami kódot injektál. Na egy ilyen esetben látszik hogy a preprocesszor csak egy "szövegszerkesztő" eszköz, nem a nyelv része, plusz úgy ütöm felül a a define-okat ahogy akarom.
          </para>
          <para>         
              Ellenben a <literal>const int = 6;</literal> egy konstans. típus, const qualifier, és értékadás, just like God intended.
              Ha már itt tartunk akkor itt a világ legmegbízhatóbb Java kódja, ami viszont olykor mégis hibát okozhat (assuming that it wont get optimized away): <literal>private static void foo(){};</literal>. He. He.
          </para>
        </section>
        <!-- SUBSECTION -->
        <section>
          <title>A változó</title>
          <para>         
              (35) név, attribútumok, cím, érték
          </para>
          <para>         
              A változóknak négy komponense van:
              <itemizedlist>
            <listitem>
                <para>név - pl.: user defined, scope-on belül egyedi</para>
            </listitem>
            <listitem>
                <para>attribútumok - pl.: típus, vagy qualifiers</para>
            </listitem>
            <listitem>
                <para>cím - stack, heap vagy manual</para>
            </listitem>
            <listitem>
                <para>érték - értékadás, itt annyit érdemes megjegyezni, hogy attól hogy létrehozom és kap címet, azt nem lehet várni hogy a tár tiszta legyen, úgyhogy érdemes lehet initelni.</para>
            </listitem>
            <listitem>
                <para>felsorolásos - pl.: (C) enum</para>
            </listitem>
            <listitem>
                <para>sorszámozott - pl.: (Pascal) byte, word, int, ...</para>
            </listitem>
          </itemizedlist>
          </para>
        </section>
         <!-- SUBSECTION -->
        <section>
          <title>Alapelemek az egyes nyelvekben</title>
      
          <para>(39) innen csak a C nyelves rész persze</para>
          <para>
            Aritmetikai típusok
            <itemizedlist>
              <listitem>
                  <para>integrális - egész (int, short[int], long[int]) : signed unsigned-ról már turingban írtam példával együtt </para>
              </listitem>
              <listitem>
                  <para>integrális - karakter (char)</para>
              </listitem>
              <listitem>
                  <para>integrális - felsorolásos (enum)</para>
              </listitem>
              <listitem>
                  <para>valós - (float, double, long double) </para>
              </listitem>
            </itemizedlist>
          </para>
          
          <para>
            Származtatott típusok
            <itemizedlist>
              <listitem>
                  <para>tömb</para>
                  <para>Memóriában garantáltan egymás mellé kerülő hasonló típusú értékek. Azért ilyen furcsán írtam le mert ez a lényeg.
                  Miért ez a lényeg? Nos, ha array-be tárolok valami akkor a cache miatt array-t nagyon gyorsan tudok "végig iterálni". Ez BORZASZTÓAN jól tud jönni.
                  Persze sajnos hátulütője, hogy előre tudni kell a hosszt amennyit foglalni akarunk...
                  </para>
              </listitem>
              <listitem>
                  <para>függvény </para>
              </listitem>
              <listitem>
                  <para>mutató </para>
                  <para>Architektúrától függő. Hossza pl. 64 bit, 32 bit. Ez egy sima egyszerű szám. 
                  Csak azáltal lesz különleges hogy általában a számot RAM hozzáférésre használjuk, de tényleg csak egy szám (főként void ptr esetén, hisz ott már nem cipel maga mellé meta adatként a mutatott adat típusát illető komoly információt).
                  Egyébként cpp-ben szoktuk nyers ptr-nek is nevezni, mert ma már csak akkor használjuk ha nagyon fontos.</para>
              </listitem>
              <listitem>
                  <para>struktúra </para>
                  <para>A user a meglévő típusokból (akár újonnan létrehozott structokból) rakhat össze újakat. Az ABI esetén említett struct-os kód példa bemutatja hogyan lehet abuzálni.</para>
              </listitem>
              <listitem>
                  <para>union </para>
                  <para>Ahelyett hogy beszélgetünk róla itt van valami production code-ból(random CAD program). Embrace the C!</para>
                  <programlisting language="c" linenumbering="numbered">
                    <textobject><textdata fileref="Gutenberg/union.c"/></textobject>
                  </programlisting>
              </listitem>
              <listitem>
                  <para>void </para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
       <section>
          <title>Kifejezések</title>
          <para>Kifejezésekkel a program egy adott pontján ismert értékekből újakat határozunk meg. 
                <literal>Értékük</literal> és <literal>típusok</literal> van.
          </para>
          <para>
            Formálisan operátorból, operandusokból és csoportosító jelekből állnak (pl. zárójel).
          </para>
          <para>
            Attól függgően hány operanduson történik, beszélhetünk unáry, binary, ternary stb. kifejezésekről. (Hehe funkcionális nyelveknél currying...)
          </para>
          <para>
            
          </para>
          <para>
            A kifejezések több fajta alakban leírhatóak. Suliban az egyiket szoktuk meg, a gépek meg egy másikat. :)
            <itemizedlist>
              <listitem>
                  <para>prefix</para>
                  <para>
                    (* 3 5 )
                  </para>
              </listitem>
              <listitem>
                  <para>infix</para>
                  <para>
                    ( 3 * 5 )
                  </para>
              </listitem>
              <listitem>
                  <para>postfix</para>
                  <para>( 3 5 * )</para>
              </listitem>
            </itemizedlist>
          </para>
          <para>
            Amikor a kifejezés értéke meghatározódik, azt kiértékelésnek is lehet nevezni, de Turing-ban adtam példát lambda kalkulusban normál formára hozásra. (Hisz a kiértékelés az, hogy normálformára hozzuk, ami lambdában nem mindig jelenti azt hogy pl. egy "számot" kapunk, lehet egy lambda absztrakció lesz a vége.)
          </para>
          <para>
            A műveletek végrehajtási sorrendje a következő lehet
            <itemizedlist>
              <listitem>
                  <para>felírási sorrend - balról jobbra</para>
              </listitem>
              <listitem>
                  <para>anti felírási sorrend - jobbról balra</para>
              </listitem>
              <listitem>
                  <para>precedencia alapján</para>
                  <para>Igen van olyan nyelv ahol magát a precedenciát is meg lehet adni...sőt ha két argunk van akkor infixben is lehet használni... De ez persze nem a C :)</para>
                  <para>Ha infixnél nem vagyunk biztosak abban hogy mi is lesz a sorrend, zárójelezzünk...</para>
              </listitem>
            </itemizedlist>
          </para>
          <para>
            Ahhoz hogy ki lehessen értékelni egy operátor alkalmazását operandusokon érdemes tudni az operandusokat. A C erről nem köt meg semmit szabványban.
          </para>
          <para>
            Ahol logikai kifejezések szerepelnek, ott rövidzárral nem feltétlenül fut le az egész, hisz az eredmény tudható anélkül is.
            Például egy vicces nyelv független példa:
          </para>
<literallayout>
TömbNemÜres ÉS TömbNulladikElemeÖt 
HAMIS ÉS ? = HAMIS 
</literallayout>
          <para>
            Fontos hogy a két operanduson lehet-e alkalmazni az operátort. Ahhoz hogy ezt eldöntsük kell a típus.
          </para>
          <para>
           Két programozási eszköz típusa azonos ha (...valóságban megint nem ennyire egyszerű de hadd menjen)
            <itemizedlist>
              <listitem>
                  <para>deklaráció egyenértékőség</para>
                  <para>egyszerre ugyanazzal a típussal deklarálódtak</para>
              </listitem>
              <listitem>
                  <para>név egyenértékőség</para>
                  <para>ugyanaz a típus név</para>
              </listitem>
              <listitem>
                  <para>struktúra egyenértékőség</para>
                  <para>összetett típusúak és szerkezetük megegyezik</para>
              </listitem>
            </itemizedlist>
          </para>
          <para>típuskényszerítéses nyelvnél ha különböző típusúak az operandusok, akkor type conversion lesz.
          Ilyen esetben a nyelv leszögezi hogy milyen konverziók történnek és hogyan.</para>
          <para>
            típus egyenértékűségnél megtörténhet de... most ugorjunk el a könyvtől. A lényeg a következő:
            Ezeket a nyelveket régen találták ki, de a következőről van szó: Van mondjuk A típus és B típus, ezek mind egy meta C típusba tartoznak és a művelet definiálva van a C-n, szóval B-n és A-n is menni fog (nem sima inheritance-re gondolok C superrel, inkább olyan jellegű mint pl. a Bácsó Tanár Úr által említett Abel csoport).
            Amiatt van ez a kernel panic a fogalom tárban mert amikor ezek a nyelvek születtek akkor nagyon gyorsan jöttek ki az új architektúrák int, aztán long int is kellett stb.
            Szóval inkább arra koncentráltak hogy polcra kerüljön a termék.
          </para>
          <para>
            Felfele cast-olni gond nélkül lehet(int->float), de lefele castolni(float->int) nem egyértelmű. Mármint nem csak annyi a kérdés, hogy befogok-e férni, hanem például ha A teljesen C "típusú" lenne akkor A "részhalmaza" lenne C-nek C pedig "A"-nak ez pedig nagyon nincs így.
            A tény hogy ez nincs normálisan formalizálva, nem customizeable csak builtin az arra enged következtetni, hogy még mindig van hova fejlődni.
          </para>
          <para>
            Konstans kifejezés (cpp-ben constexpr) compile time dől el. Ebből következik, hogy konstansokat vagy beégetett literálokat lehet benne használni csak.
          </para>
          <para>
            A könyv most ad egy rövid leírást a lehetséges operátorokról és precedencia táblázatról. Én ebbe most nem megyek bele inkább itt egy példa egy másik nyelvből hogy lehet megadni a fent említett dolgokat:
          </para>

<literallayout>
infixr precedence nm1 nm2 ...
</literallayout>
        <para>
           Annyit jelent hogy infix esetben right associative, utána egy szám amivel megadjuk a precedencia számát után pedig.
           Long story short, alább egy left associative infix dolog amire a "+" szimbólummal lehet hivatkozni. Huzzah!
          </para>
<literallayout>
infixl 5 _+_
</literallayout> 
        </section>
        <section>
          <title>Utasítások</title>
          <para>
            Az utasítások az algoritmusok egyes lépéseit megadó egységek. 
            A fordító ezek segítségével készíti a forrás kódunkból a tárgykódot.
            <itemizedlist>
              <listitem>
                  <para>deklarációs</para>
              </listitem>
              <listitem>
                  <para>végrehajtható</para>
              </listitem>
            </itemizedlist>
          </para>
          <section>
            <title>Deklarációs Utasítások</title>
            <para>
            A deklarációs utasítások hatására nem generálódik tárgykód.
            Ezek magának a fordítónak kiadott utasítások. Pl.:szolgáltatás kérés, üzemmódot beállítás stb.
            Természetesen befolyásolják a generált tárgykódot, de önnön maguk nem kerülnek fordításra.
            </para>
          </section>
          <section>
            <title>Végrehajtható Utasítások</title>
            <para>
            Ezek tárgykóddá fordulnak deklarációsakkal ellentétben(...optimalizálás miatt ez nem teljesen 100%-ban igaz).
            Következő csoportokra bonthatjuk ezen nagy csoportot:
            <itemizedlist>
              <listitem>
                  <para>Értékadó utasítás</para>
              </listitem>
              <listitem>
                  <para>Üres utasítás</para>
              </listitem>
              <listitem>
                  <para>Ugró utasítás</para>
              </listitem>
              <listitem>
                  <para>Elágaztató utasítások</para>
              </listitem>
              <listitem>
                  <para>Ciklusszervező utasítások</para>
              </listitem>
              <listitem>
                  <para>Hívó utasítás</para>
              </listitem>
              <listitem>
                  <para>Vezérlésátadó utasítások</para>
              </listitem>
              <listitem>
                  <para>I/O utasítások</para>
              </listitem>
              <listitem>
                  <para>Egyéb utasítások</para>
              </listitem>
            </itemizedlist>
            </para>
            <para>
            Az ugró, elágaztató, ciklusszervező, hívó és vezérlésátadó utasítások az ún. vezérlési szerkezetet megvalósító utasítások.
            Az egyéb utasítás csoportba tartozóból nincs ilyen C-ben, viszont egyes helyeken van belılük (pl. PL/I).
            </para>
            <section>
              <title>Értékadó utasítás</title>
              <para>Feladata változókhoz érték rendelése, vagy ezen érték módosítása.</para>
            </section>
            <section>
              <title>Üres utasítás</title>
              <para>Az üres utasítás hatására a processzor egy üres gépi utasítást hajt végre. Inkább szemantikai okokból létezik egyes nyelvekben</para>
            </section>
            <section>
              <title>Ugró utasítás</title>
              <para>Ezen utasítással feltétel nélkül ugorhatunk egy label-el definiált pontjára a kódnak.</para>
            </section>
            <section>
              <title>Elágaztató utasítások</title>
               <section>
                <title>Kétirányú elágaztató utasítás</title>
                <para>Általában a <literal>IF feltétel THEN tevékenység [ ELSE tevékenység ]</literal> alakot követi.</para>
                <para>A <literal>feltétel</literal> egy igaz-hamis eldönthető predikátum (vagy durva esetekben implicit type conversion-nel meg is lehet trükközni a dolgot)</para>
                <para>A <literal>tevékenység</literal> nyelv függő. Van ahol csak és kizárólag egyetlen utasítás állhat itt. 
                Máshol lehet több utasítás csoportosítására utasítás zárójeleket használni pl. BEGIN END, ezt így utasítás csoportnak nevezzük.
                Végül pedig C-ben például tevékenység helyén vagy egy utasítás vagy egy blokk állhat.
                </para>
                <para>
                  Ha nincs else ág akkor rövid alakról, else ág megléte esetén hosszú alakról beszélünk.
                </para>
                <para>
                  Természetesen egymásba ágyazhatóak az elágaztatások, és ilyenkor merül fel a csellengő else problémája.
                  Ezt persze mindig ki lehet kerülni ha pedantikusan a hosszú alakot használjuk. Más esetben implementáció és nyelvtan függő módon kell eljárnunk.
                </para>
              </section>
              <section>
                <title>Többirányú elágaztató utasítás</title>
                <para>
                  A többirányú elágaztató utasítás arra szolgál, hogy a program egy adott pontján egymást
                  kölcsönösen kizáró n tevékenység közül egyet végrehajtsunk. 
                  A végrehajtandó tevékenység kiválasztását egy konkrét kifejezés értékei szerint tesszük meg.        
                </para>
                <para>
                  Nyelv függő. C Példa:
                </para>
<literallayout>
SWITCH (kifejezes) {
CASE egesz_konstans_kifejezes : [ tevekenyseg ]
[ CASE egesz_konstans_kifejezes : [tevekenyseg ]]…
[ DEFAULT: tevekenyseg ]
};
</literallayout>
              <para>
                A kifejezés típusának numerikus egészre konvertálhatónak kell lennie.
                Az ágak értékei nem tartalmazhatnak duplikációkat. 
                A tevékenység végrehajtható utasítás, vagy blokk lehet. 
                A DEFAULT-ág bárhol szerepelhet.
              </para>
              <para>
                Kiértékelődik a kifejezés, majd szépen a forráskódi felírási sorrendben megpróbálunk végigmeni az összes ágon.
                Ha egy ág-hoz megadott egész konstans kifejezéssel megegyezik az érték, akkor azon ág tevékenysége végrehjatódik.
                Ha nem volt egyezés, akkor a default ág végrehajtódik. Ha nincs default ág, akkor üres utasítás hajtódik végre.
                Mindez egyben azt is jelenti, hogy pl. BREAK-et használva egy ág tevékenységében el kell hagyni a switch-et.
              </para>
              </section>
            </section>
            <section>
              <title>Ciklusszervező utasítások</title>
              <para>
              A ciklusszervező utasítások lehetővé teszik, hogy a program egy adott pontján egy bizonyos tevékenységet többször is megismételjünk.
              Ciklus fejből, magból és végből ál.
              Az ismétlést meghatározó információk vagy a ciklus fejben vagy a ciklus végben találhatóak.
              Maga az ismétlendő tevékenység a magban található.
              Két szélsőséges esetről külön beszélünk.
              Egyik az üres ciklus, mikor egyszer sem fut le a ciklus.
              A másik a végtelen ciklus, mikor a ciklus soha sem áll le.
              </para>
              <para>
               A következő ciklusfajtákat különböztetjük meg:
                <itemizedlist>
                  <listitem>
                      <para>feltételes</para>
                  </listitem>
                  <listitem>
                      <para>előírt lépésszámú</para>
                  </listitem>
                  <listitem>
                      <para>felsorolásos</para>
                  </listitem>
                  <listitem>
                      <para>végtelen</para>
                  </listitem>
                  <listitem>
                      <para>összetett</para>
                  </listitem>
                </itemizedlist>
              </para>
              <section>
                <title>Feltételes ciklus</title>
                <para>
                  Ennél a ciklusnál az ismétlődést egy feltétel határozza meg.
                  A feltétel vagy a fejben vagy a végben van.
                  Kezdő- és végfeltételes ciklusról beszélhetünk.
                </para>
                <para>
                  Kezdőfeltételes ciklus esetén először kiértékelődik a feltétel. 
                  Ha igaz(hamis, nyelv függő lehet) belépünk a magba és végrehajtjuk az ott írtakat, majd újra a feltétel kiértékelésre ugrunk és indulunk újra. 
                  Ha hamis(igaz, nyelv függő lehet) akkor nem lépünk be a magba plusz kilépünk a ciklusból.
                </para>
                <para>
                  Végfeltételes ciklus esetén először végrehajtjuk a magot, majd kiértékelődik a feltétel. 
                  Ha igaz(hamis, nyelv függő lehet) vissza ugrunk és újrakezdjük a mag végrehajtását. 
                  Ha hamis(igaz, nyelv függő lehet) akkor kilépünk a ciklusból.
                  Azaz ezen esetben egyszer mindenképp lefut a mag.
                </para>
              </section>
              <section>
                <title>Előírt lépésszámú ciklus</title>
                <para>
                  Ezen esetben a fejben találhatóak a végrehajtásra vonatkozó információk.
                  Minden esetben tartozik hozzá egy ciklusváltozó.
                  A változó által felvett értékekre fut le a ciklusmag.
                  A változó az értékeit egy általunk megadott tartományból veheti föl.
                  A változó bejárhatja a tartományt csökkenőleg vagy növekvőleg.
                  Ha a változó nem akarjuk hogy felvegye az összes értéket a tartomáynból, akkor érdemes megadnunk lépésközt.
                </para>
                <para>
                  A ciklusváltozó típusa nyelvenként eltérő lehet.
                  A lépésköz és ciklusváltozó típusa vagy megegyezőnek kell lennie, vagy konvertálhtónak kell lennie.
                  
                </para>
                <para>
                  A ciklusváltozó értékének megadásához minden nyelv esetén megengedett a literál, változó és nevesített konstans.
                  Egyes nyelveknél kifejezéssel is megadható.
                </para>
                <para>
                  A lépésköz előjele dönti el – ha pozitív, akkor növekvő, ha negatív, akkor csökkenő.
                  Általában azok a nyelvek vallják ezt, melyekben a ciklusváltozó csak numerikus típusú lehet.
                  Egyes nyelveknél külön alapszót kell használni.
                </para>
                  
                <para>
                  A ciklusparaméterek egyes nyelvek esetén csak egyszer értékelődnek ki, míg más nyelveknél minden mag végrehajtás után.
                </para>
                <para>
                  Általában a ciklus végrehajtás vagy a feltétel nem teljesülése miatt ér véget, vagy akár a magban kiadott speciális utasítás miatt.
                  A GOTO-val történő ciklusból történő kilépést nem tekintjük szabályosnak.
                </para>
                <para>
                  A ciklusváltozó értéke nyelv függő lehet a ciklus elhagyása után. Három eset van: értéke az utolsó amire lefutott a mag, értéke az utolsó amit felvett, undefined.
                </para>
              </section>
              <section>
                <title>Felsorolásos ciklus</title>
                <para>
                  A felsorolásos ciklus az elıőrt lépésszámú ciklus egyfajta általánosításának tekinthető.
                  Van ciklusváltozója, amely explicit módon megadott értékeket vesz fel, 
                  és minden felvett érték mellett lefut a mag. 
                  A ciklusváltozót és az értékeket a fejben adjuk meg, ez utóbbiakat kifejezéssel.
                  A ciklusváltozó típusa általában tetszőleges.
                  Nem lehet sem üres, sem végtelen ciklus.
                </para>
                <para>
                </para>
              </section>
              <section>
                <title>Végtelen ciklus</title>
                <para>
                  Sem a fejben sem a végben nincs információ ciklus elhagyással kapcsolatban, tehát a magban kell lennie olyan utasításnak amely miatt eltudjuk hagyni a ciklust.
                </para>
              </section>
              <section>
                <title>Összetett ciklus</title>
                <para>
                  Az előző négy ciklusfajta kombinációiból áll össze.
                </para>
              </section>
              <section>
                <title>C példák</title>
                <para>
                <itemizedlist>
                  <listitem>
                      <para><literal>WHILE(feltétel) végrehajtható_utasítás</literal></para>
                  </listitem>
                  <listitem>
                      <para><literal>DO végrehajtható_utasítás WHILE(feltétel);</literal></para>
                  </listitem>
                  <listitem>
                      <para><literal>FOR([kifejezés1]; [kifejezés2]; [kifejezés3]) végrehajtható_utasítás</literal></para>
                  </listitem>
                </itemizedlist>
                </para>
              </section>
            </section>
            <section>
              <title>Vezérlő utasítások C-ben</title>
              <para><literal>CONTINUE</literal> ciklus hátralévő utasításait nem hajtja végre és újra indul a feltétel kiértékelés stb. </para>
              <para><literal>BREAK</literal>szabályos kilépés a ciklusból magon belül kiadhatóan.</para>
              <para><literal>RETURN</literal> befejezteti a függvényt és visszaadja a kontrollt a hívónak.</para>
            </section>
          </section>
        </section>
        <section>
          <title>A programok szerkezete</title>
          <para>
            Az eljárásorientált programnyelvekben a program szövege többé-kevésbé független, önálló részekre, ún. programegységekre tagolható.
            Ezen kis egységekből nyelvtől és implementációtól függően három módon állhat össze a teljes program:
            Fizikailag önálló részek,
            Nem önálló részek (strukturáltan egymásba ágyazott)
            Fenti kettő kombinációja.
            Az eljárásorientált nyelvekben az alábbi programegységek léteznek:
            <itemizedlist>
              <listitem>
                  <para>alprogram</para>
              </listitem>
              <listitem>
                  <para>blokk</para>
              </listitem>
              <listitem>
                  <para>csomag</para>
              </listitem>
              <listitem>
                  <para>taszk</para>
              </listitem>
            </itemizedlist>
          </para>
          <section>
            <title>Alprogramok</title>
            <para>Túl szép mondat hogy kihagyjam 
            <quote>Az alprogram az eljárásorientált nyelvekben a procedurális absztrakció elsı megjelenési
            formája, alapvető szerepet játszik ebben a paradigmában, sőt meghatározója annak.</quote></para>
            <para>
              Ezen alprogramokat próbáljuk elszeparálni a lehető legjobban, például minden szükséges információt formális paraméterként átadni.
              A céunk ezzel, hogy működése legkevésbé függjön az őt körbevevő kontextustól, főként csak az általunk megadott (szűkebb) formális paraméterektől.
              Sok pozitív tulajdonsága lesz így az alprogramnak, de a legfőbb a mi szempontunkból a code reuse.
            </para>
            <para>
              Formálisan fej (specifikáció), törzs (implementáció) és végből állnak.
            </para>
            <para>
              <itemizedlist>
                <listitem>
                    <para>név</para>
                </listitem>
                <listitem>
                    <para>formális paraméter lista</para>
                </listitem>
                <listitem>
                    <para>törzs</para>
                </listitem>
                <listitem>
                    <para>környezet</para>
                </listitem>
              </itemizedlist>
            </para>
            <para>
              A név egy azonosító, a fejben szerepel. 
              
            </para>
            <para>
              A formális paraméter lista is a specifikáció része. 
              A formális paraméter listában azonosítók szerepelnek(...ez szerintem nyelv függő...mármint pl. Haskell Agda totál másképp közelíti meg pattern matching miatt a dolgokat), ezek a törzsben saját
              programozási eszközök nevei lehetnek, és egy általános szerepkört írnak le, amelyet a hívás
              helyén konkretizálni kell az aktuális paraméterek segítségével.
            </para>
            <para>
              A korai nyelvekben a formális paraméter listán csak a paraméterek nevei szerepelhettek.
              A mai modern nyelveknél azonban olyan egyéb információk mellyel a paraméterek viselkedését szabályozhatjuk.
              A formális paraméter lista kerek zárójelek között áll (általában). 
              A nyelvek egy része szerint a zárójelek a formális paraméter listához, mások szerint a névhez tartoznak.
              A formális paraméter lista lehet üres is, ekkor paraméter nélküli alprogramról beszélünk.
            </para>
            <para>
              A törzsben deklarációs és végrehajtható utasítások szerepelnek.
              A nyelvek egy része azt mondja, hogy ezeket el kell különíteni egymástól, tehát a törzsnek van egy deklarációs és egy végrehajtható része. 
              Erre a fenti mondatra már effektíve ki is tértünk a C standard-ek összehasonlításánál.
              Más nyelvek szerint viszont a kétféle utasítás tetszőlegesen keverhető.
              Az alprogramban deklarált programozási eszközök kívülről nem láthatóak azaz ezek az alprogram scope-jában élnek 
              (aka variables decalred in the block are considered to be local to that block and they are visible only in that scope or from another which has visibility on that scope).
              Persze global scope-ba is rakhatjuk a dolgokat, de ez általában nagyon erősen kerülendő.
            </para>
            <para>
              Az alprogramoknak két fajtája van: eljárás és függvény.
            </para>
            <para>
              Az eljárás a hatását a paramétereinek vagy a környezetének megváltoztatásával illetve a törzsben elhelyezett végrehajtható utasítások által meghatározott tevékenység elvégzésével fejti ki.
            </para>
            <para>
              A függvény elsődlegesen egy értéket szolgáltat vissza.
              Mellékhatás ha a függvény környezetét vagy paramétereit módosítja.
              Tiszta esetben ennyi a lényege és nincs mellékhatása.
              Sajnos a való életben főként a mellékhatásos verzióval futhatunk össze.
              Ez pontosan ugyanolyan veszélyes és megkerülhetetlen, mint az eljárás.
            </para>
            <para>
              A könyv mellékhatás definíciója...mármint biztos jó...de szerintem eljárás maga és a függvény is, 
              ha bármit módosít a környezetből paraméterből az már mellékhatás.
              Ezt arra alapozom, hogy pl. ha optimálni akarok egy kódot, akkor csak akkor hagyhatok ki dolgokat, ha tudom, hogy kihagyásukkal semmilyen módon nem változik a program eredménye és az állapot.
            </para>
            <para>
              Az eljárást aktivizálásához utasításszerűen hívnunk kell azt (gyakran még valami alapszó-t is elé kell írni). Például a lenti (absztrakt) módon:
            </para>
<literallayout>
[alapszo] eljarasnev(aktualis_parameter_lista)
</literallayout>
            <para>
              Egy eljárás szabályosan befejeződhet ha elérjük a végét.
              Másik út, hogy külön utasítással befejeztetjük, ez bárhol kiadható az eljárás törzsében.
              Szabályos befejezıdés esetén a program a hívást követő utasításon folytatódik.
              Általában nem szabályos befejezésnek tekintjük a következőket:
              A nyelvek általában megengedik, hogy GOTO-val kiugorjunk eljárásból.
            </para>
            <para>
            Függvényt kifejezés alakban lehet hívni.
            </para>
<literallayout>
fuggvenynev(aktualis_parameter_lista)
</literallayout>
            <para>
              A függvényhívás után normális befejeződést feltételezve a vezérlés a kifejezésbe tér vissza, és továbbfolytatódik annak a kiértékelése.
            </para>
            <para>
               Egy függvény a következő módokon határozhatja meg a visszatérési értékét:
              <itemizedlist>
                <listitem>
                    <para>A függvényneve változóként szabadon változtatható. Visszatérésnél utolsó felvett értéke lesz használva.</para>
                </listitem>
                <listitem>
                    <para>A függvénynevének értéket kell adni, de nem használható szabadon. Visszatérésnél utolsó felvett értéke lesz használva.</para>
                </listitem>
                <listitem>
                    <para>Külön befejeztető utasítással megadjuk az értéket és befejezzük a függvényt</para>
                </listitem>
              </itemizedlist>
            </para>
            <para>
              A függvény szabályosan befejezıdhet, ha:
              <itemizedlist>
                <listitem>
                    <para>elérjük a végét, és már van visszatérési érték</para>
                </listitem>
                <listitem>
                    <para>Külön befejeztető utasítás, és már van visszatérési érték,</para>
                </listitem>
                <listitem>
                    <para>Külön befejeztető utasítás ami meghatározza az értéket</para>
                </listitem>
              </itemizedlist>
              Ha ezek nem állnak fenn, akkor nem szabályos a kilépés. Tehát pl.: GOTO szabálytalan.
            </para>
            <para>
              Az eljárásorientált programozási nyelvekben megírt minden programban kötelezően lennie egy főprogramnak.
              Egy program szabályos befejeződése a főprogram befejeződésével történik meg, 
              ekkor a vezérlés visszakerül az operációs rendszerhez.
            </para>
          </section>
          <section>
            <title>Hívási lánc, rekurzió</title>
            <para>
              Ha egy programegység meghív egy másikat majd az egy másikat stb. akkor kialakul egy call chain, hívás lánc.
              A hívási lánc első tagja mindig a főprogram.
              A hívási lánc minden tagja aktív de csak a legvégső fut éppen (mármint igazából a schedulertől függ hogy ez megfog-e történni valaha :).
              Mikor a hívási lánc egyik tagja befejeződik az előző programegység végrehajtási folytatódik.
            </para>
            <para>
              Mikor egy aktív alprogramot hívunk meg, azt rekurziónak nevezzük.
              Rekurzió lehet közvetlen, mikor önmagát hívja az alprogram.
              Lehet közvetett, mikor a hívási lánc más tagja hívja az alprogramot.
            </para>
            <para>
              Rekurzió általában átírható iteratív megoldássá.
              Iteratív jobb, hiszen kevesebb erőforrást igényel (rövidebb call chain, nem kell annyi mindent állapotot kimenteni és cipelni).
              Vannak olyan nyelvek amelyek főként a rekurziót preferálják, pl. Haskell.
            </para>
          </section>
          <section>
            <title>Másodlagos belépési pontok</title>
            <para>
              Egyes nyelvek megengedik, hogy egy alprogramot meghívni ne csak a fejen keresztül
              lehessen, hanem a törzsben ki lehessen alakítani ún. másodlagos belépési pontokat, így vagy a
              fejben megadott névvel vagy a másodlagos belépési pont nevével lehet hivatkozni az
              alprogramra. 
            </para>
          </section>
          <section>
            <title>Paraméterkiértékelés</title>
            <para>
              Egy alprogram hívásakor a hívásban megadott aktuális paraméterek a formálisakhoz rendelődnek.
              Ezt paraméterkiértékelésnek hívjuk.
            </para>
            <para>
              Hogy melyik formálishoz, melyik aktuális param rendelődik, több módon kezelhetik a nyelvek:
              Sorrendi, vagy név szerinti kötés (binding)
              A sorrendi esetében a lista beli heylük alapján történik az összerendelés.
              Név szerinti esetben a nevesített aktuális paramétereket explicit rendeljük össze a nevesített formálisakkal.
            </para>
            <para>
              Nyelvtől eltérő hogy mennyi aktuális paramétert kell megadni.
              Alapesetben persze annyit, amennyi a formális elemszáma, de egyes nyelvekben lehet kevesebbet, és ekkor default értékek rendelhetőek a fennmaradó formálisakhoz.
              Van változó számú (nem rögzített) eset is. Var args.
            </para>
            <para>
              Egyes nyelvek esetén az aktuális és formális paraméter típusának meg kell egyeznie.
              Más nyelvek esetén elegendő ha típuskényszerítéssel elérhető legyen a konverzió.
            </para>
          </section>
          <section>
            <title>Paraméterátadás</title>
            <para>
              Mikor egy alprogram(hívó) meghív egy másik alprogramot, olyankor a kommunikációt paraméterátadásnak nevezzük.
            </para>
            <para>
            Paraméterátadás fajtái:
              <itemizedlist>
                <listitem>
                    <para>érték szerinti</para>
                </listitem>
                <listitem>
                    <para>cím szerinti</para>
                </listitem>
                <listitem>
                    <para>eredmény szerinti</para>
                </listitem>
                <listitem>
                    <para>érték-eredmény szerinti szerinti</para>
                </listitem>
                <listitem>
                    <para>név szerinti</para>
                </listitem>
                <listitem>
                    <para>szöveg szerinti</para>
                </listitem>
              </itemizedlist>
            </para>
            <section>
              <title>érték szerinti</title>
              <para>
                A hívott területén a paramétereknek van címkomponensük.
                A hívó oldalon kell hogy legyen érték komponensük.
                Az hívó oldali érték átmásolódik a hívott oldali területre.
                A hívó nem fogja látni a változtatásokat saját oldalon.
              </para>
            </section>
            <section>
              <title>cím szerinti</title>
              <para>
                Hívott oldalon nincs címkomponens, viszont hívó oldalon van.
                Ezen esetben hívó oldalon hívás után látni fogjuk a hívó általi változtatásokat.
              </para>
            </section>
            <section>
              <title>eredmény szerinti</title>
              <para>
                Hívó oldalon és hívott oldalon egyaránt címkomponens.
                Hívott nem használja a hívott oldali címet, simán local formálisba dolgozik.
                Szabályos visszatéréskor, local formális értéke átmásolódik a hívott oldali címre.
              </para>
            </section>
            <section>
              <title>érték-eredmény szerinti szerinti</title>
              <para>
                Hívó oldalról átmásolódik az érték a hívott oldalra ez lesz a helyi kezdőérték.
                Szabályos visszatéréskor a hívott oldali végleges érték átmásolódik hívó oldalra. 
              </para>
            </section>
            <section>
              <title>név szerinti</title>
              <para>
                A formális paraméter nevének összes előfordulása hívott oldalon átíródik adott szimbólummá.
              </para>
            </section>
            <section>
              <title>szöveg szerinti</title>
              <para>
                A név szerinti, egyetlen eltérés, hogy hívottban a név felülírás csak akkor fut le, amikor formális param első előfordulását elérjük.
              </para>
            </section>
          </section>
          <section>
            <title>A blokk</title>
            <para>
              Programegységben helyezkedik el, azon kívül sohasem álhat.
              Van kezdete, törzse, vége.
              A kezdetet és a véget egy-egy speciális karaktersorozat vagy alapszó jelzi. 
              A törzsben lehetnek deklarációs és végrehajtható utasítások.
            </para>
            <para>Blokk általában úgy kezdődik hogy vagy kezdetére ér a végrehajtás, vagy GOTO-t követő ugrás.</para>
            <para>Blokk általában úgy végződik hogy vagy végére ér a végrehajtás, vagy GOTO-t követő ugrással kiugrunk belőle.</para>
            <para>Fő szerepe a nevek hatáskörének tárolása. ÉLETCIKLUS!!!! PROPER CLEANUP ORDER!!!! Gyakorlatilag enélkül nem lenne smart ptr :)</para>
            <section>
              <title>Hatáskör</title>
              <para>
                A hatáskör a nevekhez kapcsolódó fogalom.
                Egy név hatásköre alatt értjük a program szövegének azon részét, 
                ahol az adott név ugyanazt a programozási eszközt hivatkozza, tehát jelentése, 
                felhasználási módja, jellemzői azonosak. 
                A hatáskör szinonimája a láthatóság.
                Ez egyébként legegyszerűbben logikából lett bemutatva először a képzés során.
                Ott is például elég komoly átnevezéseket kellett olykor elvégezni, és ezek csak akkor történhettek meg, ha nem volt szabad és tudtuk mi köti pontosan.
              </para>
              <para>
                A név hatásköre az eljárásorientált programnyelvekben a programegységekhez, illetve a fordítási egységekhez kapcsolódik.
              </para>
              <para>
                Egy programegységben deklarált nevet a programegység lokális nevének nevezzük.
                Azt a nevet, amelyet nem a programegységben deklaráltunk, de ott hivatkozunk rá, szabad névnek hívjuk.
                (Emlékezzünk logikából is, hogy átnvezést nem hajhattunk pl ilyen esetben végre stb.)
              </para>
              <para>
                Azt a tevékenységet, mikor egy név hatáskörét megállapítjuk, hatáskörkezelésnek hívjuk.
                Kétféle hatáskörkezelést ismerünk, a statikus és a dinamikus hatáskörkezelést.
              </para>
              <para>
                Statikus esetben fordítás időben current scope-ban próbáljuk megtalálni az adott nevet.
                Ha ez nem található akkor addig keresünk a felsőbb scope-okban amíg meg nem találjuk, vagy ki nem érünk.
                (Példa, ctor arg "a" de class-nak van a data member-e. Mivel legszűkebb scope-omban keresek először ezért ha simán a-t írok be, akkor a ctor argra fogok hivatkozni huzzah.)
                Ha nem található a név a legkülsőben, akkor egyes nyelvek esetén hiba áll elő.
                Más nyelvek ilyenkor a legkülső scope-ban auto deklarálják.
              </para>
              <para>
                Hatáskör befelé terjed kifelé soha.
              </para>

              <para>
               A dinamikus hatáskörkezelés futás idejű.
               Ha nem talál egy nevet a futtató rendszer akkor a hívási láncban kezd visszafele keresni.
               Ilyen esetben a hatásköre egy névnek a programegység ahol deklaráltuk, és minden belőle induló hívási láncban elhelyezkedő programegység.
              </para>
              <para>
                Az eljárásorientált nyelvek a statikus hatáskörkezelést valósítják meg. 
                Az alprogramok formális paraméterei az alprogramra lokálisak.
                A kulcsszavak, mint nevek a program bármely pontjáról láthatók. 
                A program egységek nevei azonban globális láthatóak. (azért ez sem így egy az egyben c++-ban)
              </para>
            </section>
            <section>
              <title>Fordítási egység</title>
              <para>
                Az eljárásorientált nyelvekben a program közvetlenül fordítási egységekbıl épül föl. 
                Ezek olyan forrásszöveg-részek, melyek önállóan, a program többi részétől fizikailag különválasztva fordíthatók le.
                Az egyes nyelvekben a fordítási egységek felépítése igen eltérő lehet. 
                A fordítási egységek általában hatásköri és gyakran élettartam definiáló egységek is.
              </para>
            </section>
          </section>
          <section>
              <title>C</title>
              <para>
                A C nyelv a function-t és a block-ot ismeri.
                Egy function a másikba nem ágyazható, de function-be block igen és block-ba block igen.
              </para>
              <para>Block</para>
<literallayout>
{
deklaraciok
vegrehajthato_utasitasok
}
</literallayout>
            <para>Function</para>
<literallayout>
[típus] név([formális_paraméter_lista])
block
</literallayout>
            <para>Ha nem szerepel a típus, akkor az alapértelmezés int. Ha void a típus, akkor lényegében egy eljárásról van szó.</para>
            <para>A fő program main, mely maga egy function.</para>
            <para>Függvény befejeződhet RETURN-el. Ezen esetben void típusú funckióval szokásos visszatérés, míg egyéb T típus esetén nem definiált visszatérési érték.
             Vigyázzunk ez C++-ban is maradt...
             </para>
            <para>
              <literal>RETURN kifejezes;</literal> esetén a visszatérési érték a kifejezés kiértékelt értéke.
            </para>
            <para>
              A formális paramétereket vesszővel elválasztva, explicite típust megadva tudjuk definiálni.
              A C-ben a programozó tud nem fix paraméterszámú függvényt deklarálni úgy, hogy megad legalább egy formális paramétert, és a formális paraméter listát ... zárja. 
              Az üres formális paraméter listát explicit módon jelölhetjük a void alapszó megadásával.
            </para>
            <para>
              Sorrendi kötés, típuskényszerítés (elég vad) és fix paraméterszám esetén számbeli egyeztetés van.
               A paraméterátadás érték szerinti.
            </para>
            <para>
              A C-ben a fordítási egység a forrásállomány. 
              Ez ún. külső deklarációkat (nevesített konstans,változó, típus, függvény) tartalmaz. 
              A fordítási egység elején más olyan fordítási egységekre, amelyek eszközeit használni akarjuk, a
            <literal> #include &lt;forrásállománynév&gt; </literal> preprocesszor utasítással hivatkozhatunk.
            </para>
            <para>
              A C a hatáskör és élettartam szabályozására bevezeti a tárolási osztály attribútumokat:
              <itemizedlist>
                <listitem>
                    <para>extern</para>
                </listitem>
                <listitem>
                    <para>auto</para>
                </listitem>
                <listitem>
                    <para>register</para>
                </listitem>
                <listitem>
                    <para>static</para>
                </listitem>
              </itemizedlist>
            </para>
            <section>
              <title>extern</title>
              <para>
                A fordítási egység szintjén deklarált nevek alapértelmezett tárolási osztálya.
                Lokális neveknél explicit módon meg kell adni.
                Az ilyen nevek hatásköre a teljes program, élettartamuk a program futási ideje. 
                Van automatikus kezdőértékük.
              </para>
            </section>
            <section>
              <title>auto</title>
              <para>
                lokális nevek alapértelmezett tárolási osztálya.
                Hatáskörkezelésük statikus, decsak a deklarációtól kezdve láthatók. 
                Élettartamuk dinamikus. Nincs automatikus kezdőértékük.</para>
            </section>
            <section>
              <title>register</title>
              <para>Speciális auto, amelynek értéke regiszterben tárolódik, ha van szabad regiszter, egyébként nincs különbség.</para>
            </section>
            <section>
              <title>static</title>
              <para>
              Bármely névnél explicit módon meg kell adni. 
              Hatáskörük a fordítási egység, élettartamuk a program futási ideje. 
              Van automatikus kezdőértékük.</para>
            </section>
            </section>
        </section>
        <section>
          <title>IO</title>
          <para>
            Az I/O az a területe a programnyelveknek, ahol azok leginkább eltérnek egymástól.
            Az I/O platform-, operációs rendszer-, implementációfüggő.
            Egyes nyelvek nem is tartalmaznak eszközt ennek megvalósítására, eleve az implementációra bízzák a megoldást.
          </para>
          <para>
            A perifériákkal való kommunikációról szól összességében az IO.
            Az IO hogy egységesen tudja tárgyalni a témát, azért az absztakt állomány fogalmat vezeti be.
            A programnyelvi fogalom fedésben van ezen absztrakt állomány fogalommal.
            A programban a logikai állomány egy olyan programozási eszköz, amely nevesített, és
            amelynél az absztrakt állományjellemzők (rekordfelépítés, rekordformátum, elérés, szerkezet,
            blokkolás, rekordazonosító stb.) attribútumként jelennek meg.
            A fizikai állomány pedig az op rendszer szintű impl. azaz perifériákon megjelenő adatokat tartalmazó állomány.
          </para>
          <para>
            Egy állomány funkció szerint lehet:
             <itemizedlist>
              <listitem>
                  <para>input állomány: feldolgozás előtt létezik, nem változik</para>
              </listitem>
              <listitem>
                  <para>output állomány: feldolgozás előtt NEM létezik, változik , írni lehet</para>
              </listitem>
              <listitem>
                  <para>input-output állomány: általában létezik a feldolgozás előtt és után is, változik, olvasni és írni is lehet.</para>
              </listitem>
            </itemizedlist>
          </para>
          <para>
            Az IO során tár és a periféria között adatokat mozgatunk. 
            A tárban és periféria ábrázolási módja eltérhet, ez felveti egy fajta konverzió szükségességének kérdését, illetve specifikációjának mikéntjét. 
            Az alapján hogy történik-e konverzió megkülönböztetünk: folyamatos módú (van konverzió), és bináris, rekordalapút (nincs konverzió).
          </para>
            <para>
              Folyamatos módú esetben a periférián tárolt adatokat egy folyamatos karaktersorként értelmezzük.
              A tárban azonban a typusnak megfelelő ábrázolási mód szerint definiált bitsorozatok vannak.
            </para>
            <para>
              Olvasáskor meg kell mondanunk, hogy a folytonos karaktersorozatot hogyan 
              tördeljük fel olyan karaktercsoportokra, amelyek az egyedi adatokat jelentik, 
              és hogy az adott karaktercsoport milyen típusú adatot jelent. 
              Íráskor pedig azt kell meghatároznunk, hogy a tárban tárolt bitsorozatokat hogyan konvertáljuk át folytonos karaktersorozattá és milyen szabályokkal.
            </para>
            <para>
              A fenti szabály megadása három módon történhet:
              <itemizedlist>
                <listitem>
                    <para>formátumos módú adatátvitel</para>
                </listitem>
                <listitem>
                    <para>szerkesztett módú adatátvitel</para>
                </listitem>
                <listitem>
                    <para>listázott módú adatátvitel</para>
                </listitem>
              </itemizedlist>
            </para>
            <para>
              Formátumos módú adatátvitelnél minden egyes egyedi adathoz a formátumok segítségével
explicit módon meg kell adni a kezelendı karakterek darabszámát és a típust.
            </para>
            <para>
              Szerkesztett módú adatátvitelnél minden egyes egyedi adathoz meg kell adni egy maszkot, amely szerkesztő és átviendő karakterekből áll. 
              A maszk elemeinek száma határozza meg a kezelendő karakterek darabszámát.
              A szerkesztő karakterek megadják, hogy az adott pozíción milyen kategóriájú karakternek kell megjelennie. 
              A többi karakter változtatás nélkül átvitelre kerül.
            </para>
            <para>
            Listázott módú adatátvitelnél a típusra nincs explicit módon megadott információ.
            Viszont hogy hol van az egyedi adatok közt a határ azt magában a folyamatos karaktersorban elhelyezett speciális karakterek jelentik.
            </para>
            <para>
            </para>
           <para>Bináris módban a periféria és tár közötti kommunikáció során nem történik konverzió.</para>
           <section>
            <title>Állományok kezelése</title>
            <para>
              Az állomány kezelés a következő lépésekre bontható:
              <itemizedlist>
                <listitem>
                    <para>Deklaráció</para>
                </listitem>
                <listitem>
                    <para>Összerendelés</para>
                </listitem>
                <listitem>
                    <para>Állomány megnyitása</para>
                </listitem>
                <listitem>
                    <para>Feldolgozás</para>
                </listitem>
                <listitem>
                    <para>Lezárás</para>
                </listitem>
              </itemizedlist>
            </para>
            <para>
              Deklarációnál a nyelv által megszabott módon be kell vezetnünk a logikai állományt, megfelelő attribútumokkal.
            </para>
            <para>
              Összerendelés során a logikai állományt egy OS által kezelt fizikai állománnyal rendeljük össze.
              Ezekután a logikai állománnyal végzett tevékenyésgek az alatta lévő fizikaira fognak kihatni.
            </para>
            <para>
              Állomány megnyitása során OS check-ek futnak le, hogy a logikai és fizikai állomány kompatibilis-e.
              Ezenkívül például regisztrálódik, hogy általunk használatban van az erőforrás.
              Másrészt olykor a funkció is itt tisztázódik (pl. read only célból nyitjuk).
            </para>
            <para>
              A már nyitott állományból írhatunk, vagy olvashatunk.
              Az írást/olvasást végző eszköznél a fenti fejezetek alapján folyamatos módban meg kell adni az információkat a konverzióhoz.
            </para>
            <para>
              A lezárás ismét operációs rendszer rutinokat aktivizál.
              Például itt veszi ki az OS az eddig általunk fogottnak jelzett állományokról, hogy elengedtük őket.
              A könyvtárak információinak aktualizálása ilyenkor történik meg. 
              A lezárás során a logikai és fizikai állomány közti kapcsolat megszűnik.
              Általában a főprogram szabályos befejeződésekor az összes nyitott állomány bezáródik.
              </para>
            <para>
              A programozási nyelvek a programozó számára megengedik azt, hogy input-output esetén ne
              állományokban gondolkozzon, hanem az írás-olvasást úgy képzelje el, hogy az közvetlenül
              valamelyik perifériával történik. 
              Ezt hívjuk implicit állománynak. 
              A megfelelő logikai és fizikai állomány most is létezik standard nevekkel és jellemzőkkel, 
              de ezt a futtató rendszer automatikusan kezeli. T
              ehát az implicit állományt nem kell deklarálni, összerendelni,
              megnyitni és lezárni. 
              Az implicit input állomány a szabvány rendszerbemeneti periféria
              (általában a billentyűzet), az implicit output állomány a szabvány rendszerkimeneti periféria
              (általában a képernyő).
              A programozó bármely állományokkal kapcsolatos tevékenységet
              elvégezhet explicit módon (pl. az implicit output állományhoz hozzárendelheti a nyomtatót).
              Ha az író és olvasó eszközben nem adjuk meg a logikai állomány nevét, akkor a művelet az
              implicit állománnyal történik.
              Implicit helyett olykor érdemes lehet direkt explicitben nyitni, ugyanis ilyenkor nagyobb kontrollunk a módról.
            </para>
           </section>
        </section>
    </section>
    
    <section>
      <title>Programozás bevezetés</title>
      <para>                
          <citation>KERNIGHANRITCHIE</citation> (2nd edition)
      </para>
      <para>
        Előző alfejezetben a <citation>JUHASZ</citation> könyv kapcsán már lementünk assemblyig és vissza, szóval itt nem fogunk újra arról beszélni hogy mi az a bool, csak az új dolgok.
      </para>
      <!-- TODO KR -->
      <section>
        <title>Alapismeretek</title>
        <para>
          A legegyszerűbb C program, <literal>gcc hw.c</literal>-vel compile-olunk.
        </para>
<literallayout>
main ()
{printf ("Hello World\n");} 
</literallayout>
        <para>
          Ez a fejezet elég alap dolgokkal foglalkozik, inkább csak a lényeges részeket emeletem ki csak.
          (Pl. for ciklusról volt egy pár mondatos rész, de erre úgyis egy egész afejezet lesz stb...)
        </para>
        <section>
          <title>Adattípusok</title>
          <para>
          C-beli alaptípusok
          <itemizedlist>
              <listitem>
                  <para>int    - egész szám</para>
              </listitem>
              <listitem>
                  <para>float  - lebegőpontos szám</para>
              </listitem>
              <listitem>
                  <para>char   - karakter, egyetlen byte</para>
              </listitem>
              <listitem>
                  <para>short  - rövid egész szám</para>
              </listitem>
              <listitem>
                  <para>long   - hosszú egész szám</para>
              </listitem>
              <listitem>
                  <para>double - dupla pontnosságú lebegőpontos szám</para>
              </listitem>
          </itemizedlist>
        </para>
        <para>
          Ezenkívül lehetőség van user defined struct-ok kialakítására, ahol a fenti adattípusokból és egyéb structokból
          rakhatunk össze új típusú structokat, union-nal több struct típusból képezhetünk egy közös uniót stb.
        </para>
        </section>
        <section>
          <title>Változók és aritmetikai kifejezések</title>
          <para>
            A fordító minden, a /* és */ között előforduló karaktert és mid figyelmen kívül hagy, ezek kommentek.
            A C nyelvben használat előtt minden változót deklarálni kell.
            Mindezt (szabvénytól függően) az első végrehajtható utasítás előtt, ezáltal a függvény test 
            egy deklarációs és végrehajtási részre tagolható.
            A deklarációban egy típus megadását követően az ezen típusú változók neveinek felsorolását kell elvégeznünk.
            Példa:
          </para>
<literallayout>
int lower, upper, step; float fahr, celsius;
</literallayout>
          <para>
            Értékadást a = operátorral érhetünk el, azaz pl.:
          </para>
<literallayout>
int lower, upper, step; float fahr, celsius;
lower = 0;
</literallayout>
          <para>
            Persze az értékadás kiértékelődése miatt láncolhatjuk is a változókat:
          </para>
<literallayout>
int lower, upper, step; float fahr, celsius;
upper = lower = 0;
</literallayout>

<literallayout>
main ()
{
  int lower, upper, step;
  float fahr, celsius;
        lower = 0;	/* A hőmérséklet-táblázat alsó határa */
        upper = 300;	/* felső határ */
        step = 20;	/* lépésköz */
  fahr = lower;
  while (fahr &lt;= upper) 
  {
        celsius = (5.0 / 9.0) * (fahr - 32.0);
        printf ("%4.0f %6.1f \n", fahr, celsius);
        fahr = fahr + step;
  }     
} 
</literallayout>
        <para>
          Az előzőekben említett típusok fontosak, hiszen ezek szablyák meg a foglalt hey méretét.
          Ez gép (architektúra) függő.
        </para>
        <para>
          A printf első argumentumában lévő format karakterláncban minden egyes % konstrukcióhoz 
          hozzárendelődik a neki megfelelő második, harmadik stb. argumentum.
          Egyébként a printf nem része a C nyelvnek: a C nyelven belül a be- és kivitel nincs definiálva.
          Formatálsához segítség:
          <itemizedlist>
              <listitem>
                  <para>%d    decimális egész</para>
              </listitem>
              <listitem>
                  <para>%6d   decimális egész, de legalább 6 char hosszan</para>
              </listitem>
              <listitem>
                  <para>%f    lebegőpontos</para>
              </listitem>
              <listitem>
                  <para>%6f   lebegőpontos, de legalább 6 char hosszan</para>
              </listitem>
              <listitem>
                  <para>%.2f    decimális egész, kettő a tizedes veszző után</para>
              </listitem>
              <listitem>
                  <para>%6.2d   lebegőpontos, de legalább 6 char hosszan, kettő a tizedes veszző után</para>
              </listitem>
          </itemizedlist>
        </para>
        </section>
        <section>
          <title>Változók és aritmetikai kifejezések</title>
          <para>
          </para>
<literallayout>
#include &lt;stdio.h&gt;
main ()	/ * Fahrenheit-Celsius táblázat*/
{
  int fahr; 
  for (fahr = 0; fahr &lt;= 300; fahr = fahr + 20){
    printf ("%4d %6.1f \n", fahr, (5.0 / 9.0) * (fahr - 32));
  }
}
</literallayout>
        <para>
          A <literal>for</literal> egy ciklusutasítás, tekinthetünk rá a while általánosításaként.
          Három részt tartalmaz, amelyeket pontosvesszők választanak el.
          Az első rész, fahr = 0 értékadása egyszer hajtódik végre a ciklusba való belépés előtt.
          A második rész a ciklust vezérlő ellenőrzés vagy feltétel.
          Minden alkalommal megvizsgáljuk hogy a feltétel teljesül-e, ha igen végrehajtjuk a ciklus magot,
          amit az újrainicializáló lépés azaz <literal>fahr = fahr + 20</literal> követ.
          A ciklus akkor ér véget, amikor a feltétel hamissá válik.
          Csakúgy, mint a while esetében, a törzs vagy egyetlen utasítás, 
          vagy pedig kapcsos zárójelek közé zárt utasítások csoportja. 
          Az inicializáló és újrainicializáló tetszőleges kifejezés lehet. 
          A ciklusnak nincs saját scope-ja C++-tól eltérően.
        </para>
        </section>
        <section>
          <title>Szimbolikus konstansok</title>
          <para>
            Az előfeldolgozó preprocesszor segítségével úgymond szimbolikus konstansokat használhatunk.
            A preprocesszor compile előtt végig megy a forrás szövegen és ha olyan szimbólumba fut,
            mely define-al értelmezve lett számára, akkor azon előfordulásokat cseréli a defineban megadott karakterláncra.
            Ezek használatával az előző fahrenheit program.
          </para>
<literallayout>
#include &lt;stdio.h&gt;
#define LO 0
#define UP 300
#define STEP 20
main ()	/ * Fahrenheit-Celsius táblázat*/
{
  int fahr; 
  for (fahr = LO; fahr &lt;= UP; fahr = fahr + STEP){
    printf ("%4d %6.1f \n", fahr, (5.0 / 9.0) * (fahr - 32));
  }
}
</literallayout>
        </section>
        <section>
          <title>Tömbök</title>
          <para>
            C-ben a tömb egy adott adattípusból n darabot tartalmazó adattároló.
            Legfontosabb tulajdonsága, hogy memóriában az array egy egybefüggő helyen tárolódik.
            Emiatt allokálásakor nem csak hogy elegendő szabad memóriával kell a gépnek rendelkeznie,
            de kell lennie legalább egy olyan memória résznek, mely nem kisebb mint az igényelt terület az array által.
            Ezen helyfoglalás miatt az array mérete utólag nem növelhető.
            Az egyetlen módszer új elem hozzáadására, ha kérünk egy nagyobb array-t és átmásoljuk az elemeket a régiből az újba,
            majd a régit felszabadítjuk stb.
          </para>
        </section>
        <section>
          <title>Argumentumok érték szerinti átadása</title>
          <para>
            C-ben az argumentumok érték szerint adódnak át, azaz a hívó nem fogja látni a hívott az argumentumokon
            végzett változtatásokat. Példa:
          </para>
<literallayout>
#include &lt;stdio.h&gt;

int add(int x, int y)
{
  x = 5;
  return x + y;
}

main ()	/ * Fahrenheit-Celsius táblázat*/
{
  int a = 1;
  int b = 2;
  add(a,b);
}
</literallayout>
        <para>
          Fenti példában az add által okozott változtatás <literal>x = 5;</literal>
          nem lesz kihatással <literal>main</literal>-beli <literal>a</literal>-ra.
        </para>
        <para>
          Ez amiatt van így, mert <literal>add</literal> hívásakor  <literal>main</literal>-beli <literal>a</literal>          
          értéke átmásolódik add területén lévő x változóba.
          x-en végzett bármilyen változtatás lokális add-ra, és kívülről nem is megfigyelhető.
        </para>
        <para>
          A későbbiekben kifogunk térni egy megoldásra abban az esetben, ha olyan változást akarunk amit a hívónak is
          látnia kellene. Ezt pointer-ekkel fogjuk megoldani (azaz a változtatandó változó értéke helyett a tárbeli címét küldjük a hívottnak.)
        </para>
        </section>
        <section>
          <title>Karakter tömbök</title>
          <para>
            A C nyelvben leggyakoribb tömbtípus valószínűleg a karaktertömb.
            Érdemes felhívni a figyelmet, hogy egy 0 értékű zárókarakterrel a c karaktertömbök általában le vannak zárva.
            Azaz például:
         </para>
<literallayout>
"hello\n"
['h','e','l','l','o','\n','\0']
</literallayout>
         <para>
          Sok C funkció ha karakter tömböt fogad el, akkor elvárja hogy ezen szabványnak megfelelő módon előállított tömböt kapjon.
          Más esetben nem definiált működésük.
         </para>
<literallayout>	       
int getline(char s[], int lim)
{
  int c,i;
  for(i=0;i&lt;lim-1&amp;&amp;(c=getchar())!=EOF&amp;&amp;c!='\n';++i){ 
    s[i]=c;
  }
  if(c=='\n'){
    s[i]=c;
    ++i;
  }
  s[i]='\0';
  return i;
}

void copy(char to[], char from[])
{
  int i;
  i=0;
  while((to[i]=from[i])!='\0'){
    ++i;
  }
}
</literallayout>
         <para>
          Fenti példában látható, hogy <literal>copy</literal> arra támaszkodik hogy null-terminated C char array-t kapjon.
          <literal>getline</literal> esetében pedig láthatjuk hogy a végén garantáljuk, hogy az utolsó karakter a terminátor legyen.
          Itt érdemes megjegyezni, hogy a fordító is hasonló technikával fordításközben átalakítja a forrásban található egymásután álló karaktereket egy nullterminált karaktertömbbé.
         </para>
        </section>
        <section>
          <title>Érvényességi határ, külső változók</title>
          <para>
            A main függvényen belüli változók (line, save stb.) a main-re nézve lokálisak. 
            Mivel ezeket a main-en belül deklaráltuk, egyetlen más függvény sem tud közvetlenül hozzájuk férni.
            Ez fennáll fordítva is, azaz egy másik funkciónak lokális változó nem látható main számára (és ezáltal nem is okoz összeférhetetlenséget névegyezés miatt).
            A függvények lokális változói csak meghívásukkor jönnek létre, és megsemmisülnek a scope elhagyáskor.
            Emiatt az ilyen változókat automatikus változóknak nevezzük. 
            Ezek értéküket nem őrzik meg egyik hívástól a másikig, 
            így minden belépéskor explicit módon értéket kell adni nekik. 
            Ha azonban azt akarjuk hogy ne az előbb ismertetett "tranziens" módon viselkedjenek, 
            akkor lehetőségünk van globális változókat használni.
            Ezeket a globális változókat bármelyik függvény név szerint elérheti.
           Az összes függvényen kívül kell definiálni, hogy ezzel tárolóhelyet foglaljunk le a számukra.
           A változókat minden olyan függvényben, ahol használni akarjuk, vagy explicit módon az extern alapszóval, 
           vagy implicit módon értelemszerűen, de deklarálnunk is kell. 
          </para>
        </section>
      </section>
      <section>
        <title>Típusok, Operátorok és Kifejezések</title>
        <para>
          A programokban változókat és állandókat használunk.
          A deklarációk effektíve kijelentik a fordító számára az általunk
          felhasználni kívánt változókat.
          A fordítónak szüksége van emiatt a typusra, és esetleges kezdeti értékre is.
          A kifejezésekkel és operátorokkal ezen változókat módosíthatjuk plusz számításokat végezhetünk rajtuk.
          (Mármint a legvégén a legbonyolultabb dolog is egyszerű ALU által végrehajtható elemi máveletekké fog egyszerűsödni.)
        </para>
        <section>
            <title>Változó nevek</title>
            <para>
              A nevek betűkből és számjegyekből állnak: az első karakter betű kell, hogy legyen.
              Az aláhúzás karakter (_) betűnek számít: ezzel javíthatjuk a hosszú változónevek olvashatóságát.
              Lehetőleg aláhúzással ne kezdjünk nevet (_) 
              A nagy- és a kisbetű különbözőnek számít.
              A belső nevekben és külső nevekben eltérés van.
              Ugyan akármilyen hosszú nevet megadhatunk mindkét esetben, de szabványtól függ, hogy ezen karakterekből mennyi lesz szignifikáns.
              Ezenkívül az olyan kulcsszavak, mint if, else, int, float stb. fenntartott szavak,
              változónévként nem használhatók.
            </para>
          </section>
          <section>
            <title>Adattípus és méret</title>
            <para>
              A C-beli alaptípusok
              <itemizedlist>
                  <listitem>
                      <para>int    - egész szám</para>
                  </listitem>
                  <listitem>
                      <para>float  - lebegőpontos szám</para>
                  </listitem>
                  <listitem>
                      <para>char   - karakter, egyetlen byte</para>
                  </listitem>
                  <listitem>
                      <para>short  - rövid egész szám</para>
                  </listitem>
                  <listitem>
                      <para>long   - hosszú egész szám</para>
                  </listitem>
                  <listitem>
                      <para>double - dupla pontnosságú lebegőpontos szám</para>
                  </listitem>
              </itemizedlist>
              int, short és long architektúrától eltérő, de a lényeges egymáshoz képest relatív reprezentált nagyságuk.
              (pl. int és short 16 bit, long 32 bit)
              <literal>char</literal> és <literal>int</literal> esetén tovább módosíthatjuk 
              <literal>unsigned</literal> és <literal>signed</literal> hozzáadásával.
              Ezek annyit jelentenek, hogy előjeles vagy nem előjeles megjelenítést és aritmetikát tervezünk használni.
              Példa char esetén, hogy unsigned char [0,255] intervallumból, míg signed társa [-128,128] intervallumból vehet fel értékeket.
              <literal>limits.h</literal> és <literal>float.h</literal> tartalmazza ezen típusokhoz tartozó utility konstansokat(pl. max).
            </para>
          </section>
          <section>
            <title>Konstansok</title>
            <para>
            int konstans és long
            </para>
<literallayout>
1234
1234L
</literallayout>
            <para>
            long int signed unsigned
            </para>
<literallayout>
1234L
1234UL
</literallayout>
            <para>
              float
            </para>
<literallayout>
123.4
1e-2
</literallayout>
          <para>
            Egy vezető 0 int előtt oktális, míg 0x vagy 0X hexadecimálist jelent
          </para>
<literallayout>
012
0x1f
</literallayout>
          <para>
            Karakter konstanst aposztrófok közé írjuk. Newline és egyéb speciális karakterekhez escape char-t használhatunk ami backslash.
          </para>
<literallayout>
'a'
'\n'
</literallayout>
          <para>
            Stringeket idézőjelek közé írjuk
          </para>
<literallayout>
"aba"
"ab" "a"
</literallayout>
          <para>
            felsorolások (enum) a következő módon:
          </para>
<literallayout>
enum foo{AAR,BAR,CAR}
</literallayout>
          <para>
            Enum érték 0-ról indul, de megadhatunk mást is
          </para>
<literallayout>
enum foo{AAR=1,BAR,CAR,UNDEF=0}
</literallayout>
          </section>
          <section>
            <title>Deklarációk</title>
            <para>
              Minden változót deklarálni kell használat előtt.
               A deklaráció meghatároz egy típust, amelyet az illető típusú változó(ka)t megadó lista követ, mint például:
              Külső vagy statikus változó esetén az inicializálás csak egyszer
              értelemszerűen a program végrehajtásának megkezdése előtt - történik meg.
              Az  explicit módon inicializált automatikus változók minden alkalommal inicializálódnak, amikor az őket tartalmazó függvényt egy program meghívja.
              Az explicit inicializálás nélküli automatikus változók értéke határozatlan.
              A külső és statikus változók kezdeti értéke alapértelmezés szerint nulla, de stilárisan helyesebb, ha minden esetben megadjuk a kezdeti értéket.
                          
            </para>
<literallayout>
int lower, upper, step; char c, line [1000];
</literallayout>
            <para>
              A változók saját deklarációikban inicializálhatók is, bár ezzel kapcsolatban vannak megkötések. 
              Ha a nevet egy egyenlőségjel és egy állandó követi, akkor az az illető változó kezdeti értékének megadását(inicializálását) jelenti.
            </para>
          </section>
          <section>
            <title>Aritmetikai műveletek</title>
            <para>
              Az aritmetikai operátorok a +, -, *, /  és a % (moduló) operátor. Van egyoperandusú -, de nincs egyoperandusú +.
            Az egész típusú (integer) osztás levágja a tört részt. Az
            x % y kifejezés az  x-nek y-nal történő osztásakor keletkező maradékot jelenti, tehát értéke nulla, ha x pontosan osztható y-nal.
            </para>
          </section>
          <section>
            <title>Relációs és logikai operátorok</title>
            <para>
              Relációs operátorok
             <literal> &gt; &gt;= &lt; &lt;= = </literal>
            </para>
            <para>
              Egyenlőséget vizsgáló operátorok
             <literal> == != </literal>
            </para>
            <para>
              Logikai operátorok
             <literal> &amp;&amp; || </literal>
            </para>
          </section>
          <section>
            <title>Típus konverzió</title>
            <para>
              Ha egy kifejezésben különböző típusú operandusok fordulnak elő, 
              a kifejezés kiértékeléséhez az operandusokat azonos típusúakká kell alakítani.
              Belátható, hogy bizonyos esetekben a konverzió nem lehetséges, például a tört számot nem tudunk egész számként leképezni.
              Azonban ha például egy float-ként tárolt szám valójában éppen egész értékű, akkor nem okoz adatvesztést a konverzió.
              Bizonyos esetkeben a konverzió garantálhatóan sikeres lesz.
              Ez például tegyük fel char-t akarunk int-é alakítani. Ez biztosan mindig megtörténhet, hiszen egy szűkebb intervallumon lévő elem biztos leképzehető egy olyan intervallum által aminek része ezen intervallum.
              Általában csak az értelmes konverziók történnek meg automatikusan, 
              például egész típusú mennyiségek átalakítása lebegőpontossá olyan kifejezésekben, 
              mint f + i, ahol f float, i pedig int típusú. 
              Az értelmetlen kifejezések, mint például a float indexként való használata, nem megengedettek.
              A char és int típusú mennyiségek aritmetikai kifejezésekben szabadon keveredhetnek.
              Konverziót kényszeríthetünk is, ezt az alábbi módon tehetjük meg:
            </para>
<literallayout>
int a;
char b;
a = 5;
b = (char)a;
</literallayout>
            <para>
            </para>
          </section>
          <section>
            <title>Bitenkénti műveletek</title>
            <para>
              A következő bitenkénti műveleteket használhatjuk.
              <itemizedlist>
                  <listitem>
                      <para>&amp;	 - bitenkénti ÉS</para>
                  </listitem>
                  <listitem>
                      <para>|  - bitenkénti megengedő (inkluzív) VAGY</para>
                  </listitem>
                  <listitem>
                      <para>^	 - bitenkénti kizáró (exkluzív) VAGY,</para>
                  </listitem>
                  <listitem>
                      <para>&lt;&lt;  - bitléptetés (shift) balra,</para>
                  </listitem>
                  <listitem>
                      <para>&gt;&gt;  - bitléptetés (shift) jobbra,</para>
                  </listitem>
                  <listitem>
                      <para>~ - egyes komplemens (egyoperandusú).</para>
                  </listitem>
              </itemizedlist>
            </para>
          </section>
          <section>
            <title>Értékadási operátorok és kifejezések</title>
            
            <para>
            Az olyan kifejezések, mint i = i + 2 amelyekben a bal oldal a jobb oldalon megismétlődik, a +=
            értékadó operátor segítségével az i += 2 tömörített alakban is írhatók.
            A C-ben legtöbb aritemetikai művelet esetén van értékadó megfelelő.
            Ne feledekezzünk meg az erősorrendről.
            </para>
<literallayout>
x *= y + 1      // 1.
x = x * (y + 1) // 2. ekvivalens 1.-vel
x = x * y + 1   // Nem ekvivalens sem 1.-vel sem 2.-kal
</literallayout>
          </section>
          <section>
            <title>Feltételes kifejezések</title>
            <para>
            </para>
<literallayout>
if (a > b)
z = a;
else
z = b;
</literallayout>
          <para>
            A fenti feltételes utasítás eredményeként z a és b közül a nagyobbik értékét veszi fel.
            A C-ben a háromoperandusú ?: operátor segítségével az ilyen
            szerkezeteket sokkal rövidebben leírhatjuk.
          </para>
<literallayout>
z = (a > b) ? a : b;
</literallayout>
          <para>
            A feltételes kifejezésben az első kifejezést nem kötelező zárójelbe tenni, mivel ?: precedenciája igen alacsony (pontosan az értékadás fölötti). Zárójelezéssel azonban érthetőbbé tehetjük a kifejezés feltételrészét.
          </para>
          </section>
          <section>
            <title>Precedencia, kiértékelési sorrend</title>
            <para>
              Ha nem teljesen zárójelezett alakot adunk meg, akkor érdemes lehet tanuémányozni a <link xlink:href="https://en.cppreference.com/w/c/language/operator_precedence">precedencia táblát</link>.
            </para>
          </section>
      </section>
      <section>
        <title>Vezérlési szerkezetek</title>
        <para>
          A nyelv vezérlésátadó utasításai a számítások végrehajtásának sorrendjét határozzák meg. 
        </para>
          <section>
            <title>Utasítások, blokkok</title>
            <para>
              A C-ben a pontosvesszővel zárjuk az utasításokat.
              A { és } kapcsos zárójelek felhasználásával deklarációkat 
              és utasításokat egyetlen összetett utasításba vagy blokkba foghatunk össze. 
              Ez szintaktikailag egyetlen utasítással egyenértékű.  
              A blokkot  lezáró jobb oldali kapcsos zárójel után soha nincs pontosvesszô.
              A blokkon belül deklarálási sorrendtől fordított sorrendben szűnik meg a változók élete.
              (Ez később c++ esetén lehet hasznos amikor gurad-okat akarunk csinálni, és garantálni akarjuk hogy egy bizonyos dtor mindig a végén hívódjon meg.)
            </para>
          </section>
          <section>
            <title>If-else</title>
            <para>
              Elágaztatás esetén az if-else-t használjuk
            </para>
<literallayout>
if(feltétel)
egy utasítás vagy egy blokk
else
egy utasítás vagy egy blokk
</literallayout>
            <para>
              Azaz például
            </para>
<literallayout>
if(a&gt;5)
  a=5
else
{
a=b;
c=2*d;
b=c;
}
</literallayout>
          <para>
              Az else el is hagyható
          </para>
<literallayout>
if(g&gt;5)
  g=5
</literallayout>
          <para>
            Emiatt azonban olykor nem teljesen egyértelmű hogy mely if hez tartozik egy else.
            Ennek feloldására szabvány szerint  az else a hozzá legközelebbi else nélküli if-hez kapcsolódik. 
          </para>
<literallayout>
if (n &gt; 0)
  if (a &gt; b)
    z = a;
  else
    z = b;
</literallayout> 
          <para>
            Ha ettől eltérőt akarunk, akkor azt a blokk jelöléssel érhetjük el
          </para>
<literallayout>
if (n &gt; 0){
  if (a &gt; b)
    z = a;
}else
  z = b;
</literallayout> 
          </section>
          <section>
            <title>Else-if</title>
            <para>
              Else if az else és if közé akárhányszor beépíthatő
            </para>
<literallayout>
if (feltetel0)
  utasitas0
else if (feltetel1)
  utasitas1
else if (feltetel2)
  utasitas2
else
  utasitas3
</literallayout> 
          </section>
          <section>
            <title>Switch</title>
            <para>
              A switch utasítással a többirányban ágaztathatjuk a programot.
            </para>
<literallayout>
switch (kifejezes)
{
  case konstans-kifejezes: utasitasok
  case konstans-kifejezes: utasitasok
  default: utasitasok
}
</literallayout> 
            <para>
              A switch először kiértékeli a zárójelek közötti kifejezést 
              utána pedig egyenként forráskódbeli sorrendben összehasonlítja a case-eknél
              megadott konstans kifejezesek értékeivel.
              Minden case-t egész állandó kifejezéssel kell ellátni.
              Ha egy case azonos a kifejezés értékével, akkor a casehez rendelt tevékenységek elfognak végződni. 
              A default címkéjű case-re akkor kerül a vezérlés, ha a többi case egyike sem teljesül. 
              A default elhagyható : ha nem szerepel és a case-ek egyike sem teljesül, semmi nem történik. 
              A case-ek és a default tetszôleges sorrendben követhetik egymást. 
              A case utasítások címkéinek különbözniük kell egymástól.
              A break utasítás hatására a vezérlés azonnal kilép a switch-bôl. 
              Mivel a case-ek címkeként működnek, miután valamelyik case-hez tartozó programrész 
              végrehajtása befejezôdött, a vezérlés a következô case-re kerül, 
              hacsak explicit módon nem intézkedünk a kilépésrôl. 
              A switch-bôl való kilépés legközönségesebb módja a break és a return. 
              Az egymást követô case-ekbe való belépés nem egyértelműen elônyös. 
              A case-ken történô lépkedés azért is veszélyes, mert a vezérlés széteshet, 
              ha a programot módosítjuk.  Azokat  az eseteket kivéve, 
              amikor ugyanahhoz a számításhoz  több címke tartozik, 
              a case-ek közötti átmenetek használatával célszerű takarékoskodni.  
            </para> 
          </section>
          <section>
            <title>Loops(for, while)</title>
            <para>
              a <literal>while</literal> esetében kiértékeljük a fejben lévő feltételt.
              Ha igaz, akkor belépünk a magba és végrehajtjuk az utasításokat, majd visszaugrunk fejbe és újrakezdjük a folyamatot.
              Ha hamis, akkor elhagyjuk a ciklust:
            </para>
<literallayout>
while (kifejezes)
  statement
</literallayout> 
            <para>
              A <literal>for</literal> ciklus egy speciális while, ahogy azt az alábbi példa is mutatja:
            </para>
<literallayout>
for (expr0;expr1;expr2)
  statement
//ami ekvivalens
expr0
while (expr1){
  statement
  expr2;
}
</literallayout>
          </section>
          <section>
            <title>Loops(Do-while)</title>
            <para>
              A do-while esetében a mag egyszer garantáltan végrehajtódik.
              Alább látható alakú:
            </para>
<literallayout>
do
utasitas
while (kifejezes)
</literallayout> 
            <para>
              Azaz utasitas mindig legelább egyszer végre fog hajtódni.
            </para>
          </section>
          <section>
            <title>Break and continue</title>
            <para>
              A ciklusból való kilépést vezérlhetjük nem csak a ciklus elején vagy végén való feltételvizsgálattal, 
              hanem a magban kiadott utasítással is.      
              A break utasítással a vizsgálat elôtt is ki lehet ugrani a for, while és do ciklusokból, csakúgy, mint a switch-bôl.
              A break utasítás hatására a vezérlés azonnal kilép a legbelsô zárt ciklusból.
            </para>
            <para>
              A continue utasítás a break-hez kapcsolódik, 
              de a break-nél ritkábban használjuk.
              A continue esetén a ciklus (for, while, do) a következô iterációjának  megkezdését idézi elô.
              A while és a do  esetében ez azt jelenti, hogy azonnal végrehajtódik a feltételvizsgálat, 
              a for esetében pedig a vezérlés azonnal az újrainicializálási lépésre kerül. 
              Switch-re ez nem alkalmazható.
            </para>
          </section>
      </section>
      <section>
        <title>Függvények és programstruktúra</title>
        <para>
          A függvények segítségével a nagy feladatokat kisebbekre tudjuk bontani, 
          illetve kisebb problémákra adott megoldásokat újból felhasználni.  
          A jól  megírt függvények gyakran elrejtik az implementációs részleteket így felsőbb szinten a program
          áttekinhetőbbé válik.
        </para>
          <section>
            <title>Alapok</title>
            <para>
              A függvényeket más helyekről a következő módon hívjuk:
            </para>
<literallayout>
fuggvenyneve(aktualis_parameterek_listaja)
</literallayout>
            <para>
             Azaz a függvény neve után zárójelek között felsoroljuk azon paramétereket melyeket aktuálisnak tekintünk,
             és tovább akarunk adni.
             Amikor a program ide ér végrehajtásban érték szerint átadja az aktuális paramétereket,
             ezek a hívottban a formális paraméterek konkrét értékeként lesznek használva.
             Miután az irányítás átkerült a hívottnak addig amíg ki el nem éri utolsó sorát vagy egy <literal>return</literal>-t végrehajtódik.
             Ha végrehajtódásának végére ér, az irányítás visszaadódik a hívónak, és ha volt visszatérési érték, azt
             hívó látni fogja.
             Nem szükséges hogy a <literal>return</literal> után kifejezés álljon, ez esetben a hívó nem kap vissza semmit. 
             A vezérlés visszatér (visszatérési érték nélkül) azon esetben is, ha 
             a blokk végét úgy érjük el, hogy nem futottunk bele <literal>return</literal>-be.
             Mikor a visszatérési érték nem adódik meg a hívott által a hívó által látott visszatérési érték nem NULL vagy egyéb,
             hanem nem definiált, azaz ne alapozzuk erre a program későbbi működését, logikáját.
             Az ilyen hibákat <literal>lint</literal> helyességvizsgálóval analizálhatjuk.
            </para>
          </section>
          <section>
            <title>Nem int visszatérési értékű függvények</title>
            <para>
              A függvények implicit módon deklaráltak azáltal,  hogy megjelennek valamely utasításban vagy kifejezésben.
              Ha valamely kifejezésben korábban még nem deklarált név fordul elô,
              amelyet bal oldali kerek zárójel követ, akkor ezt a gép a szövegkörnyezet alapján függvénynévként deklarálja. 
              Default ezen függvény visszatérési értékének int-et veszi.
              Ha a fenti default működéstő eltérő értelmezést akarunk, akkor explicit deklarálnunk kell a függvényt.
              Ilyen esetben deklarálnunk a függvény visszatérési rték típusát a függvény neve előtt:
            </para>
<literallayout>
double foo(int a);
</literallayout>
          </section>
          <section>
            <title>Külső változók</title>
            <para>
                A C program külsô változókból és függvényekből áll.
                Külsővel szemben belső az amit függvényen belül deklaráltunk vagy automatikusan deklarálódtak.
                A külsô változókat függvényeken kívül definiáljuk, 
                így sok függvény számára elérhetôk. 
                Maguk a függvények mindig külsôk, hiszen függvényt függvényen belül nem szabad definiálni. 
                Megállapodás szerint a külsô változók egyben globális változók is tehát minden, 
                az ilyen változóra ugyanazzal a névvel történô hivatkozás 
                (még a teljesen külön fordított függvényekbôl is) ugyanarra a programozási objektumra t
                örténô hivatkozást  jelent.
                Bármelyik  függvény hozzáférhet külsô változóhoz az illetô változó nevére történô hivatkozással, 
                ha a nevet korábban deklarálták.
            </para>
          </section>
          <section>
            <title>Érvényességi Tartomány</title>
            <para>
              Nem szükséges egyszerre lefordítani a C programot alkotó összes függvényt és külsô változót: a program forrásszövege több állományban tárolható, és könyvtárakból már elôzôleg lefordított rutinok is betölthetôk.
            </para>
            <para>
              Egy név érvényességi tartománya a programnak az a része, 
              amelyre vonatkozóan a nevet definiáltuk. 
              A függvény elején definiált automatikus változó érvényességi  
              tartománya  az  a függvény, amelyben  a nevet deklaráltuk, 
              és a más függvényekben ugyanilyen néven létezô változókat ez nem érinti. 
              Ugyanez igaz a függvény argumentumaira.
              A külsô változó érvényességi tartománya ott kezdôdik, 
              ahol a forrásállományban a változót deklaráltuk és az illetô állomány végéig tart. 
            </para>
            <para>
              Ha viszont egy külsô változóra még annak definiálása elôtt kell hivatkozni, vagy ha egy külsô változót más forrásállományban definiálunk, mint ahol használunk, akkor kötelezôen extern deklarációt kell alkalmazni.
            </para>
            <para>
                A forrásprogramot alkotó állományok között csupán egyben kell a külsô változó definíciójának szerepelnie; a többi állományban extern deklarációval biztosítjuk a változó elérését. (A definíciót tartalmazó állományban is lehet extern deklaráció.) Külsô változót csak definiáláskor lehet inicializálni. A tömbméreteket a definícióban kell megadni, de opcionálisan extern deklarációban is szerepelhetnek.
            </para>
          </section>
          <section>
            <title>Statikus változók</title>
            <para>
              A már korábban megismert extern és automatikus változók mellett 
              a statikus (static) változók jelentik a harmadik tárolási osztályt. 
              A static változók akár belsôk, akár külsôk lehetnek.
              Belső esetben ugyanúgy csak a függvényen belülről elérhetőek, de az automatikusokatól eltérően,
              nem inicializálódik újra értékük hívásonként és az egész program élettartama alatt megmaradnak.
              A belsô static változók a függvényen belül állandó tárban tárolódnak le. 
              A függvényeken belül megjelenô karakterláncok, mint pl. a printf argumentumai, belsô static változók.
            </para>
            <para>
              A külsô static változó azon forrásállományban ahol deklaráltuk látható lesz,
              és a program egész élettartama alatt létezni fog.
              Miel csak az adott forrásállományban használhatjuk azután hogy deklarálva lett, ezért ennek két következménye lesz:
              Egy forrásállományban deklarációja után több függvénnyel is használhatjuk, módosíthatjuk ezt.
              Más forrásállományból nem látjuk, nem használhatjuk, módosíthatjuk.
            </para>
            <para>
              A statikus tárolást úgy jelöljük hogy static szót írjuk a típus elé.
              A változó külsô, ha nem függvényen belül deklaráltuk, belső ha függvényen belül.
            </para>
<literallayout>
static int a;
foo(int b)
{
static int c;
}
</literallayout>
          </section>
          <section>
            <title>Regiszter változók</title>
            <para>
              Amennyiben lehetséges, a register típusú változók a gép regisztereibe kerülnek, miáltal rövidebb és gyorsabb
              programok jönnek létre. A register deklaráció alakja:
            </para>
<literallayout>
register int c, n;
f(register unsigned int a, register long b)
</literallayout>
            <para>
              Gyakorlatban persze elég gép függő kényszerek között dolgozunk.
              Hisz már ha csak a használható regiszterek száméra gondolunk, akkor is láthatjuk hogy ez elég
              gép függő lehet.
            </para>
          </section>
          <section>
            <title>Blokk struktúra</title>
            <para>
              C-ben nem deklaráhatóak függvények függvények testében, 
              viszont bizonyos részek elküönítésére alkalmasak a blokkok.
              Az adott blokk kezdete után deklarált változók a blokk végéig érvényben maradnak.
              Ha a blokkon kívül egy adott névvel már létezik változó de mi a blokkban deklaráaláunk ezen a néven újból egyet, akkor ezen blokkon belül,
              ez az új felülfogja bírálni a régit, tehát ezen blokkban mindig a blokkra lokálisra fogunk hivatkozni.
            </para>
          </section>
          <section>
            <title>Inicializáció</title>
            <para>
              Az explcicit inicializálatlan külső és statikus változók értéke mindig garantáltan null lesz,
              míg az auto és regiszter változók értéke ilyen setben definiálatlan.
            </para>
            <para>
              Külsô és statikus változók esetében az inicializálás egyszer fordítási idôben történik meg.
              Az auto és regiszter változók minden függvénybe vagy blokkba lépéskor inicializálódnak, 
              ha oda ért a vezérlés.
              Automatikus és regiszterváltozók esetében az inicializálás jobb oldalán állhat állandó, 
              előzőleg definiált érték, függvény hívás stb.
            </para>
            <para>
              Tömbök inicializálása során kapcsoszárjelek között az elemeket vesszővel elválasztva kell felsorolnunk.
            </para>
<literallayout>
int arr [10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, } ;
</literallayout>
            <para>
              Karakter tömbök esetén literállal is megadhatjuk.
            </para>
<literallayout>
char ar0 [] = "abc";
char ar1 [] = {'a','b','c','\0'};
</literallayout>
          </section>
          <section>
            <title>Rekurzió</title>
            <para>
              C megengedi hogy a függvények önnömagukat hívják.
              Ilyenkor az automatikus változól az új hívás esetén újra inicializálódnak.
              Mivel a hívó és a hívott adatait el kell szeparálni, ezért ez plusz terhelés a veremnek.
              Emiatt általában a rekurzivitás lassabb és nagyobb tárigányű kódhoz vezet.
            </para>
          </section>
      </section>
      <section>
        <title>Bevitel és kivitel</title>
        <para>
          A bevitel és kivitel nem részei a C nyelvnek.
          Azonban a C nyelv mellé használatos szabványos könyvtár orvosolja ezt a problémát.
          Ez a könyvtár függvények olyan készletét tartalmazza, melyek a szabványos be- és kivitelről gondoskodnak.
          A könyvtárbeli rutinok gépfüggetlenek azaz kompatibilis módon működnek minde olyan rendszeren melyen a C létezik.
          A fenti könyvtárat <literal>stdio.h</literal> fájl includejával be kell emelnünk az előfordító segítségével használat előtt.
        </para>
          <section>
            <title>Szabványos kimenet és bemenet</title>
            <para>
              A legegyszerűbb beviteli mód a getchar
            </para>
<literallayout>
int getchar(void);
</literallayout>
            <para>
              Minden híváskor a soronkövetkező karaktert vagy EOF konstanst ad vissza.
              EOF jelentése end of file, azaz az input végére ért.
              Ezt az <literal>stdio.h</literal> definiálja.
            </para>
            <para>
              Sok rendszeren lehetőségünk van szabványos bemenetre billentyűzet helyett fájl állományt irányítani.
            </para>
<literallayout>
foo &lt; file.txt
</literallayout>
            <para>
              Emellett lehetőségünk van egyik program kimenetét átirányítani egy másik program bementére:
            </para>
<literallayout>
foo | bar
</literallayout>
            <para>
              A kimenetre legegyszerűbb lehetőségünk a putchar:
            </para>
<literallayout>
int putchar(int);
</literallayout>
             <para>
              Ez egyszerűen a megadott értéket megpróbálja a szabványos kimenetre írni.
              Visszatérési értéke a kiírt érték, vagy hiba esetén EOF.
            </para>
          </section>
          <section>
            <title>Formátumozott kimenet- printf</title>
            <para>
              A formátumozott kimenetet megavlósító printf
            </para>
<literallayout>
int printf(char* format, arg1, arg2);
</literallayout>
            <para>
              A függvény láthatóan vár egy format string-et, és ez illetve a megadott változó számú argumentumok alapján elvégzi a kiírást az stdout-ra.
            </para>
            <para>
              A format string két fajta objektumot tartalmazhat: közönséges karaktereket, 
              amelyeket egyszerűen a kimeneti folyamra másol és konverzió-specifikációkat, 
              amelyek mindegyike a printf soron következô argumentumának konvertálását és ki-nyomtatását írja elô.
            </para>
            <para>
              A format stringben % után szerepelnie kell a következő felsorolásbeli szimbólumoknak, majd egy konverziós karakterrel kell ezt a karakter felsorolást zárni.
              <itemizedlist>
                <listitem>
                    <para>minusz - balra igazítás</para>
                </listitem>
                <listitem>
                    <para>szám - mely megadja a minimális hosszat megjelenített karakterszámban</para>
                </listitem>
                <listitem>
                    <para>pont - ami szeparálja a precíziót</para>
                </listitem>
                <listitem>
                    <para>szám - megadja a precízió pontosságát</para>
                </listitem>
                <listitem>
                    <para>h, vagy l - h ha short, l ha longként kell a számot kezelni</para>
                </listitem>
              </itemizedlist>
              A konverziós karakterek:
              <itemizedlist>
                <listitem>
                    <para>d,i - int decimális</para>
                </listitem>
                <listitem>
                    <para>o - int unsigned oktális</para>
                </listitem>
                <listitem>
                    <para>x,X - int unsigned hexadecimális</para>
                </listitem>
                <listitem>
                    <para>u - int unsigned decimális</para>
                </listitem>
                <listitem>
                    <para>c - egy karkter</para>
                </listitem>
                <listitem>
                    <para>s - char* mely null terminátorig a char array-t kiírja</para>
                </listitem>
                <listitem>
                    <para>f - double lebegőpontos szám [-]m.dddddd alakban</para>
                </listitem>
                <listitem>
                    <para>e,E - double lebegőpontos szám [-]m.dddddde[+/-]xx alakban</para>
                </listitem>
                <listitem>
                    <para>g,G - ha a kitevő kisebb mint -4, vagy nagyobb mint a precízió akkor úgy viselkedik mint e, egyébként f</para>
                </listitem>
                <listitem>
                    <para>p - pointer</para>
                </listitem>
                <listitem>
                    <para>% - nincs konverzió, %-t nyomtat</para>
                </listitem>
              </itemizedlist>
            </para>
          </section>
          <section>
            <title>Formattált bemenet - Scanf</title>
            <para>
              A formátumozott bemenetet megavlósító scanf
            </para>
<literallayout>
int scanf(char* format, arg1, arg2);
</literallayout>
            <para>
              scanf akkor áll meg, ha a format string-ben megadott össze olvasási kérést elvégezte, 
              vagy az egyik input format alapján történő beolvasása és értelmezése közben hiba lép fel.
              A scanf számára meg kell adni hogy beolvasás esetén hova tárolja a értékeket.
              Példa:
            </para>
<literallayout>
int a,b,c;
double v;
char arr[20];
scanf("%lf",&amp;v);
scanf("%s",arr);
scanf("%d/%d/%d",&amp;a,&amp;b,&amp;c);
</literallayout>
          <para>
            Fenti példán látszik hogy az érték szerinti átadás maitt
            nem egyenesen a változókat adtuk át hanem azok címét.
            Ettől csak a char array esetén tértünk el, hoszen az array, és eredendően a a karaktertömbnek foglalt hely kezdő memória címét adja.
          </para>
          <para>
            Scanf átugorja a whitespace karaktereket.
          </para>
          </section>
          <section>
            <title>Változó hosszú argumentum listák</title>
            <para>
              Az edigiekben látott <literal>printf</literal> függvény esetében láthattuk, hogy nem volt megszabott az argumentumok száma.
              Hogyan lehet jelölni, hogy n darab előre nem meghatározott argumentumot akarunk elfogadni?
            </para>
<literallayout>
int myprintf(char*fmt, ...);
</literallayout>
          <para>
            Ahhoz hogy végigtudjuk járni az argumentumokat használnunk kell az <literal>stdarg.h</literal>-t.
          </para>
<literallayout>
int myprintf(char*fmt, ...)
{
  va_list ap;char *p, *sval;
  int ival;
  double dval;
  
  va_start(ap,fmt);
  for(p=fmt; *p; p++){
    if(*p!='%'){
      putchar(*p);
      continue;
    }
    switch(*++p){
      case 'd':
        ival = va_arg(ap,int);
        printf("%d",ival);
        break;
      case 'f':
        dval = va_arg(ap,double);
        printf("%f",dval);
        break;
      case 's':
        for(sval=va_arg(ap,char*);*sval;sval+){
          putchar(*sval);
        }
        break;
      default:
        putchar(*p);
        break;
    }
    va_end(ap);
  }
}
</literallayout>
          </section>
          <section>
            <title>Fájl hozzáférés</title>
            <para>
              Az eddigiekben szabványos bemenettel, kimenettel foglalkoztunk.
              Azonban olykor szükség lehet például egyéb állományok használatára.
              Gyakran fájlok tartalmával kell foglalkoznunk.
              Ezek fizikailag egy adott módon vannak leképezve, viszont a C szempontjából logikailag kezelésük egységes.
              Azaz a logikai állomány egy absztrakció a perifária, fájlrendszer és OS által megvalósított fizikai szint felett.
              Minden alapja a <literal>FILE</literal> ami az <literal>stdio.h</literal>-ban deklarált struktúra.
            </para>
            <para>
              Az állományt bármilyen más művelet előtt meg kell nyitni. Ez az a pont amikor 
              összerendelődik a fizikai és logikai állomány és emellett a hozzáférés módja is tisztázódik.
              Másrészről ez jelzi az OS számára hogy a folyamat igényt tart az adott állományra.
            </para>
<literallayout>
FILE* fp;
fp = fopen(name,mode);
</literallayout>
            <para>
              Az első arg az állomány neve (az OS kezeli egyébként, hiszen a valóságban nem név alapján azonosítja egyedileg a fájlokat.)
              A mode egy karakterlánc ami specifikálja hogy milyen módon akarjuk megnyitni.
              <literal>r</literal> olvasás, <literal>w</literal> írás, <literal>a</literal> hozzáfűzés.
              <literal>b</literal> bináris, azaz nem történi karakter konverzió, hanem a nyers bájtokat kapjuk meg.
              Ha egy nem létező fájlt nyitunk meg írási célból akkor az ilyenkor létrejön.
              Ha létező fájlt nyitunk írásra, akkor az összes előzetes eddigi tartalmat felülírjuk.
              Ha nem létező fájlt akarunk olvasni akkor az hiba.
              Másik hiba lehetőség, ha nincs megfelelő jogosultságunk, de ezt az OS kezeli vagy DOS esetén nem kezeli.
              Hiba esetén fopen garantáltan NULL értékkel tér vissza.
            </para>
            <para>
              Bemenet kimenet legegyszerűbb tevékenységei a:
            </para>
<literallayout>
int getc(FILE* fp);
int putc(int c, FILE* fp);
</literallayout>
            <para>
              Format vezérelt bemenet kimenet legegyszerűbb tevékenységei a:
            </para>
<literallayout>
int fscanf(FILE* fp, char* fmt, ...);
int fprintf(FILE* fp, char* fmt, ...);
</literallayout>
            <para>
              Ha végeztünk a tevékenységekkel, akkor be kell zárni a fájlt.
              Ez valóságban azt jelenti,hogy bontani kell a megfeleltetési kapcsolatot 
              a logikai és a fizikai állomány között.
              Másrészről ez jelzi az OS számára hogy a folyamat továbbá nem tart igényt az adott állományra.
            </para>
<literallayout>
int fcloe(FILE* fp);
</literallayout>
          </section>
          <section>
            <title>Hibakezelés és Exit</title>
            <para>
              A stdout mellett létezik még egy szabványos kimenet.
              Ez az stderr. Ez általában akkor is megjelenik a képernyőn ha stdout át lett irányítva.
              (De külön ezt is lehet átirányítani.)
              Példa:
            </para>
<literallayout>
if(is_error){
  fprintf(stderr,"%s: error\n", msg);
  exit(2);
}
</literallayout>
          <para>
            A másik dolog amit a fenti kód használ az az <literal>exit</literal>.
            Ennek egyetlen argumentuma egy int.
            A program ennek hatására elkezdi terminálni a futását.
            Visszatérési értéke pedig az ezen függvény argumentumában adott int lesz.
          </para>
          </section>
          <section>
            <title>Soronkénti bemenet és kimenet</title>
            <para>
              Lehetőségünk van stdlib-el sorok beolvasására.
            </para>
<literallayout>
char* fgets(char*line, int maxline, FILE* fp);
</literallayout>
           <para>
              <literal>fgets</literal> beolvassa a következő karakterláncot fp által mutatott állományból.
              Maximum maxline-1 karaktert olvas.
              Az olvasás eredményéből egy karakter tömböt hoz létre mely null terminált.
              Ha fájl végére ért, vagy egyéb hiba jelentkezett akkor NULL ptr-t ad vissza.
            </para>
            <para>
               Lehetőségünk van stdlib-el sorok kiírására.
            </para>
<literallayout>
int fputs(char*line, FILE* fp);
</literallayout>
            <para>
              <literal>fputs</literal> kiírja egy sorban a kimentre a megadott karakterláncot az fp által mutatott állományból.
              Alapvetően 0 visszatérési értéket ad vissza.
              Hiba esetén EOF-t.
            </para>
          </section>
      </section>
    </section>

    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <section>
            <title>C és C++</title>
            <para>                
              C-ben üres paramlista azt jelenti hogy tetszőleges számú parammal hívható.
              C++-ban azonban ez konkrétan az alábbit jelenti:
            </para>
<literallayout>
void foo(void){}
</literallayout>
            <para>
              Ha azonban előre nem definiált számú paraméteres hívást akarunk, akkor használjuk a köv alakot:
            </para>
<literallayout>
void foo(...){}
</literallayout>
          <para>
            Másik eltérés a visszatérési típus explicit specifikálása:
          </para>
<literallayout>
foo(...){}
</literallayout>
          <para>
            Ez C-ben int visszatérési typusú lesz (ugyanis implicitly assigned by compiler under the hood :) )
            C++ban ugyanez hiba compile time.
          </para>
          <para>
            C++ban a főprogram két formája szabványos
          </para>
<literallayout>
int main(){}
</literallayout>
<literallayout>
int main(int argc, char* argv[]){}
</literallayout>
          <para>
            C++-ban bevezetésre került kód olvashatóság miatt <literal>bool</literal> típus és ehhez kapcsolódóan
            <literal>bool true false</literal> kulcsszavak.
          </para>
          <para>
            C++-ban több bájtos karakterek reprezentációjára beépített típus a <literal>wchar_t</literal>.
            String literal ezen esetben <literal>L"bar"</literal>.
          </para>
          <para>
            C++-ban ahol utasítás állhat, ott állhat változó deklaráció is.
            Azaz C-hez képest nem különíthető el a body deklarációs és utasításos részre.
          </para>
          <para>
          </para>
        </section>
        <section>
          <title>Function overloading</title>
          <para>
            C-ben egy függvényt neve azonosítja egyértelműen.
            C++-ban azonban neve ÉS formális param listája együttesen.
            Az overload során létrehozott változatoknak meg KELL egyezniük visszatérési típusukban.
          </para>
          <para>
            C linker aláhúzás+function name-et használ, azonban C++ esetében az overload megvalósítása miatt mást alkalmaznak. 
          </para>
          <para>
            C++ esetében a formális paraméterek alapján képzett prefixumot vagy posztfixumot adnak a függvény névhez.
            Ez a name mangling. Ennek pontos kivitelezése egyrészt nem sztenderdizált, hanem implementáció függő.
          </para>
          <para>
            Ez persze elég problémássá teszi a C és C++ közti hívást.
            A non-mangling "bekapcsolható" ha <literal>extern</literal>-el specifikáljuk hogy mangling nélkül fordítsunk.
          </para>
<literallayout>
extern "C" int foo(int flags)
{
}
</literallayout>
        </section>
        <section>
          <title>Alapértelmezett függvény argumentumok</title>
          <para>
            Lehetséges default értékek definiálására formális paraméterek számára.
            Vegyünk egy példát.
          </para>
<literallayout>
extern "C" int bar(int a, int b, int c){}
</literallayout>
          <para>
            Default-olás hátulról indul és folyamatos kell hogy legyen.
          </para>
<literallayout>
int bar(int a, int b = 10, int c = 10){} //Jó
int bar(int a, int b=10, int c){}        //Rossz
</literallayout>
          <para>
            Hívásnál hátulról kezdve hagyhatóak el.
          </para>
<literallayout>
bar(0,0){}   //Jó
bar(0,,0){}  //Rossz
</literallayout>
          <para>
            Default-olni egyszer definícióban és deklarációban nem lehet.
            (Érdemes decl-nél megadni, mert user úgyis a header-t fogja nézni.)
          </para>
<literallayout>
int bar(int a, int b = 10, int c = 10);   //Idáig még oké 
int bar(int a, int b = 10, int c = 10){}  //Ez pedig hiba
</literallayout>
        </section>
        <section>
          <title>Paraméterátadás referencia típussal</title>
          <para>
            C-ben by value pass érvényes, ezért amikor azt akarjuk hogy a hívott függvény hatása látszódjon 
            hívónál cím szerinti átadást alkalmazunk.
          </para>
          <para>
            C++-ban egy újabb lehetőséget vezet be. Ehhez először bevezeti a referencia típust melyet egy &amp; jellel jelezhetünk pl:
          </para>
<literallayout>
void foo(int&amp; a)
{
  a = 5;
}
</literallayout>  
          <para>
            Fent vázolt esetben a hívó látni fogja az általa megadott aktuális paraméteren a változást.
            Referenciát MINDIG inicializálni KELL.
          </para>
          <para>
            Apró kis probléma a ref visszaadás. Ennek során egy ideiglenes ref változót hoz létre a fordító.
          </para>
<literallayout>
int&amp; bar()
{
  int x = 5;
  return x;
}

int calc(int a, int&amp; b)
{
  return 2*a*b;
}
int main()
{
  std::cout&lt;&lt;calc(a,bar());
}
</literallayout>  
          <para>
            Itt annyi történik, hogy invalid területre hivatkozunk, hogy x bar végrehajtásakor élt.
            bar után nem garantált léte, és ha le is fut a dolog továbbra is a referencia a verem egy olyan helyére hivatkozik, ami nekünk nem állt szándékunkban.
          </para>
        </section>
        <section>
          <title>Objektum orientáltság</title>
          <para>
            A C++-ban lehetőség van összetartozó adatok és rajtuk végzendő műveletek egy egységbe való foglalására.
            Az elv encapsulation(egységbe zárás), és a megfelelő adatok és műveletek összefogását a class-ok(osztályok) hivatottak elérni.
            A class-oknak instance-ei (példányai) léteznek, és ezek konkrét adat értékei eltérőek, de típusaik és nevük megegyezik, illetve a műveletek egyeznek.
            Inheritance-ről (öröklés) is beszélhtünk, ahol mind a műveletek, mind az állapotváltozók örökölhetőek.
            Más nyelvek ezt direkt tiltják, mert kora 2000-es évekbeli inheritance rémálommá válhatnak a projektek, ezért csak interface-ek implementációját engedik.            
            Data hidingról (Adatrejtés) akkor beszélhetünk, ha például nem akarjuk engedni, hogy valamilyen implementációs detailhez osztályon kívülről hozzáférhessenek.
            A substitutability (behelyettesíthetőség) azon mélyebb elvet takarja, hogy ha egy általánosabb osztályon értelmezhető egy műveet például, akkor a specifikáltabb osztályon is értelmezhető az.
          </para>
          <para>
            Az osztálynak tagváltozói, tag függvényei vannak. Maga az osztály egyébként egyben egy hatáskör is.
            Ez azért van így, mert küönben name clash alakulhatna ki küönböző osztályok tag változói és tag függvényeinek nevei között.
          </para>
          <para>
            A tagfüggvényeknek vagy egy láthatatlan első paraméterük, amiben megkapják a struktúrára mutató ptr-t.
            Erre a <literal>this</literal>-el hivatkozhatunk.
          </para>
          <para>
            Data hiding-ra private, public, protected használható.
            Private esetben csak az osztályon belül elérhető. Public esetben belül kívül. Protected esetben az osztályon belülről és minden leszármazottban.
          </para>
          <para>
            Az objektum inicializálását egy konstruktor végzi. Ha a konstruktornak nincsenek paraméterei akkor azt default constructor-nak hívjuk.
            Ha egy paramétere van akkor azt gyakran konverziós konstruktornak nevezzük.
            Az objektum életciklusa végén a destruktor hívódik meg.
          </para>
          <para>
            C++ osztályok a C struct-okhoz képest nem feltétlenül az attribútumok által meghatározott méretben és rendben foglalnak helyet a memóriában.
          </para>
        </section>

        <section>
          <title>Dinamikus adattagot tartalmazó osztályok</title>
          <para>
            C-ben a <literal>malloc</literal> és <literal>free</literal> vot használatos a dinamikus foglalásra.
            Malloc nem kezelte a típusokat, hanem egyenesen a lefoglalandó méretet várta
          </para>
          <para>
            C++-ban a <literal>new</literal> és <literal>delete</literal> használatos amik már típus alapján képesek a méretet számítani.
            Továbbá new egyben a ctor hívását is elvégzi a megadott argumnetumok alapján.
            Mivel az új <literal>new</literal>-ba nem adhatjuk be explicit a méretet, ezért a C-style array malloc nem fog működni.
            Emiatt <literal>new[]</literal> és <literal>delete[]</literal> került bevezetésre tömböknek történő helyfoglaláshoz és felszabadításhoz.
            <literal>new[]</literal> esetén nem adhatunk meg argumentumokat ctor híváshoz ezért a default ctor hívódik meg.
            Természetesen ha nem létezik default ctor, akkor compile time error-t fogunk kapni.
          </para>
          <para>
            Amennyiben osztályunk dinamikus adattagot tartalmaz aminek életciklusáért mi vagyunk felelősek, 
            akkor az osztály destruktorában el kell végeznünk a felszabadítást.
          </para>
          <para>
            Másoló konstruktor esetén egy új objektumot hozunk létre egy előző alapján, az előző módosítása nélkül.
            Ez beépített típusoknál viszonylag egyszerű bitenkénti átmásolást jelent, viszont user defined esetekben erről nekünk kell gondoskodnunk.
          </para>
<literallayout>
T(const T&amp; o){}
</literallayout>
          <para>
            Ha dinamikus tagot tartalmaz osztályunk aminek életciklusáért mi vagyunk felelősek, akkor előáll egy probléma:
            Ha csak átmásoljuk a ptr-et A objektumból B ctorában, akkor ha A élete hamarabb véget ér (és lefut a dtor ezáltal felszabadítva a dinamikus tagot),
            akkor mellékhatásként B egy mostmár nem valid memóriterületre fog mutatni és nem értesül a változásról.        
          </para>
          <para>
            Ilyenkor lehetséges megoldás a ptr által mutatott adat(ok) teljes rekonstrukciója egy újonnan igényelt helyen a memóriában.
            Ezt hívjuk deep copy-nak.
            Amikor ilyenről nincs szó, akkor shallow copy-ról beszélünk. A compiler álta auto generált copy ctor shallow copy-t valósít meg.
          </para>
        </section>
        <section>
          <title>Friend függvények és osztályok</title>
          <para>
            C++-ban lehetsőég van, hogy egy osztály globális függvényeket, vagy más osztályok tagfüggvényiet feljogosítsa,
            hogy tagváltozóihoz és tagfügvényeihez hozzáférjenek.
          </para>
          
          <para>
            Friend függvényekre példa:
          </para>
<literallayout>
class Bar;

void howdareyou(Bar&amp; b);

class Stranger{
void danger(Bar&amp;);
};

class Bar{
int y;
int x;
friend void howdareyou(Bar&amp;);
friend void Stranger::danger(Bar&amp;);
};

void Stranger::danger(Bar&amp; b){
  b.x=b.y=0;
}

void howdareyou(Bar&amp; b){
  b.x=b.y=0;
}
</literallayout>
          <para>
            Friend osztályra példa:
          </para>
          
<literallayout>

class Stranger;

class Bar{
int y;
int x;
friend class Stranger;
};

class Stranger{
void danger(Bar&amp; b){
b.x=b.y=0;
}
};
</literallayout>
          <para>
            A class friend "jogosítványa" nem öröklődik subclass-okra. Illetve friend "jogosítvány" nem tranzitív.
          </para>
        </section>
        <section>
          <title>Tagvátozók inicializálása</title>
          <para>
            Először is tisztázzuk a az inicializálást és az értékadást!
          </para>
          <para>
            Inicializálás
          </para>
<literallayout>
int i = 0; 
Foo foo1(1,2);
int k;
Foo foo1;
</literallayout>
          <para>
            Értékadás
          </para>
<literallayout>
int i; 
i = 6;
</literallayout>
          <para>
            Menjünk kicsit mélyebbre, nézzük meg Foo-t!
          </para>
<literallayout>
class Foo
{
public:
  Foo(int av, int bv)
  { a=av; b=bv;}
int a;
int b;
};
</literallayout>
          <para>
            ctor testben <literal>a=av</literal> és <literal>b=bv</literal> már értékadásnak számítanak.
            Ha mégis inicializálni akarjuk a dolgokat, akkor a C++ a ctor initializer listet nyújtja segítségül.
          </para>
<literallayout>
class Foo
{
public:
  Foo(int av, int bv) : a(av), b(bv){}
int a;
int b;
};
</literallayout>
        <para>
          Ez akkor lehet hasznos, amikor valami miatt tartózkodni akarunk az assignment-től. 
          Bár gyakoribb hogy olyan taggal kell dologznunk akinek simán nincs default ctor-a.
          Ezen esetben technikailag nincs más lehetőségünk mint ctor initializer list-et használni.
        </para>
        </section>
        <section>
          <title>Statikus tagok</title>
          <para>Osztályok esetén lehetőségünk van olyan tagok létrehozására, melyek nem példányok, hanem az osztálynak részei.</para>
          <para> Deklarálni static keyworddel tudjuk, viszont ez nem elég, ugyanis ez nem biztosít hely foglalást.</para>
          <para>Azaz például a cpp fájlban külön fel kell tüntetni.</para>
<literallayout>
-- foo.hpp
class Foo
{
public:
  Foo(){}
  static int a;
};
-- foo.cpp
int Foo::a = 1;
</literallayout>
        <para>Kívülről az osztály namespace-én keresztül kell elérni, azaz</para>
<literallayout>
fn_int_consumer(Foo::a);
</literallayout>
        <para>
          Statikus tagfüggvények is definiálhatóak, viszont ezekből (logikus módon) nem érhetőek el a példányokra jellemző tagok.
          Sőt...logikus módon implicit egyedre mutató ptr-t sem kapnak (azaz this ne értelmezett, hisz nem példányra jellemző tagfüggvény).
        </para>
<literallayout>
-- foo.hpp
class Foo
{
public:
  Foo(){}
  static void naughty()
  {
    a = 0; HIBA!!!
    this->a = 0; HIBA!!!
  }
  int a;
};
-- foo.cpp
int Foo::a = 1;
</literallayout>
         <para>
          A statikus tagváltozók a <literal>main</literal> előtt inicializálódnak!
          Azaz nem garantálható egy C++ programban, hogy a main első sora lesz a kezdő sor. (plusz még ott vannak a globális változók initjei)
         </para>
        </section>
        <section>
          <title>Beágyazott (nested) definíciók</title>
          <para>
            C++ esetében lehetőség van enum, struct, class és typedef osztály definíción belüli megadására.
            Ezek kívülről a teljesen mnősített nevükkel érhetőek el pl.
          </para>
<literallayout>
class Foo
{
class Bar{};
};
-- Foo::Bar
</literallayout>
          <para>
            Nestelt esetben sem a nestet megvalósító(tartalmazó) osztály sem a nestelt (tartalmazott) osztály nem kap a másik felé külön jogokat.
            A külvilág számára a private után deklarált nestelt class-ok nem láthatóak.
            STL-ben gyakran találkozhatunk ilyen nested class-okkal container-ek esetén.
          </para>
        </section>
        <section>
          <title>Konstansok és inline függvények</title>
          <para>
            C-ben konstansokra gyakran használják a preprocesszor adta lehetőségeket <literal>#define</literal>-al.
            Ez azonban valójában csak nyers behelyettesítést jelent. Szószerint a preprocesszor csak felcseréli
            a define-al definiált szimbólumsor összes előfordulását a megadott nyers értékkel.
            Ezáltal type információt sem képes rögzíteni "magáról". 
          </para>
          <para>
            C++ esetében a <literal>const</literal> type modifier-t használhatjuk.
            Ezzel jelezzük a compiler számára, hogy az érték init után garantáltan nem fog változni,
            és ha ilyet írnánk, kezelje hibaként.
          </para>
          <para>
            Const ptr-ek esetén két különböző dolgot is megadhatunk
          </para>
          <para>
            A mutatott érték ne legyen változtatható
          </para>
<literallayout>
char t[10];
const char* p = t;
*p = 0;  HIBA!
p++;     OK!
</literallayout>
          <para>
            A mutató érték ne legyen változtatható
          </para>
<literallayout>
char t[10];
char* const p = t;
*p = 0;   OK!
p++;      HIBA!
</literallayout>
          <para>
            Const függvény paraméterek esetén is használható.
            Ekkor azt a jelentést beszi fel, hogy a paraméter olvasható, de nem változtatható.
            Vegyük például referenciákat:
          </para>
<literallayout>
void foo(Foo&amp; o)
{
  o.x=5;  OK!
}

void foo(const Foo&amp; o)
{
  o.x=5;  HIBA!
}
</literallayout>
        <para>
          Függvények visszatérési értéke is lehet konstans. Például std::string c_str tagfüggvénye.
          A const overaload szempontjából megkülönböztető jelentőségű.
        </para>
        <para>
          Osztályok tagváltozói is lehetnek konstansok.
          Ezeket a ctor initializer list-ben KELL inicializálni.
        </para>
        <para>
          Const függvények fejlécének végén is használható annak kifejezésére, hogy a függvénynek
          garantáltan nincs olyan mellékhatása mely módosítani a példány állapotát.
          Ha azonban egy const függvényben mégis módosítani akarunk egy tagváltozót,
          akkor az nem lehet static vagy const és a <literal>mutable</literal>-t kell használni.
        </para>
<literallayout>
class Foo
{
public:
const int a;
mutable int b;
void safe() const{b = 7;}
};
</literallayout>
        </section>
        <section>
          <title>C++ IO alapjai</title>
          <para>Ezen alfejezetben a C++ IO-val fogunk foglalkozni, kicsit a C-ből indulva.</para>
          <section>
            <title>Szabványos adatfolyamok</title>
            <para>
              C nyelvben három előre megnyitott szabványos állomány leíró áll rendelkezésre. stdin, stdout és stderr.
              A C++ adatfolyamokban gondolkodik, ami felfogható byte-ok sorának.
              Egy folyam lehet bemeneti (istream), kimeneti (ostream), vagy ezek kombinációja.
              A könyv azt írja, hogy a kimenetnek alapértelmezetten a képernyő a kimenete.
              Ez szerintem nem teljesen van így (mármint ha jól értem akkor arra gondolhatott a szerző,
              hogy ha terminál ablakból nyitottuk, akkor annak az OS által kialakított OS dependens terminálnak valamilyen módon ír egy bufferére,
              ami a végén azt eredményezi hogy megjelenik a szöveg a terminál ablakban. De nem direkt a képernyőn jelenik meg még ekkor sem...).
            </para>
            <para>
              std namespace cout, cin és cerr megfeleltethető a C-s szabvány állományoknak céljuk és rendeltetésük szerint.
              A left shift &lt;&lt; alkalmazható cout-on (ostream) a kiírásra, míg a &gt;&gt; right shift operátorral cin-ből végezhetünk beolvasást.
              cin esetén fontos tudni, hogy whitespace jellegű karaktereket elhagyja.
              Alább egy példa a folyam állapotáról:
            </para>
<literallayout>
#include &lt;iostream&gt;
int main()
{
  std::cout&lt;&lt;"Enter an int: "&lt;&lt;std::endl;
  int i;
  std::cin >> i;
  std::cout&lt;&lt;"Enter a dbl: "&lt;&lt;std::endl;
  double d;
  std::cin >> d;
  if(cin)
    std::cout&lt;&lt;"The number was "&lt;&lt;i&lt;&lt;", "&lt;&lt;d&lt;&lt;std::endl;
  else
    std::cout&lt;&lt;"It was not a number"&lt;&lt;std::endl;
}
</literallayout>
          <para>
            A fent megadott kód a következő user input-ra <literal>12.3</literal> 
            várakozásunk ellenére <literal>12, 0.3</literal>-at fog kiírni anélkül hogy bekérné a double-t,
            vagy hibát dobna 12.3-nál.
            C-ben <literal>fflush(stdin);</literal>-el értük el az eddigi adatok ejtését (azaz a flush-t).
            C++-ban más módon ugyan de azt megtudjuk adni, hogy a sorvége karakterig hagyja figyelmen kívü a karaktereket.
          </para>
<literallayout>
#include &lt;limits&gt;
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(),'\n');
</literallayout>
          <para>
            A <literal>numeric_limits</literal> első paramétere megadja hány karaktert ignoráljunk legfeljebb, míg a másik argumentummal
            azt adjuk meg melyik karakterig.
          </para>
          <para>
            flush-ra egyébként van lehetőség a bufferelt adatfolyamokon:
          </para>
<literallayout>
std::cout&lt;&lt;std::flush;

std::cout.flush();
</literallayout>
          <para>
            A cerr nem bufferelt, ami segítség, ha pl. memória szűkében állunk és pont ezt akarjuk kiírni, hiszen
            ha bufferelni kéne, nem lenne elég memóriánk, hisz pontosan amiatt kezdtük el a hiba írást.
          </para>
          <para>
            A clog, hasonló rendeltetésű mint a cerr, azonban ez bufferelt.
          </para>
          <para>
            Az adatfolyam állapotát egy iostate nevű tagváltozó reprezentálja.
            Ez a következő értékeket veheti fel:
            <itemizedlist>
              <listitem>
                  <para>eofbit: adatfolyam elérte végét</para>
              </listitem>
              <listitem>
                  <para>failbit: pl. formátummal hiba</para>
              </listitem>
              <listitem>
                  <para>badbit: fatáis hiba, pl. adatvesztés</para>
              </listitem>
              <listitem>
                  <para>goodbit: egyik másik állapot sem áll fenn</para>
              </listitem>
            </itemizedlist>
            Ezek együtt maszkokként használandóak, alább példa:
          </para>
<literallayout>
std::cout.clear(std::ios::eofbit | std::ios::failbit);
</literallayout>
          <para>
            A bit-ek lekérdezése tagfüggvényekkel történik, pl.:
          </para>
<literallayout>
bool g = std::cout.good();
</literallayout>
  <para>
    Ha az adatfolyam bármely hibabitje beállítódik, akkor az össze további írási és olvasási tevékenység
    hatástalan marad.
  </para>
  <para>
    Az adatfolyam igaz-hamis értékké történő kiértékelése hamisat ad, ha bármely hiba bit be van állítva.
    Ennek logikusan tagadás is működik
  </para>
<literallayout>
while(std::cin>>v)
{siker(v);}

if(!cin)
{std::cout&lt;&lt;"Err"&lt;&lt;std::endl);}
</literallayout>
      <para>
        Az istream osztálynak egyéb hasznos tagfüggvényei is vannak.
      </para>
      <para>
        get() utolsó karakter vagy eof visszaadása.
      </para>
      <para>
        getline() egy sor olvasása a sorvégig vagy más hatroló karkterig
      </para>
      <para>
        fread() bináris adat olvasása.
      </para>
          </section>
          <section>
            <title>Manipulátorok és formázás</title>
            <para>Az előre deiniált manipulátorokat az iomanip header-ben találjuk</para>
            <para>
              Például a <literal>noskipws</literal> segítségével beállíthatjuk hogy a sztenderd input
              ne ignorálja a whitespace karaktereket.
              <literal>skipws</literal>-el pedig visszatudjuk ezt állítani.
            </para>
<literallayout>
std::cin>>std::noskipws;
std::cin>>std::skipws;
</literallayout>
            <para>
              A <literal>setprecision</literal>-el a megjelenített tizedestört kiírási pontosságát állíthatjuk be
              például <literal>setprecision(4)</literal>.
              A formázásra különböző jelző bitek szolgálnak.
              Alább példa lebegőpontos szám tizedestört alakban történő kiírására:
            </para>
<literallayout>
cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;3.14&lt;&lt;endl;
cout&lt;&lt;resetiosflags(ios::fixed);
</literallayout>

          </section>
          <section>
            <title>Állománykezelés</title>
            <para>
              C-ben az állomány kezelés FILE* típusú leíróval kapcsolatos függvényekkel történik.
              C++-ban ez is adatfolyamokkal történik. Ezek <literal>ifstream</literal> <literal>ofstream</literal> az ezekhez kapcsolódó
              header <literal>fstream</literal> fájlban taláhatóak.
              Az állományok megnyitását ezen objektumok konstruktorai, míg lezárást ezek destruktorai végzik.
            </para>
            <para>
              Egyes OS-k eltérően ábrázolhatják és kezelhetik egyes speciális karakterek csoportját.
              Legegyszerűbb a WIN-re jellemző carriage return + new line.
              Emiatt olykor érdemes lehet binárisban nyitni a fájlt(begyük észre a flag-ek össze vagy-olását):
            </para>
<literallayout>
ofstream ofs("sample.txt", ios::out | ios::binary)
</literallayout>
            <para>
              Ha valami miatt nem ctor-ban akarjuk nyitni a fájlt, vagy nem dtor-ban zárni, akkor
              <literal>open()</literal>, <literal>close()</literal> és <literal>is_open()</literal>
              állnak rendelkezésünkre.
            </para>
            <para>
              Bizonyos állományok esetén pozícionálásra is van szükség. 
            </para>
            <para>
              <literal>tellg()</literal> visszaadja a jelenlegi pozíciót.
            </para>
            <para>
              <literal>seekg(position)</literal> a megadott pozíciót állítja be.
            </para>
            <para>
              <literal>seekg(offset,position)</literal> Relatíve a pozícióhoz képest állítja be az offset által megadott pozíciót.
              position lehet:
              <literal>ios::beg</literal> állomány kezdet,
              <literal>ios::end</literal> állomány vég,
              <literal>ios::cur</literal> jelen pozíció.
            </para>
            <para>
              Az ezekkel beállított pozíciók validitását a hívónak (szóval a programozónak) a felelőssége garantálni.
            </para>
            <para>
              Átirányításra alább egy példa
            </para>
<literallayout>
// Állományt nyitjuk
ofstream log_file("log.txt");
// clog formázási beállításainak másolás
log_file.copyfmt(clog);
// clog eredeti bufferének eltárolása
streambuf* clog_buf=clog.rdbuf();
// clog buffere az állomány buffere lesz
clog.rdbuf(log_file.rdbuf());
// Ezen a ponton clog már át van irányítva
clog&lt;&lt;"Redirect happend "&lt;&lt;endl;
// Régi buffer vissza
clog.rdbuf(clog_buf); 
</literallayout>
          </section>
        </section>
        <section>
          <title>Operátorok és túlterhelésük</title>
          <para>
            Az operátorok argumentumaikon végzett műveletekkel
            visszatérési értéket álíltanak elő.
            Általában emiatt használjuk őket, de egyes operátorok
            ezenkívül argumentumaikon végzett változtatásuk miatt (mellékhatás)
            is hasznosak.
          </para>
          <para>
            Operátorok kiértékelési sorrendjét a nyelv által lefeketetett minden
            implementáció által betartandó precedencia táblázat rögzíti.
          </para>
          <section>
            <title>Függvényszintaxis és túlterhelés</title>
            <para>
              C nyelv esetében a függvényeknek nem lehet mellékhatásuk a pass by value miatt.
              Az egyetlen mód a kikényszerítésére ha ptr-t adunk át.
              C++ esetében azonban referenciák használatával ez már nem így van.
            </para>
            <para>
              Példának vegyünk egy postfix operátort
            </para>
<literallayout>
int postfix_incr(int&amp; arg)
{
  int a = arg;
  arg = arg +1;
  return a;
}

int main()
{
  int i = 1;
  int j;
  j= i++;
  j = postfix_incr(i);
}
</literallayout>
            <para>
              A fenti példa is mutatja, hogy az operátorok és a függvények között csak nagyon kis különbség van.
              A különbség csak a kiértékelés szabályaiban van.
              Sőt, szószerint függvény hívási szintaxissal is hívhatjuk!
            </para>
<literallayout>
++i;
operator++ (i);
</literallayout>
            <para>
              Mintahogy a függvények, úgy az operátorok is túlterhelhetőek.
              Alapvetően a global namespace-ben kell dolgozni:
            </para>
<literallayout>
Foo operator(double d, Foo z);
</literallayout>
            <para>
              Ha azonban az első paraméter olyan user defined type (class) amit mi írtunk, 
              akkor azon adott osztály tagfüggvényeként fogalmazzuk meg!
            </para>
<literallayout>
Foo Foo::operator(Foo a, Foo b);
</literallayout>
            <para>
            </para>
          </section>
          <section>
            <title>Speciális operátorok túlterhelése</title>
            <para>
              Az életciklus szempontjából nem triviális az assignment, értékadás operátor túlterhelése. 
              Dinamikus adattagokat tartalmazó osztályban ezt érdemes végig gondolni.
              A ctor-okat is behozva a témába a következő életciklust befolyásoló esetek vannak:
              <itemizedlist>
              <listitem>
                  <para>deafult ctor</para>
              </listitem>
              <listitem>
                  <para>other ctors</para>
              </listitem>
              <listitem>
                  <para>copy ctor</para>
              </listitem>
              <listitem>
                  <para>copy assignment</para>
              </listitem>
              <listitem>
                  <para>move ctor</para>
              </listitem>
              <listitem>
                  <para>move assignment</para>
              </listitem>
            </itemizedlist>
              Ezeket érdemes mindig elkészíteni. Ha egy ctor-t definiáltunk, akkor a hozzátartozó assignment-et is definiálni kell szabály szerint.
              Ha mondjuk valamit nagyon nem akarunk (pl.: non-copyable) akkor érdemes azokat direkt töröltetni, megakadályozva a compiler generálta shallow copy implementációt.
            </para>
            <para>
              Deafult ctor-ról már volt szó. Hiánya esetén az inicializálást kezelnünk kell majd ha beépítjük más osztályba.
            </para>
            <para>
              Más ctor-ok, ezeknél talán az egy paraméterűek speciálisak, ugyanis ezek konverzióknál használhatóak. (És a compiler is megpróbálja őket használni, ha csak nem tiltjuk meg)
            </para>
            <para>
              Copy ctor és assignment esetén egy létező példány alapján egy teljesen újat akarunk kialakítani.
              Mindezt úgy, hogy a másolandó állapotát nem változtathatjuk (azaz max mutable változókhoz nyúlhatunk hozzá)
            </para>
          </section>
        </section>
    </section>  
    <!-- TODO BMECPP -->  
  
</chapter>                
